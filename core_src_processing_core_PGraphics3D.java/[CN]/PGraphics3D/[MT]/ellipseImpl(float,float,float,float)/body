{
  float radiusH=w / 2;
  float radiusV=h / 2;
  float centerX=x + radiusH;
  float centerY=y + radiusV;
  float sx1=screenX(x,y);
  float sy1=screenY(x,y);
  float sx2=screenX(x + w,y + h);
  float sy2=screenY(x + w,y + h);
  if (fill) {
    int accuracy=(int)(TWO_PI * PApplet.dist(sx1,sy1,sx2,sy2) / 20);
    if (accuracy < 6)     accuracy=6;
    float inc=(float)SINCOS_LENGTH / accuracy;
    float val=0;
    boolean strokeSaved=stroke;
    stroke=false;
    boolean smoothSaved=smooth;
    if (smooth && stroke) {
      smooth=false;
    }
    beginShape(TRIANGLE_FAN);
    normal(0,0,1);
    vertex(centerX,centerY);
    for (int i=0; i < accuracy; i++) {
      vertex(centerX + cosLUT[(int)val] * radiusH,centerY + sinLUT[(int)val] * radiusV);
      val=(val + inc) % SINCOS_LENGTH;
    }
    vertex(centerX + cosLUT[0] * radiusH,centerY + sinLUT[0] * radiusV);
    endShape();
    stroke=strokeSaved;
    smooth=smoothSaved;
  }
  if (stroke) {
    int accuracy=(int)(TWO_PI * PApplet.dist(sx1,sy1,sx2,sy2) / 8);
    if (accuracy < 6)     accuracy=6;
    float inc=(float)SINCOS_LENGTH / accuracy;
    float val=0;
    boolean savedFill=fill;
    fill=false;
    val=0;
    beginShape();
    for (int i=0; i < accuracy; i++) {
      vertex(centerX + cosLUT[(int)val] * radiusH,centerY + sinLUT[(int)val] * radiusV);
      val=(val + inc) % SINCOS_LENGTH;
    }
    endShape(CLOSE);
    fill=savedFill;
  }
}

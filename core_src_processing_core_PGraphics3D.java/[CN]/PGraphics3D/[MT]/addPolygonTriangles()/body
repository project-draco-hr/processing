{
  if (vertexOrder.length != vertices.length) {
    int[] temp=new int[vertices.length];
    PApplet.arrayCopy(vertexOrder,temp,vertexCount);
    vertexOrder=temp;
  }
  int d1=X;
  int d2=Y;
  float area=0;
  for (int p=shapeLast - 1, q=shapeFirst; q < shapeLast; p=q++) {
    area+=(vertices[q][d1] * vertices[p][d2] - vertices[p][d1] * vertices[q][d2]);
  }
  if (area == 0) {
    boolean foundValidX=false;
    boolean foundValidY=false;
    for (int i=shapeFirst; i < shapeLast; i++) {
      for (int j=i; j < shapeLast; j++) {
        if (vertices[i][X] != vertices[j][X])         foundValidX=true;
        if (vertices[i][Y] != vertices[j][Y])         foundValidY=true;
      }
    }
    if (foundValidX) {
      d2=Z;
    }
 else     if (foundValidY) {
      d1=Y;
      d2=Z;
    }
 else {
      return;
    }
    for (int p=shapeLast - 1, q=shapeFirst; q < shapeLast; p=q++) {
      area+=(vertices[q][d1] * vertices[p][d2] - vertices[p][d1] * vertices[q][d2]);
    }
  }
  float vfirst[]=vertices[shapeFirst];
  float vlast[]=vertices[shapeLast - 1];
  if ((abs(vfirst[X] - vlast[X]) < EPSILON) && (abs(vfirst[Y] - vlast[Y]) < EPSILON) && (abs(vfirst[Z] - vlast[Z]) < EPSILON)) {
    shapeLast--;
  }
  int j=0;
  if (area > 0) {
    for (int i=shapeFirst; i < shapeLast; i++) {
      j=i - shapeFirst;
      vertexOrder[j]=i;
    }
  }
 else {
    for (int i=shapeFirst; i < shapeLast; i++) {
      j=i - shapeFirst;
      vertexOrder[j]=(shapeLast - 1) - j;
    }
  }
  int vc=shapeLast - shapeFirst;
  int count=2 * vc;
  for (int m=0, v=vc - 1; vc > 2; ) {
    boolean snip=true;
    if (0 >= (count--)) {
      break;
    }
    int u=v;
    if (vc <= u)     u=0;
    v=u + 1;
    if (vc <= v)     v=0;
    int w=v + 1;
    if (vc <= w)     w=0;
    double Ax=-10 * vertices[vertexOrder[u]][d1];
    double Ay=10 * vertices[vertexOrder[u]][d2];
    double Bx=-10 * vertices[vertexOrder[v]][d1];
    double By=10 * vertices[vertexOrder[v]][d2];
    double Cx=-10 * vertices[vertexOrder[w]][d1];
    double Cy=10 * vertices[vertexOrder[w]][d2];
    if (EPSILON > (((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax)))) {
      continue;
    }
    for (int p=0; p < vc; p++) {
      if ((p == u) || (p == v) || (p == w)) {
        continue;
      }
      double Px=-10 * vertices[vertexOrder[p]][d1];
      double Py=10 * vertices[vertexOrder[p]][d2];
      double ax=Cx - Bx;
      double ay=Cy - By;
      double bx=Ax - Cx;
      double by=Ay - Cy;
      double cx=Bx - Ax;
      double cy=By - Ay;
      double apx=Px - Ax;
      double apy=Py - Ay;
      double bpx=Px - Bx;
      double bpy=Py - By;
      double cpx=Px - Cx;
      double cpy=Py - Cy;
      double aCROSSbp=ax * bpy - ay * bpx;
      double cCROSSap=cx * apy - cy * apx;
      double bCROSScp=bx * cpy - by * cpx;
      if ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0)) {
        snip=false;
      }
    }
    if (snip) {
      addTriangle(vertexOrder[u],vertexOrder[v],vertexOrder[w]);
      m++;
      for (int s=v, t=v + 1; t < vc; s++, t++) {
        vertexOrder[s]=vertexOrder[t];
      }
      vc--;
      count=2 * vc;
    }
  }
}

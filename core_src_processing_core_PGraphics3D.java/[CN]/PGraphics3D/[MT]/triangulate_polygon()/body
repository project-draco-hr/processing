{
  int d1=MX;
  int d2=MY;
  float area=0;
  for (int p=vertex_end - 1, q=vertex_start; q < vertex_end; p=q++) {
    area+=(vertices[q][d1] * vertices[p][d2] - vertices[p][d1] * vertices[q][d2]);
  }
  if (area == 0) {
    boolean foundValidX=false;
    boolean foundValidY=false;
    for (int i=vertex_start; i < vertex_end; i++) {
      for (int j=i; j < vertex_end; j++) {
        if (vertices[i][MX] != vertices[j][MX])         foundValidX=true;
        if (vertices[i][MY] != vertices[j][MY])         foundValidY=true;
      }
    }
    if (foundValidX) {
      d2=MZ;
    }
 else     if (foundValidY) {
      d1=MY;
      d2=MZ;
    }
 else {
      return;
    }
    for (int p=vertex_end - 1, q=vertex_start; q < vertex_end; p=q++) {
      area+=(vertices[q][d1] * vertices[p][d2] - vertices[p][d1] * vertices[q][d2]);
    }
  }
  float vfirst[]=vertices[vertex_start];
  float vlast[]=vertices[vertex_end - 1];
  if ((abs(vfirst[MX] - vlast[MX]) < EPSILON) && (abs(vfirst[MY] - vlast[MY]) < EPSILON) && (abs(vfirst[MZ] - vlast[MZ]) < EPSILON)) {
    vertex_end--;
  }
  int j=0;
  if (area > 0) {
    for (int i=vertex_start; i < vertex_end; i++) {
      j=i - vertex_start;
      vertex_order[j]=i;
    }
  }
 else {
    for (int i=vertex_start; i < vertex_end; i++) {
      j=i - vertex_start;
      vertex_order[j]=(vertex_end - 1) - j;
    }
  }
  int vc=vertex_end - vertex_start;
  int count=2 * vc;
  for (int m=0, v=vc - 1; vc > 2; ) {
    boolean snip=true;
    if (0 >= (count--)) {
      break;
    }
    int u=v;
    if (vc <= u)     u=0;
    v=u + 1;
    if (vc <= v)     v=0;
    int w=v + 1;
    if (vc <= w)     w=0;
    float Ax=-vertices[vertex_order[u]][d1];
    float Ay=vertices[vertex_order[u]][d2];
    float Bx=-vertices[vertex_order[v]][d1];
    float By=vertices[vertex_order[v]][d2];
    float Cx=-vertices[vertex_order[w]][d1];
    float Cy=vertices[vertex_order[w]][d2];
    if (EPSILON > (((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax)))) {
      continue;
    }
    for (int p=0; p < vc; p++) {
      if ((p == u) || (p == v) || (p == w)) {
        continue;
      }
      float Px=-vertices[vertex_order[p]][d1];
      float Py=vertices[vertex_order[p]][d2];
      float ax=Cx - Bx;
      float ay=Cy - By;
      float bx=Ax - Cx;
      float by=Ay - Cy;
      float cx=Bx - Ax;
      float cy=By - Ay;
      float apx=Px - Ax;
      float apy=Py - Ay;
      float bpx=Px - Bx;
      float bpy=Py - By;
      float cpx=Px - Cx;
      float cpy=Py - Cy;
      float aCROSSbp=ax * bpy - ay * bpx;
      float cCROSSap=cx * apy - cy * apx;
      float bCROSScp=bx * cpy - by * cpx;
      if ((aCROSSbp >= 0.0f) && (bCROSScp >= 0.0f) && (cCROSSap >= 0.0f)) {
        snip=false;
      }
    }
    if (snip) {
      add_triangle(vertex_order[u],vertex_order[v],vertex_order[w]);
      m++;
      for (int s=v, t=v + 1; t < vc; s++, t++) {
        vertex_order[s]=vertex_order[t];
      }
      vc--;
      count=2 * vc;
    }
  }
}

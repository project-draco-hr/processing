{
  ObjectReference or=event.exception();
  ReferenceType rt=or.referenceType();
  String exceptionName=rt.name();
  Field messageField=rt.fieldByName("detailMessage");
  Value messageValue=or.getValue(messageField);
  int last=exceptionName.lastIndexOf('.');
  String message=exceptionName.substring(last + 1);
  if (messageValue != null) {
    String messageStr=messageValue.toString();
    if (messageStr.startsWith("\"")) {
      messageStr=messageStr.substring(1,messageStr.length() - 1);
    }
    message+=": " + messageStr;
  }
  if (exceptionName.equals("java.lang.OutOfMemoryError")) {
    editor.statusError("OutOfMemoryError: You may need to increase the memory setting in Preferences.");
    System.err.println("An OutOfMemoryError means that your code is either using up too much memory");
    System.err.println("because of a bug (e.g. creating an array that's too large, or unintentionally");
    System.err.println("loading thousands of images), or that your sketch may need more memory to run.");
    System.err.println("If your sketch uses a lot of memory (for instance if it loads a lot of data files)");
    System.err.println("you can increase the memory available to your sketch using the Preferences window.");
  }
 else   if (exceptionName.equals("java.lang.StackOverflowError")) {
    editor.statusError("StackOverflowError: This sketch is attempting too much recursion.");
    System.err.println("A StackOverflowError means that you have a bug that's causing a function");
    System.err.println("to be called recursively (it's calling itself and going in circles),");
    System.err.println("or you're intentionally calling a recursive function too much,");
    System.err.println("and your code should be rewritten in a more efficient manner.");
  }
 else   if (exceptionName.equals("java.lang.UnsupportedClassVersionError")) {
    editor.statusError("UnsupportedClassVersionError: A library is using code compiled with an unsupported version of Java.");
    System.err.println("This version of Processing only supports libraries and JAR files compiled for Java 1.5.");
    System.err.println("A library used by this sketch was compiled for Java 1.6 or later, ");
    System.err.println("and needs to be recompiled to be compatible with Java 1.5.");
  }
 else   if (exceptionName.equals("java.lang.NoSuchMethodError") || exceptionName.equals("java.lang.NoSuchFieldError")) {
    editor.statusError(exceptionName.substring(10) + ": You're probably using a library that's incompatible with this version of Processing.");
  }
 else {
    ThreadReference thread=event.thread();
    try {
      int codeIndex=-1;
      int lineNumber=-1;
      List<StackFrame> frames=thread.frames();
      for (      StackFrame frame : frames) {
        Location location=frame.location();
        String filename=null;
        try {
          filename=location.sourceName();
          lineNumber=location.lineNumber();
          for (int i=0; i < sketch.getCodeCount(); i++) {
            SketchCode code=sketch.getCode(i);
            if (((code.getPreprocName() == null) && (lineNumber >= code.getPreprocOffset())) || ((code.getPreprocName() != null) && code.getPreprocName().equals(filename))) {
              codeIndex=i;
              break;
            }
          }
        }
 catch (        AbsentInformationException e) {
          e.printStackTrace();
        }
      }
      if (codeIndex != -1) {
        lineNumber-=sketch.getCode(codeIndex).getPreprocOffset();
      }
      exception=new RunnerException(message,codeIndex,lineNumber,-1);
      exception.hideStackTrace();
      editor.statusError(exception);
    }
 catch (    IncompatibleThreadStateException e) {
      e.printStackTrace();
    }
  }
  editor.internalRunnerClosed();
}

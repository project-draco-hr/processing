{
  if (updateElement != -1) {
    throw new RuntimeException("PShape3D: only one element can be updated at the time");
  }
  updateElement=element;
  firstUpdateIdx=numVertices;
  lastUpdateIdx=-1;
  if (updateElement == VERTICES) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glVertexBufferID[0]);
    int offset=first * 3;
    int size=(last - first + 1) * 3;
    vertexBuffer.limit(vertexBuffer.capacity());
    vertexBuffer.rewind();
    vertexBuffer.get(vertexArray,offset,size);
    creatingGroup=false;
    firstSetGroup=true;
  }
 else   if (updateElement == COLORS) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glColorBufferID[0]);
    int offset=first * 4;
    int size=(last - first + 1) * 4;
    colorBuffer.limit(colorBuffer.capacity());
    colorBuffer.rewind();
    colorBuffer.get(colorArray,offset,size);
  }
 else   if (updateElement == NORMALS) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
    int offset=first * 3;
    int size=(last - first + 1) * 3;
    normalBuffer.limit(normalBuffer.capacity());
    normalBuffer.rewind();
    normalBuffer.get(normalArray,offset,size);
  }
 else   if (TEXTURES1 <= updateElement && updateElement <= TEXTURES4) {
    int n=updateElement - TEXTURES1;
    if (numTexUnits <= n) {
      throw new RuntimeException("PShape3D: not enought texture units in use by his shape.");
    }
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[n]);
    int offset=first * 2;
    int size=(last - first + 1) * 2;
    texCoordBuffer.limit(texCoordBuffer.capacity());
    texCoordBuffer.rewind();
    texCoordBuffer.get(texCoordArray,offset,size);
  }
 else   if (updateElement == GROUPS) {
    deleteGroups();
  }
 else {
    throw new RuntimeException("PShape3D: unknown element to update");
  }
}

{
  if (updateElement != -1) {
    throw new RuntimeException("GLModel: only one element can be updated at the time");
  }
  updateElement=element;
  if (updateElement == VERTICES) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glVertexBufferID[0]);
    firstUpdateIdx=numVertices;
    lastUpdateIdx=-1;
    if (updateVertexArray == null) {
      updateVertexArray=new float[vertices.capacity()];
      vertices.get(updateVertexArray);
      vertices.rewind();
    }
  }
 else   if (updateElement == COLORS) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glColorBufferID[0]);
    firstUpdateIdx=numVertices;
    lastUpdateIdx=-1;
    if (updateColorArray == null) {
      updateColorArray=new float[colors.capacity()];
      colors.get(updateColorArray);
      colors.rewind();
    }
  }
 else   if (updateElement == NORMALS) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
    firstUpdateIdx=numVertices;
    lastUpdateIdx=-1;
    if (updateNormalArray == null) {
      updateNormalArray=new float[normals.capacity()];
      normals.get(updateNormalArray);
      normals.rewind();
    }
  }
 else   if (updateElement == TEXTURES) {
    for (int i=0; i < groups.size(); i++)     if (((VertexGroup)groups.get(i)).textures[selectedTexture] == null)     throw new RuntimeException("GLModel: texture must be set first in group " + i);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[selectedTexture]);
    firstUpdateIdx=numVertices;
    lastUpdateIdx=-1;
    if (updateTexCoordArray == null) {
      updateTexCoordArray=new float[texCoords[selectedTexture].capacity()];
      texCoords[selectedTexture].get(updateTexCoordArray);
      texCoords[selectedTexture].rewind();
    }
  }
 else   if (updateElement == GROUPS) {
    groupBreaks.clear();
  }
 else {
    throw new RuntimeException("GLModel: unknown element to update");
  }
}

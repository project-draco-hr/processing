{
  if (updateElement != -1) {
    throw new RuntimeException("GLModel: only one element can be updated at the time");
  }
  updateElement=element;
  firstUpdateIdx=numVertices;
  lastUpdateIdx=-1;
  if (updateElement == VERTICES) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glVertexBufferID[0]);
    if (updateVertexArray == null) {
      updateVertexArray=new float[vertices.capacity()];
    }
    int offset=first * 3;
    int size=(last - first + 1) * 3;
    vertices.get(updateVertexArray,offset,size);
    vertices.rewind();
  }
 else   if (updateElement == COLORS) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glColorBufferID[0]);
    if (updateColorArray == null) {
      updateColorArray=new float[colors.capacity()];
    }
    int offset=first * 4;
    int size=(last - first + 1) * 4;
    colors.get(updateColorArray,offset,size);
    colors.rewind();
  }
 else   if (updateElement == NORMALS) {
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
    if (updateNormalArray == null) {
      updateNormalArray=new float[normals.capacity()];
    }
    int offset=first * 3;
    int size=(last - first + 1) * 3;
    normals.get(updateNormalArray,offset,size);
    normals.rewind();
  }
 else   if (updateElement == TEXTURES) {
    for (int i=0; i < groups.size(); i++)     if (((VertexGroup)groups.get(i)).texture == null)     throw new RuntimeException("GLModel: texture must be set first in group " + i);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[0]);
    if (updateTexCoordArray == null) {
      updateTexCoordArray=new float[texCoords.capacity()];
    }
    int offset=first * 2;
    int size=(last - first + 1) * 2;
    texCoords.get(updateTexCoordArray,offset,size);
    texCoords.rewind();
  }
 else   if (updateElement == GROUPS) {
    groupBreaks.clear();
  }
 else {
    throw new RuntimeException("GLModel: unknown element to update");
  }
}

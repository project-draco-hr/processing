{
  if (valueShift == SHADE) {
    for (int j=0; j < steps; j++) {
      int[] cols={color(255 - (255 / steps) * j,255 - (255 / steps) * j,0),color(255 - (255 / steps) * j,(255 / 1.5f) - ((255 / 1.5f) / steps) * j,0),color(255 - (255 / steps) * j,(255 / 2) - ((255 / 2) / steps) * j,0),color(255 - (255 / steps) * j,(255 / 2.5f) - ((255 / 2.5f) / steps) * j,0),color(255 - (255 / steps) * j,0,0),color(255 - (255 / steps) * j,0,(255 / 2) - ((255 / 2) / steps) * j),color(255 - (255 / steps) * j,0,255 - (255 / steps) * j),color((255 / 2) - ((255 / 2) / steps) * j,0,255 - (255 / steps) * j),color(0,0,255 - (255 / steps) * j),color(0,255 - (255 / steps) * j,(255 / 2.5f) - ((255 / 2.5f) / steps) * j),color(0,255 - (255 / steps) * j,0),color((255 / 2) - ((255 / 2) / steps) * j,255 - (255 / steps) * j,0)};
      for (int i=0; i < segs; i++) {
        fill(cols[i]);
        arc(x,y,radius,radius,interval * i + rotAdjust,interval * (i + 1) + rotAdjust);
      }
      radius-=segWidth;
    }
  }
 else   if (valueShift == TINT) {
    for (int j=0; j < steps; j++) {
      int[] cols={color((255 / steps) * j,(255 / steps) * j,0),color((255 / steps) * j,((255 / 1.5f) / steps) * j,0),color((255 / steps) * j,((255 / 2) / steps) * j,0),color((255 / steps) * j,((255 / 2.5f) / steps) * j,0),color((255 / steps) * j,0,0),color((255 / steps) * j,0,((255 / 2) / steps) * j),color((255 / steps) * j,0,(255 / steps) * j),color(((255 / 2) / steps) * j,0,(255 / steps) * j),color(0,0,(255 / steps) * j),color(0,(255 / steps) * j,((255 / 2.5f) / steps) * j),color(0,(255 / steps) * j,0),color(((255 / 2) / steps) * j,(255 / steps) * j,0)};
      for (int i=0; i < segs; i++) {
        fill(cols[i]);
        arc(x,y,radius,radius,interval * i + rotAdjust,interval * (i + 1) + rotAdjust);
      }
      radius-=segWidth;
    }
  }
}

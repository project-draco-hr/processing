{
switch (which) {
case PGLU.GLU_TESS_TOLERANCE:
    if (value < 0.0 || value > 1.0)     break;
  relTolerance=value;
return;
case PGLU.GLU_TESS_WINDING_RULE:
int windingRule=(int)value;
if (windingRule != value) break;
switch (windingRule) {
case PGLU.GLU_TESS_WINDING_ODD:
case PGLU.GLU_TESS_WINDING_NONZERO:
case PGLU.GLU_TESS_WINDING_POSITIVE:
case PGLU.GLU_TESS_WINDING_NEGATIVE:
case PGLU.GLU_TESS_WINDING_ABS_GEQ_TWO:
this.windingRule=windingRule;
return;
default :
break;
}
case PGLU.GLU_TESS_BOUNDARY_ONLY:
boundaryOnly=(value != 0);
return;
case PGLU.GLU_TESS_AVOID_DEGENERATE_TRIANGLES:
avoidDegenerateTris=(value != 0);
return;
default :
callErrorOrErrorData(PGLU.GLU_INVALID_ENUM);
return;
}
callErrorOrErrorData(PGLU.GLU_INVALID_VALUE);
}

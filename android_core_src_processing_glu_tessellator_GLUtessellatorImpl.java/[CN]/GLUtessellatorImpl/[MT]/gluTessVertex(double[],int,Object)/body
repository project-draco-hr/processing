{
  int i;
  boolean tooLarge=false;
  double x;
  double[] clamped=new double[3];
  requireState(TessState.T_IN_CONTOUR);
  if (flushCacheOnNextVertex) {
    if (!flushCache()) {
      callErrorOrErrorData(PGLU.GLU_OUT_OF_MEMORY);
      return;
    }
    lastEdge=null;
  }
  for (i=0; i < 3; ++i) {
    x=coords[i + coords_offset];
    if (x < -PGLU.GLU_TESS_MAX_COORD) {
      x=-PGLU.GLU_TESS_MAX_COORD;
      tooLarge=true;
    }
    if (x > PGLU.GLU_TESS_MAX_COORD) {
      x=PGLU.GLU_TESS_MAX_COORD;
      tooLarge=true;
    }
    clamped[i]=x;
  }
  if (tooLarge) {
    callErrorOrErrorData(PGLU.GLU_TESS_COORD_TOO_LARGE);
  }
  if (mesh == null) {
    if (cacheCount < TESS_MAX_CACHE) {
      cacheVertex(clamped,vertexData);
      return;
    }
    if (!flushCache()) {
      callErrorOrErrorData(PGLU.GLU_OUT_OF_MEMORY);
      return;
    }
  }
  if (!addVertex(clamped,vertexData)) {
    callErrorOrErrorData(PGLU.GLU_OUT_OF_MEMORY);
  }
}

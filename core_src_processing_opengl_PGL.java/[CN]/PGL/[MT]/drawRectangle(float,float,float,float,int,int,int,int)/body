{
  if (!loadedRectShader || rectShaderContext.hashCode() != context.hashCode()) {
    rectVertShader=createShader(GL_VERTEX_SHADER,rectVertShaderSource);
    rectFragShader=createShader(GL_FRAGMENT_SHADER,rectFragShaderSource);
    if (0 < rectVertShader && 0 < rectFragShader) {
      rectShaderProgram=createProgram(rectVertShader,rectFragShader);
    }
    if (0 < rectShaderProgram) {
      rectVertLoc=glGetAttribLocation(rectShaderProgram,"inVertex");
      rectColorLoc=glGetUniformLocation(rectShaderProgram,"rectColor");
    }
    rectData=allocateDirectFloatBuffer(rectCoords.length);
    loadedRectShader=true;
    rectShaderContext=context;
  }
  if (0 < rectShaderProgram) {
    boolean[] depthTest=new boolean[1];
    glGetBooleanv(GL_DEPTH_TEST,depthTest,0);
    glDisable(GL_DEPTH_TEST);
    boolean[] depthMask=new boolean[1];
    glGetBooleanv(GL_DEPTH_WRITEMASK,depthMask,0);
    glDepthMask(false);
    glUseProgram(rectShaderProgram);
    glEnableVertexAttribArray(rectVertLoc);
    glUniform4f(rectColorLoc,r,g,b,a);
    rectCoords[0]=2 * (float)scrX0 / pg.width - 1;
    rectCoords[1]=2 * (float)scrY0 / pg.height - 1;
    rectCoords[2]=2 * (float)scrX1 / pg.width - 1;
    rectCoords[3]=2 * (float)scrY0 / pg.height - 1;
    rectCoords[4]=2 * (float)scrX0 / pg.width - 1;
    rectCoords[5]=2 * (float)scrY1 / pg.height - 1;
    rectCoords[6]=2 * (float)scrX1 / pg.width - 1;
    rectCoords[7]=2 * (float)scrY1 / pg.height - 1;
    rectData.rewind();
    rectData.put(rectCoords);
    glBindBuffer(GL_ARRAY_BUFFER,0);
    rectData.position(0);
    glVertexAttribPointer(rectVertLoc,2,GL_FLOAT,false,2 * SIZEOF_FLOAT,rectData);
    glDrawArrays(GL_TRIANGLE_STRIP,0,4);
    glDisableVertexAttribArray(rectVertLoc);
    glUseProgram(0);
    if (depthTest[0]) {
      glEnable(GL_DEPTH_TEST);
    }
 else {
      glDisable(GL_DEPTH_TEST);
    }
    glDepthMask(depthMask[0]);
  }
}

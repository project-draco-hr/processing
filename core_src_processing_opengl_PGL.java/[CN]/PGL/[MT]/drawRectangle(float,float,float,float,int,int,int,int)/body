{
  if (!loadedRectShader || rectShaderContext.hashCode() != context.hashCode()) {
    rectVertShader=createShader(VERTEX_SHADER,rectVertShaderSource);
    rectFragShader=createShader(FRAGMENT_SHADER,rectFragShaderSource);
    if (0 < rectVertShader && 0 < rectFragShader) {
      rectShaderProgram=createProgram(rectVertShader,rectFragShader);
    }
    if (0 < rectShaderProgram) {
      rectVertLoc=getAttribLocation(rectShaderProgram,"inVertex");
      rectColorLoc=getUniformLocation(rectShaderProgram,"rectColor");
    }
    rectData=allocateDirectFloatBuffer(rectCoords.length);
    loadedRectShader=true;
    rectShaderContext=context;
  }
  if (0 < rectShaderProgram) {
    boolean[] depthTest=new boolean[1];
    getBooleanv(DEPTH_TEST,depthTest,0);
    disable(DEPTH_TEST);
    boolean[] depthMask=new boolean[1];
    getBooleanv(DEPTH_WRITEMASK,depthMask,0);
    depthMask(false);
    useProgram(rectShaderProgram);
    enableVertexAttribArray(rectVertLoc);
    uniform4f(rectColorLoc,r,g,b,a);
    rectCoords[0]=2 * (float)scrX0 / pg.width - 1;
    rectCoords[1]=2 * (float)scrY0 / pg.height - 1;
    rectCoords[2]=2 * (float)scrX1 / pg.width - 1;
    rectCoords[3]=2 * (float)scrY0 / pg.height - 1;
    rectCoords[4]=2 * (float)scrX0 / pg.width - 1;
    rectCoords[5]=2 * (float)scrY1 / pg.height - 1;
    rectCoords[6]=2 * (float)scrX1 / pg.width - 1;
    rectCoords[7]=2 * (float)scrY1 / pg.height - 1;
    rectData.rewind();
    rectData.put(rectCoords);
    bindBuffer(ARRAY_BUFFER,0);
    rectData.position(0);
    vertexAttribPointer(rectVertLoc,2,FLOAT,false,2 * SIZEOF_FLOAT,rectData);
    drawArrays(TRIANGLE_STRIP,0,4);
    disableVertexAttribArray(rectVertLoc);
    useProgram(0);
    if (depthTest[0]) {
      enable(DEPTH_TEST);
    }
 else {
      disable(DEPTH_TEST);
    }
    depthMask(depthMask[0]);
  }
}

{
  GLUmesh mesh;
  try {
    requireState(TessState.T_IN_POLYGON);
    state=TessState.T_DORMANT;
    if (this.mesh == null) {
      if (!flagBoundary) {
        if (Render.__gl_renderCache(this)) {
          polygonData=null;
          return;
        }
      }
      if (!flushCache())       throw new RuntimeException();
    }
    Normal.__gl_projectPolygon(this);
    if (!Sweep.__gl_computeInterior(this)) {
      throw new RuntimeException();
    }
    mesh=this.mesh;
    if (!fatalError) {
      boolean rc=true;
      if (boundaryOnly) {
        rc=TessMono.__gl_meshSetWindingNumber(mesh,1,true);
      }
 else {
        rc=TessMono.__gl_meshTessellateInterior(mesh,avoidDegenerateTris);
      }
      if (!rc)       throw new RuntimeException();
      Mesh.__gl_meshCheckMesh(mesh);
      if (callBegin != NULL_CB || callEnd != NULL_CB || callVertex != NULL_CB || callEdgeFlag != NULL_CB || callBeginData != NULL_CB || callEndData != NULL_CB || callVertexData != NULL_CB || callEdgeFlagData != NULL_CB) {
        if (boundaryOnly) {
          Render.__gl_renderBoundary(this,mesh);
        }
 else {
          Render.__gl_renderMesh(this,mesh);
        }
      }
    }
    Mesh.__gl_meshDeleteMesh(mesh);
    polygonData=null;
    mesh=null;
  }
 catch (  Exception e) {
    e.printStackTrace();
    callErrorOrErrorData(PGLU.GLU_OUT_OF_MEMORY);
  }
}

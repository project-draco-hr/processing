{
switch (which) {
case PGLU.GLU_TESS_TOLERANCE:
    assert(0.0 <= relTolerance && relTolerance <= 1.0);
  value[value_offset]=relTolerance;
break;
case PGLU.GLU_TESS_WINDING_RULE:
assert(windingRule == PGLU.GLU_TESS_WINDING_ODD || windingRule == PGLU.GLU_TESS_WINDING_NONZERO || windingRule == PGLU.GLU_TESS_WINDING_POSITIVE || windingRule == PGLU.GLU_TESS_WINDING_NEGATIVE || windingRule == PGLU.GLU_TESS_WINDING_ABS_GEQ_TWO);
value[value_offset]=windingRule;
break;
case PGLU.GLU_TESS_BOUNDARY_ONLY:
assert(boundaryOnly == true || boundaryOnly == false);
value[value_offset]=boundaryOnly ? 1 : 0;
break;
case PGLU.GLU_TESS_AVOID_DEGENERATE_TRIANGLES:
value[value_offset]=avoidDegenerateTris ? 1 : 0;
break;
default :
value[value_offset]=0.0;
callErrorOrErrorData(PGLU.GLU_INVALID_ENUM);
break;
}
}

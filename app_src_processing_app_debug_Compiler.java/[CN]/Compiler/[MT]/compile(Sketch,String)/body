{
  this.sketch=sketch;
  this.buildPath=buildPath;
  new MessageStream(this);
  String baseCommand[]=new String[]{((!Base.isMacOS()) ? "jikes" : System.getProperty("user.dir") + File.separator + "jikes"),"-target",Preferences.get("preproc.jdk_version"),"-bootclasspath",calcBootClassPath(),"-classpath",sketch.getClassPath(),"-nowarn","+E","-d",buildPath};
  String preprocNames[]=new String[sketch.getCodeCount()];
  int preprocCount=0;
  for (int i=0; i < sketch.getCodeCount(); i++) {
    if (sketch.getCode(i).preprocName != null) {
      preprocNames[preprocCount++]=sketch.getCode(i).preprocName;
    }
  }
  String command[]=new String[baseCommand.length + preprocCount];
  System.arraycopy(baseCommand,0,command,0,baseCommand.length);
  for (int i=0; i < preprocCount; i++) {
    command[baseCommand.length + i]=buildPath + File.separator + preprocNames[i];
  }
  firstErrorFound=false;
  secondErrorFound=false;
  int result=0;
  try {
    Process process=Runtime.getRuntime().exec(command);
    new MessageSiphon(process.getInputStream(),this);
    new MessageSiphon(process.getErrorStream(),this);
    boolean compiling=true;
    while (compiling) {
      try {
        result=process.waitFor();
        compiling=false;
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
 catch (  Exception e) {
    String msg=e.getMessage();
    if ((msg != null) && (msg.indexOf("jikes: not found") != -1)) {
      Base.showWarning("Compiler error","Could not find the compiler.\n" + "jikes is missing from your PATH,\n" + "see readme.txt for help.",null);
      return false;
    }
 else {
      e.printStackTrace();
      result=-1;
    }
  }
  if (exception != null)   throw exception;
  if (result != 0 && result != 1) {
    Base.openURL(BUGS_URL);
    throw new RunnerException(SUPER_BADNESS);
  }
  return (result == 0);
}

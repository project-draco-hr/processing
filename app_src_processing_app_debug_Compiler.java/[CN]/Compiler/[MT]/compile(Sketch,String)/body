{
  RunnerException exception=null;
  boolean success=false;
  String baseCommand[]=new String[]{"-Xemacs","-source","1.5","-target","1.5","-classpath",sketch.getClassPath(),"-nowarn","-d",buildPath};
  String[] preprocNames=new String[sketch.getCodeCount()];
  int preprocCount=0;
  for (int i=0; i < sketch.getCodeCount(); i++) {
    if (sketch.getCode(i).preprocName != null) {
      preprocNames[preprocCount++]=sketch.getCode(i).preprocName;
    }
  }
  String[] command=new String[baseCommand.length + preprocCount];
  System.arraycopy(baseCommand,0,command,0,baseCommand.length);
  for (int i=0; i < preprocCount; i++) {
    command[baseCommand.length + i]=buildPath + File.separator + preprocNames[i];
  }
  try {
    final StringBuffer errorBuffer=new StringBuffer();
    Writer internalWriter=new Writer(){
      public void write(      char[] buf,      int off,      int len){
        errorBuffer.append(buf,off,len);
      }
      public void flush(){
      }
      public void close(){
      }
    }
;
    PrintWriter writer=new PrintWriter(internalWriter);
    CompilationProgress progress=null;
    PrintWriter outWriter=new PrintWriter(System.out);
    success=org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(command,outWriter,writer,progress);
    writer.flush();
    writer.close();
    BufferedReader reader=new BufferedReader(new StringReader(errorBuffer.toString()));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String errorFormat="([\\w\\d_]+.java):(\\d+):\\s*(.*):\\s*(.*)\\s*";
      String[] pieces=PApplet.match(line,errorFormat);
      if (pieces == null) {
        exception=new RunnerException("Cannot parse error text: " + line);
        exception.hideStackTrace();
        System.err.println(line);
        while ((line=reader.readLine()) != null) {
          System.err.println(line);
        }
        break;
      }
      String dotJavaFilename=pieces[0];
      int dotJavaLineIndex=PApplet.parseInt(pieces[1]) - 1;
      String errorMessage=pieces[3];
      int codeIndex=-1;
      int codeLine=-1;
      for (int i=0; i < sketch.getCodeCount(); i++) {
        String name=sketch.getCode(i).preprocName;
        if ((name != null) && dotJavaFilename.equals(name)) {
          codeIndex=i;
        }
      }
      if (codeIndex == 0) {
        for (int i=1; i < sketch.getCodeCount(); i++) {
          SketchCode code=sketch.getCode(i);
          if (code.flavor == Sketch.PDE) {
            if (code.preprocOffset <= dotJavaLineIndex) {
              codeIndex=i;
            }
          }
        }
      }
      codeLine=dotJavaLineIndex - sketch.getCode(codeIndex).preprocOffset;
      exception=new RunnerException(errorMessage,codeIndex,codeLine,-1,false);
      if (errorMessage.startsWith("The import ") && errorMessage.endsWith("cannot be resolved")) {
        String what=errorMessage.substring("The import ".length());
        what=what.substring(0,what.indexOf(' '));
        exception.setMessage("The package " + "\u201C" + what + "\u201D"+ " does not exist. "+ "You might be missing a library.");
      }
 else       if (errorMessage.endsWith("cannot be resolved to a type")) {
        String what=errorMessage.substring(0,errorMessage.indexOf(' '));
        if (what.equals("BFont") || what.equals("BGraphics") || what.equals("BImage")) {
          handleCrustyCode(exception);
        }
 else {
          exception.setMessage("Cannot find a class or type " + "named \u201C" + what + "\u201D");
        }
      }
 else       if (errorMessage.endsWith("cannot be resolved")) {
        String what=errorMessage.substring(0,errorMessage.indexOf(' '));
        if (what.equals("LINE_LOOP") || what.equals("LINE_STRIP") || what.equals("framerate")) {
          handleCrustyCode(exception);
        }
 else {
          exception.setMessage("Cannot find anything " + "named \u201C" + what + "\u201D");
        }
      }
 else       if (errorMessage.startsWith("Duplicate")) {
      }
 else {
        String[] parts=null;
        String undefined="The method (\\S+\\(.*\\)) is undefined for the type (.*)";
        parts=PApplet.match(errorMessage,undefined);
        if (parts != null) {
          if (parts[0].equals("framerate(int)") || parts[0].equals("push()")) {
            handleCrustyCode(exception);
          }
 else {
            String mess="The function " + parts[0] + " does not exist.";
            exception.setMessage(mess);
          }
          break;
        }
      }
      if (exception != null) {
        exception.hideStackTrace();
        break;
      }
    }
  }
 catch (  IOException e) {
    String bigSigh="Error while compiling. (" + e.getMessage() + ")";
    exception=new RunnerException(bigSigh);
    e.printStackTrace();
    success=false;
  }
  if (exception != null)   throw exception;
  return success;
}

{
  vertex_end=vertexCount;
  vertex_end_including_clip_verts=vertex_end;
  if (vertexCount == 0) {
    shape=0;
    return;
  }
  for (int i=vertex_start; i < vertex_end; i++) {
    float vertex[]=vertices[i];
    vertex[VX]=modelview.m00 * vertex[MX] + modelview.m01 * vertex[MY] + modelview.m02 * vertex[MZ] + modelview.m03;
    vertex[VY]=modelview.m10 * vertex[MX] + modelview.m11 * vertex[MY] + modelview.m12 * vertex[MZ] + modelview.m13;
    vertex[VZ]=modelview.m20 * vertex[MX] + modelview.m21 * vertex[MY] + modelview.m22 * vertex[MZ] + modelview.m23;
    vertex[VW]=modelview.m30 * vertex[MX] + modelview.m31 * vertex[MY] + modelview.m32 * vertex[MZ] + modelview.m33;
    if (vertex[VW] != 0 && vertex[VW] != ONE) {
      vertex[VX]/=vertex[VW];
      vertex[VY]/=vertex[VW];
      vertex[VZ]/=vertex[VW];
    }
    vertex[VW]=ONE;
  }
  int increment=1;
  int stop=0;
  if (stroke) {
switch (shape) {
case POINTS:
{
        stop=vertex_end;
        for (int i=vertex_start; i < stop; i++) {
          add_path();
          add_line(i,i);
        }
      }
    break;
case LINES:
case LINE_STRIP:
case LINE_LOOP:
{
    int first=lineCount;
    stop=vertex_end - 1;
    increment=(shape == LINES) ? 2 : 1;
    if (shape != LINES)     add_path();
    for (int i=vertex_start; i < stop; i+=increment) {
      if (shape == LINES)       add_path();
      add_line(i,i + 1);
    }
    if (shape == LINE_LOOP) {
      add_line(stop,lines[first][VERTEX1]);
    }
  }
break;
case TRIANGLES:
{
for (int i=vertex_start; i < vertex_end - 2; i+=3) {
  add_path();
  add_line(i + 0,i + 1);
  add_line(i + 1,i + 2);
  add_line(i + 2,i + 0);
}
}
break;
case TRIANGLE_STRIP:
{
stop=vertex_end - 1;
add_path();
for (int i=vertex_start; i < stop; i++) {
add_line(i,i + 1);
}
stop=vertex_end - 2;
for (int i=vertex_start; i < stop; i++) {
add_path();
add_line(i,i + 2);
}
}
break;
case TRIANGLE_FAN:
{
for (int i=vertex_start + 1; i < vertex_end; i++) {
add_path();
add_line(vertex_start,i);
}
add_path();
for (int i=vertex_start + 1; i < vertex_end - 1; i++) {
add_line(i,i + 1);
}
add_line(vertex_end - 1,vertex_start + 1);
}
break;
case QUADS:
{
for (int i=vertex_start; i < vertex_end; i+=4) {
add_path();
add_line(i + 0,i + 1);
add_line(i + 1,i + 2);
add_line(i + 2,i + 3);
add_line(i + 3,i + 0);
}
}
break;
case QUAD_STRIP:
{
for (int i=vertex_start; i < vertex_end - 3; i+=2) {
add_path();
add_line(i + 0,i + 2);
add_line(i + 2,i + 3);
add_line(i + 3,i + 1);
add_line(i + 1,i + 0);
}
}
break;
case POLYGON:
{
int first=lineCount;
stop=vertex_end - 1;
add_path();
for (int i=vertex_start; i < stop; i++) {
add_line(i,i + 1);
}
add_line(stop,lines[first][VERTEX1]);
}
break;
}
}
if (fill) {
switch (shape) {
case TRIANGLE_FAN:
{
stop=vertex_end - 1;
for (int i=vertex_start + 1; i < stop; i++) {
add_triangle(vertex_start,i,i + 1);
}
}
break;
case TRIANGLES:
case TRIANGLE_STRIP:
{
stop=vertex_end - 2;
increment=(shape == TRIANGLES) ? 3 : 1;
for (int i=vertex_start; i < stop; i+=increment) {
if ((i % 2) == 0) {
add_triangle(i,i + 2,i + 1);
}
 else {
add_triangle(i,i + 1,i + 2);
}
}
}
break;
case QUADS:
{
stop=vertexCount - 3;
for (int i=vertex_start; i < stop; i+=4) {
add_triangle(i,i + 1,i + 2);
add_triangle(i,i + 2,i + 3);
}
}
break;
case QUAD_STRIP:
{
stop=vertexCount - 3;
for (int i=vertex_start; i < stop; i+=2) {
add_triangle(i + 0,i + 2,i + 1);
add_triangle(i + 2,i + 3,i + 1);
}
}
break;
case POLYGON:
{
triangulate_polygon();
}
break;
}
}
if (lightCount > 0 && fill) {
handle_lighting();
}
 else {
handle_no_lighting();
}
for (int i=vertex_start; i < vertex_end_including_clip_verts; i++) {
float vx[]=vertices[i];
float ox=projection.m00 * vx[VX] + projection.m01 * vx[VY] + projection.m02 * vx[VZ] + projection.m03 * vx[VW];
float oy=projection.m10 * vx[VX] + projection.m11 * vx[VY] + projection.m12 * vx[VZ] + projection.m13 * vx[VW];
float oz=projection.m20 * vx[VX] + projection.m21 * vx[VY] + projection.m22 * vx[VZ] + projection.m23 * vx[VW];
float ow=projection.m30 * vx[VX] + projection.m31 * vx[VY] + projection.m32 * vx[VZ] + projection.m33 * vx[VW];
if (ow != 0 && ow != ONE) {
ox/=ow;
oy/=ow;
oz/=ow;
}
vx[X]=width * (ONE + ox) / 2.0f;
vx[Y]=height * (ONE + oy) / 2.0f;
vx[Z]=(oz + ONE) / 2.0f;
}
if (!hints[DEPTH_SORT]) {
if (fill) render_triangles();
if (stroke) render_lines();
}
shape=0;
}

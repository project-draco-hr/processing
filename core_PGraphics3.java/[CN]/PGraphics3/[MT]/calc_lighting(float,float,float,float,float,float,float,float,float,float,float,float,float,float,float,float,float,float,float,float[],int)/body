{
  if (lightCount == 0) {
    target[toffset + 0]=min(1.0f,er + dr);
    target[toffset + 1]=min(1.0f,eg + dg);
    target[toffset + 2]=min(1.0f,eb + db);
    return;
  }
  float dir=dot(nx,ny,nz,-wx,-wy,-wz);
  if (dir < 0) {
    nx=-nx;
    ny=-ny;
    nz=-nz;
  }
  float diffuse_r=0;
  float diffuse_g=0;
  float diffuse_b=0;
  float specular_r=0;
  float specular_g=0;
  float specular_b=0;
  for (int i=0; i < lightCount; i++) {
    float denom=lightsFalloffConstant[i];
    float spotTerm=1;
    if (lights[i] == AMBIENT) {
      if (lightsFalloffQuadratic[i] != 0 || lightsFalloffLinear[i] != 0) {
        float distSq=mag(lightsX[i] - wx,lightsY[i] - wy,lightsZ[i] - wz);
        denom+=(lightsFalloffQuadratic[i] * distSq + lightsFalloffLinear[i] * (float)sqrt(distSq));
      }
      if (denom == 0)       denom=1;
      diffuse_r+=lightsDiffuseR[i] * ar / denom;
      diffuse_g+=lightsDiffuseG[i] * ag / denom;
      diffuse_b+=lightsDiffuseB[i] * ab / denom;
    }
 else {
      float lix, liy, liz;
      float lightDir_dot_li=0;
      float n_dot_li=0;
      if (lights[i] == DIRECTIONAL) {
        lix=-lightsNX[i];
        liy=-lightsNY[i];
        liz=-lightsNZ[i];
        denom=1;
        n_dot_li=(nx * lix + ny * liy + nz * liz);
        if (n_dot_li <= 0) {
          continue;
        }
      }
 else {
        lix=lightsX[i] - wx;
        liy=lightsY[i] - wy;
        liz=lightsZ[i] - wz;
        float distSq=mag(lix,liy,liz);
        if (distSq != 0) {
          lix/=distSq;
          liy/=distSq;
          liz/=distSq;
        }
        n_dot_li=(nx * lix + ny * liy + nz * liz);
        if (n_dot_li <= 0) {
          continue;
        }
        if (lights[i] == SPOT) {
          lightDir_dot_li=-(lightsNX[i] * lix + lightsNY[i] * liy + lightsNZ[i] * liz);
          if (lightDir_dot_li <= lightsSpotAngleCos[i]) {
            continue;
          }
          spotTerm=pow(lightDir_dot_li,lightsSpotConcentration[i]);
        }
        if (lightsFalloffQuadratic[i] != 0 || lightsFalloffLinear[i] != 0) {
          denom+=(lightsFalloffQuadratic[i] * distSq + lightsFalloffLinear[i] * (float)sqrt(distSq));
        }
      }
      if (denom == 0)       denom=1;
      float mul=n_dot_li * spotTerm / denom;
      diffuse_r+=lightsDiffuseR[i] * mul;
      diffuse_g+=lightsDiffuseG[i] * mul;
      diffuse_b+=lightsDiffuseB[i] * mul;
      if ((sr > 0 || sg > 0 || sb > 0) && (lightsSpecularR[i] > 0 || lightsSpecularG[i] > 0 || lightsSpecularB[i] > 0)) {
        float vmag=mag(wx,wy,wz);
        if (vmag != 0) {
          wx/=vmag;
          wy/=vmag;
          wz/=vmag;
        }
        float sx=lix - wx;
        float sy=liy - wy;
        float sz=liz - wz;
        vmag=mag(sx,sy,sz);
        if (vmag != 0) {
          sx/=vmag;
          sy/=vmag;
          sz/=vmag;
        }
        float s_dot_n=(sx * nx + sy * ny + sz * nz);
        if (s_dot_n > 0) {
          s_dot_n=pow(s_dot_n,shininess);
          mul=s_dot_n * spotTerm / denom;
          specular_r+=lightsSpecularR[i] * mul;
          specular_g+=lightsSpecularG[i] * mul;
          specular_b+=lightsSpecularB[i] * mul;
        }
      }
    }
  }
  target[toffset + 0]=min(1,er + dr * diffuse_r);
  target[toffset + 1]=min(1,eg + dg * diffuse_g);
  target[toffset + 2]=min(1,eb + db * diffuse_b);
  target[SPR]=min(1,sr * specular_r);
  target[SPG]=min(1,sg * specular_g);
  target[SPB]=min(1,sb * specular_b);
  return;
}

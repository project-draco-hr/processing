{
  float[] v=vertices[vIndex];
  float sr=v[SPR];
  float sg=v[SPG];
  float sb=v[SPB];
  float wx=v[VX];
  float wy=v[VY];
  float wz=v[VZ];
  float shine=v[SHINE];
  float nx;
  float ny;
  float nz;
  if (!normalIsWorld) {
    toWorldNormal(v[NX],v[NY],v[NZ],worldNormal);
    nx=worldNormal[X];
    ny=worldNormal[Y];
    nz=worldNormal[Z];
  }
 else {
    nx=v[NX];
    ny=v[NY];
    nz=v[NZ];
  }
  float dir=dot(nx,ny,nz,-wx,-wy,-wz);
  if (dir < 0) {
    nx=-nx;
    ny=-ny;
    nz=-nz;
  }
  contribution[LIGHT_AMBIENT_R]=0;
  contribution[LIGHT_AMBIENT_G]=0;
  contribution[LIGHT_AMBIENT_B]=0;
  contribution[LIGHT_DIFFUSE_R]=0;
  contribution[LIGHT_DIFFUSE_G]=0;
  contribution[LIGHT_DIFFUSE_B]=0;
  contribution[LIGHT_SPECULAR_R]=0;
  contribution[LIGHT_SPECULAR_G]=0;
  contribution[LIGHT_SPECULAR_B]=0;
  for (int i=0; i < lightCount; i++) {
    float denom=lightsFalloffConstant[i];
    float spotTerm=1;
    if (lights[i] == AMBIENT) {
      if (lightsFalloffQuadratic[i] != 0 || lightsFalloffLinear[i] != 0) {
        float distSq=mag(lightsX[i] - wx,lightsY[i] - wy,lightsZ[i] - wz);
        denom+=lightsFalloffQuadratic[i] * distSq + lightsFalloffLinear[i] * (float)sqrt(distSq);
      }
      if (denom == 0)       denom=1;
      contribution[LIGHT_AMBIENT_R]+=lightsDiffuseR[i] / denom;
      contribution[LIGHT_AMBIENT_G]+=lightsDiffuseG[i] / denom;
      contribution[LIGHT_AMBIENT_B]+=lightsDiffuseB[i] / denom;
    }
 else {
      float lix, liy, liz;
      float lightDir_dot_li=0;
      float n_dot_li=0;
      if (lights[i] == DIRECTIONAL) {
        lix=-lightsNX[i];
        liy=-lightsNY[i];
        liz=-lightsNZ[i];
        denom=1;
        n_dot_li=(nx * lix + ny * liy + nz * liz);
        if (n_dot_li <= 0) {
          continue;
        }
      }
 else {
        lix=lightsX[i] - wx;
        liy=lightsY[i] - wy;
        liz=lightsZ[i] - wz;
        float distSq=mag(lix,liy,liz);
        if (distSq != 0) {
          lix/=distSq;
          liy/=distSq;
          liz/=distSq;
        }
        n_dot_li=(nx * lix + ny * liy + nz * liz);
        if (n_dot_li <= 0) {
          continue;
        }
        if (lights[i] == SPOT) {
          lightDir_dot_li=-(lightsNX[i] * lix + lightsNY[i] * liy + lightsNZ[i] * liz);
          if (lightDir_dot_li <= lightsSpotAngleCos[i]) {
            continue;
          }
          spotTerm=pow(lightDir_dot_li,lightsSpotConcentration[i]);
        }
        if (lightsFalloffQuadratic[i] != 0 || lightsFalloffLinear[i] != 0) {
          denom+=lightsFalloffQuadratic[i] * distSq + lightsFalloffLinear[i] * (float)sqrt(distSq);
        }
      }
      if (denom == 0)       denom=1;
      float mul=n_dot_li * spotTerm / denom;
      contribution[LIGHT_DIFFUSE_R]+=lightsDiffuseR[i] * mul;
      contribution[LIGHT_DIFFUSE_G]+=lightsDiffuseG[i] * mul;
      contribution[LIGHT_DIFFUSE_B]+=lightsDiffuseB[i] * mul;
      if ((sr > 0 || sg > 0 || sb > 0) && (lightsSpecularR[i] > 0 || lightsSpecularG[i] > 0 || lightsSpecularB[i] > 0)) {
        float vmag=mag(wx,wy,wz);
        if (vmag != 0) {
          wx/=vmag;
          wy/=vmag;
          wz/=vmag;
        }
        float sx=lix - wx;
        float sy=liy - wy;
        float sz=liz - wz;
        vmag=mag(sx,sy,sz);
        if (vmag != 0) {
          sx/=vmag;
          sy/=vmag;
          sz/=vmag;
        }
        float s_dot_n=(sx * nx + sy * ny + sz * nz);
        if (s_dot_n > 0) {
          s_dot_n=pow(s_dot_n,shine);
          mul=s_dot_n * spotTerm / denom;
          contribution[LIGHT_SPECULAR_R]+=lightsSpecularR[i] * mul;
          contribution[LIGHT_SPECULAR_G]+=lightsSpecularG[i] * mul;
          contribution[LIGHT_SPECULAR_B]+=lightsSpecularB[i] * mul;
        }
      }
    }
  }
  return;
}

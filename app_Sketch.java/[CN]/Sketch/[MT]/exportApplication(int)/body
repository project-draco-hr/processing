{
  ensureExistence();
  String exportPlatformStr=null;
  if (exportPlatform == PConstants.WINDOWS) {
    exportPlatformStr="windows";
  }
 else   if (exportPlatform == PConstants.MACOSX) {
    exportPlatformStr="macosx";
  }
 else   if (exportPlatform == PConstants.LINUX) {
    exportPlatformStr="linux";
  }
 else {
    exportPlatform=-1;
  }
  String folderName="application";
  if (exportPlatform != -1) {
    folderName+="." + exportPlatformStr;
  }
  File destFolder=new File(folder,folderName);
  Base.removeDir(destFolder);
  destFolder.mkdirs();
  String foundName=build(destFolder.getPath(),name);
  if (foundName == null)   return false;
  if (!name.equals(foundName)) {
    Base.showWarning("Error during export","Sketch name is " + name + " but the sketch\n"+ "name in the code was "+ foundName,null);
    return false;
  }
  File jarFolder=new File(destFolder,"lib");
  File dotAppFolder=null;
  if (exportPlatform == PConstants.MACOSX) {
    dotAppFolder=new File(destFolder,name + ".app");
    String APP_SKELETON="skeleton.app";
    File dotAppSkeleton=new File("lib/export/" + APP_SKELETON);
    Base.copyDir(dotAppSkeleton,dotAppFolder);
    String stubName="Contents/MacOS/JavaApplicationStub";
    if (PApplet.platform == PConstants.WINDOWS) {
      File warningFile=new File(destFolder,"readme.txt");
      PrintStream ps=new PrintStream(new FileOutputStream(warningFile));
      ps.println("This application was created on Windows, which doesn't");
      ps.println("properly support setting files as \"executable\",");
      ps.println("a necessity for applications on Mac OS X.");
      ps.println();
      ps.println("To fix this, use the Terminal on Mac OS X, and from this");
      ps.println("directory, type the following:");
      ps.println();
      ps.println("chmod +x " + dotAppFolder.getName() + "/"+ stubName);
      ps.flush();
      ps.close();
    }
 else {
      File stubFile=new File(dotAppFolder,stubName);
      String stubPath=stubFile.getAbsolutePath();
      Runtime.getRuntime().exec(new String[]{"chmod","+x",stubPath});
    }
    jarFolder=new File(dotAppFolder,"Contents/Resources/Java");
  }
  if (!jarFolder.exists())   jarFolder.mkdirs();
  if (exportPlatform == PConstants.WINDOWS) {
    Base.copyFile(new File("lib/export/application.exe"),new File(destFolder,this.name + ".exe"));
  }
  Vector jarListVector=new Vector();
  zipFileContents=new Hashtable();
  FileOutputStream zipOutputFile=new FileOutputStream(new File(jarFolder,name + ".jar"));
  ZipOutputStream zos=new ZipOutputStream(zipOutputFile);
  ZipEntry entry;
  addManifest(zos);
  String classfiles[]=destFolder.list();
  for (int i=0; i < classfiles.length; i++) {
    if (classfiles[i].endsWith(".class")) {
      entry=new ZipEntry(classfiles[i]);
      zos.putNextEntry(entry);
      zos.write(Base.grabFile(new File(destFolder,classfiles[i])));
      zos.closeEntry();
    }
  }
  if (dataFolder.exists()) {
    String dataFiles[]=Base.listFiles(dataFolder,false);
    int offset=folder.getAbsolutePath().length() + 1;
    for (int i=0; i < dataFiles.length; i++) {
      if (PApplet.platform == PApplet.WINDOWS) {
        dataFiles[i]=dataFiles[i].replace('\\','/');
      }
      File dataFile=new File(dataFiles[i]);
      if (dataFile.isDirectory())       continue;
      if (dataFile.getName().charAt(0) == '.')       continue;
      entry=new ZipEntry(dataFiles[i].substring(offset));
      zos.putNextEntry(entry);
      zos.write(Base.grabFile(dataFile));
      zos.closeEntry();
    }
  }
  if (codeFolder.exists()) {
    String includes=Compiler.contentsToClassPath(codeFolder);
    packClassPathIntoZipFile(includes,zos);
  }
  zos.flush();
  zos.close();
  jarListVector.add(name + ".jar");
  Base.copyFile(new File("lib/core.jar"),new File(jarFolder,"core.jar"));
  jarListVector.add("core.jar");
  Enumeration en=importedLibraries.elements();
  while (en.hasMoreElements()) {
    File libraryFolder=(File)en.nextElement();
    File exportSettings=new File(libraryFolder,"export.txt");
    Hashtable exportTable=readSettings(exportSettings);
    String commaList=null;
    String exportList[]=null;
    if (exportPlatform != -1) {
      commaList=(String)exportTable.get("application." + exportPlatformStr);
    }
    if (commaList == null) {
      commaList=(String)exportTable.get("application");
    }
    if (commaList == null) {
      exportList=libraryFolder.list();
    }
 else {
      exportList=PApplet.split(commaList,", ");
    }
    for (int i=0; i < exportList.length; i++) {
      if (exportList[i].equals(".") || exportList[i].equals(".."))       continue;
      exportList[i]=PApplet.trim(exportList[i]);
      if (exportList[i].equals(""))       continue;
      File exportFile=new File(libraryFolder,exportList[i]);
      if (!exportFile.exists()) {
        System.err.println("File " + exportList[i] + " does not exist");
      }
 else       if (exportFile.isDirectory()) {
        System.err.println("Ignoring sub-folder \"" + exportList[i] + "\"");
      }
 else       if (exportFile.getName().toLowerCase().endsWith(".zip") || exportFile.getName().toLowerCase().endsWith(".jar")) {
        Base.copyFile(exportFile,new File(jarFolder,exportList[i]));
        jarListVector.add(exportList[i]);
      }
 else       if ((exportPlatform == PConstants.MACOSX) && (exportFile.getName().toLowerCase().endsWith(".jnilib"))) {
        Base.copyFile(exportFile,new File(jarFolder,exportList[i]));
      }
 else {
        Base.copyFile(exportFile,new File(destFolder,exportFile.getName()));
      }
    }
  }
  String jarList[]=new String[jarListVector.size()];
  jarListVector.copyInto(jarList);
  StringBuffer exportClassPath=new StringBuffer();
  if (exportPlatform == PConstants.MACOSX) {
    for (int i=0; i < jarList.length; i++) {
      if (i != 0)       exportClassPath.append(":");
      exportClassPath.append("$JAVAROOT/" + jarList[i]);
    }
  }
 else   if (exportPlatform == PConstants.WINDOWS) {
    for (int i=0; i < jarList.length; i++) {
      if (i != 0)       exportClassPath.append(",");
      exportClassPath.append(jarList[i]);
    }
  }
 else {
    for (int i=0; i < jarList.length; i++) {
      if (i != 0)       exportClassPath.append(":");
      exportClassPath.append("lib/" + jarList[i]);
    }
  }
  if (exportPlatform == PConstants.MACOSX) {
    String PLIST_TEMPLATE="template.plist";
    File plistTemplate=new File(folder,PLIST_TEMPLATE);
    if (!plistTemplate.exists()) {
      plistTemplate=new File("lib/export/" + PLIST_TEMPLATE);
    }
    File plistFile=new File(dotAppFolder,"Contents/Info.plist");
    PrintStream ps=new PrintStream(new FileOutputStream(plistFile));
    String lines[]=PApplet.loadStrings(plistTemplate);
    for (int i=0; i < lines.length; i++) {
      if (lines[i].indexOf("@@") != -1) {
        StringBuffer sb=new StringBuffer(lines[i]);
        int index=0;
        while ((index=sb.indexOf("@@sketch@@")) != -1) {
          sb.replace(index,index + "@@sketch@@".length(),name);
        }
        while ((index=sb.indexOf("@@classpath@@")) != -1) {
          sb.replace(index,index + "@@classpath@@".length(),exportClassPath.toString());
        }
        lines[i]=sb.toString();
      }
      ps.print(lines[i] + "\n");
    }
    ps.flush();
    ps.close();
  }
 else   if (exportPlatform == PConstants.WINDOWS) {
    File argsFile=new File(destFolder + "/lib/args.txt");
    PrintStream ps=new PrintStream(new FileOutputStream(argsFile));
    ps.println(Preferences.get("run.options"));
    ps.println(this.name);
    ps.println(exportClassPath);
    ps.flush();
    ps.close();
  }
 else {
    File shellScript=new File(destFolder,this.name);
    PrintStream ps=new PrintStream(new FileOutputStream(shellScript));
    ps.print("#!/bin/sh\n\n");
    ps.print("java " + Preferences.get("run.options") + " -cp "+ exportClassPath+ " "+ this.name+ "\n");
    ps.flush();
    ps.close();
    String shellPath=shellScript.getAbsolutePath();
    if (PApplet.platform != PConstants.WINDOWS) {
      Runtime.getRuntime().exec(new String[]{"chmod","+x",shellPath});
    }
  }
  File sourceFolder=new File(destFolder,"source");
  sourceFolder.mkdirs();
  for (int i=0; i < codeCount; i++) {
    try {
      Base.copyFile(code[i].file,new File(sourceFolder,code[i].file.getName()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  String preprocFilename=this.name + ".java";
  File preprocFile=new File(destFolder,preprocFilename);
  if (preprocFile.exists()) {
    preprocFile.renameTo(new File(sourceFolder,preprocFilename));
  }
  for (int i=0; i < classfiles.length; i++) {
    if (classfiles[i].endsWith(".class")) {
      File deadguy=new File(destFolder,classfiles[i]);
      if (!deadguy.delete()) {
        Base.showWarning("Could not delete",classfiles[i] + " could not \n" + "be deleted from the applet folder.  \n"+ "You'll need to remove it by hand.",null);
      }
    }
  }
  return true;
}

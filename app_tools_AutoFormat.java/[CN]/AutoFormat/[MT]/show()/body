{
  StringBuffer onechar;
  theStuff=editor.textarea.getText();
  strOut=new StringBuffer();
  indentValue=Preferences.getInteger("editor.tabs.size");
  indentChar=new String(" ");
  lineNumber=0;
  BLOCK_MAXLEN=256;
  c_level=if_lev=level=e_flg=paren=0;
  a_flg=q_flg=j=b_flg=tabs=0;
  if_flg=peek=-1;
  peekc='`';
  s_flg=1;
  bblank=' ';
  jdoc=0;
  s_level=new int[10];
  sp_flg=new int[20][10];
  s_ind=new int[20][10];
  s_if_lev=new int[10];
  s_if_flg=new int[10];
  ind=new int[10];
  p_flg=new int[10];
  s_tabs=new int[20][10];
  w_else=new String("else");
  w_if_=new String("if");
  w_for=new String("for");
  w_ds=new String("default");
  w_case=new String("case");
  w_cpp_comment=new String("//");
  w_jdoc=new String("/**");
  line_feed=new String("\n");
  try {
    ByteArrayInputStream in=new ByteArrayInputStream(theStuff.getBytes());
    bin=new BufferedInputStream(in);
  }
 catch (  Exception e) {
    System.out.println(e.toString());
  }
  EOF=0;
  bArray=new byte[BLOCK_MAXLEN];
  string=new char[BLOCK_MAXLEN];
  try {
    for (int ib=0; ib < BLOCK_MAXLEN; ib++)     bArray[ib]='\0';
    lineLength=nBytesRead=0;
    nBytesRead=bin.read(bArray);
    strBlock=new String(bArray);
    lineLength=nBytesRead;
    lineNumber=1;
    indexBlock=-1;
    j=0;
    while (EOF == 0) {
      c=getchr();
switch (c) {
default :
        string[j++]=c;
      if (c != ',') {
        l_char=c;
      }
    break;
case ' ':
case '\t':
  if (lookup(w_else) == 1) {
    gotelse();
    if (s_flg == 0 || j > 0)     string[j++]=c;
    indent_puts();
    s_flg=0;
    break;
  }
if (s_flg == 0 || j > 0) string[j++]=c;
break;
case '\r':
case '\n':
lineNumber++;
if (EOF == 1) {
break;
}
String j_string=new String(string);
e_flg=lookup(w_else);
if (e_flg == 1) gotelse();
if (lookup_com(w_cpp_comment) == 1) {
if (string[j] == '\n') {
string[j]='\0';
j--;
}
}
indent_puts();
fprintf(outfil,line_feed);
s_flg=1;
if (e_flg == 1) {
p_flg[level]++;
tabs++;
}
 else if (p_char == l_char) {
a_flg=1;
}
break;
case '{':
if (lookup(w_else) == 1) gotelse();
s_if_lev[c_level]=if_lev;
s_if_flg[c_level]=if_flg;
if_lev=if_flg=0;
c_level++;
if (s_flg == 1 && p_flg[level] != 0) {
p_flg[level]--;
tabs--;
}
string[j++]=c;
indent_puts();
getnl();
indent_puts();
fprintf(outfil,"\n");
tabs++;
s_flg=1;
if (p_flg[level] > 0) {
ind[level]=1;
level++;
s_level[level]=c_level;
}
break;
case '}':
c_level--;
if (c_level < 0) {
EOF=1;
string[j++]=c;
indent_puts();
break;
}
if ((if_lev=s_if_lev[c_level] - 1) < 0) if_lev=0;
if_flg=s_if_flg[c_level];
indent_puts();
tabs--;
p_tabs();
peekc=getchr();
if (peekc == ';') {
onechar=new StringBuffer();
onechar.append(c);
onechar.append(';');
fprintf(outfil,onechar.toString());
peek=-1;
peekc='`';
}
 else {
onechar=new StringBuffer();
onechar.append(c);
fprintf(outfil,onechar.toString());
peek=1;
}
getnl();
indent_puts();
fprintf(outfil,"\n");
s_flg=1;
if (c_level < s_level[level]) if (level > 0) level--;
if (ind[level] != 0) {
tabs-=p_flg[level];
p_flg[level]=0;
ind[level]=0;
}
break;
case '"':
case '\'':
string[j++]=c;
cc=getchr();
while (cc != c) {
string[j++]=cc;
if (cc == '\\') {
cc=string[j++]=getchr();
}
if (cc == '\n') {
lineNumber++;
indent_puts();
s_flg=1;
}
cc=getchr();
}
string[j++]=cc;
if (getnl() == 1) {
l_char=cc;
peek=1;
peekc='\n';
}
break;
case ';':
string[j++]=c;
indent_puts();
if (p_flg[level] > 0 && ind[level] == 0) {
tabs-=p_flg[level];
p_flg[level]=0;
}
getnl();
indent_puts();
fprintf(outfil,"\n");
s_flg=1;
if (if_lev > 0) if (if_flg == 1) {
if_lev--;
if_flg=0;
}
 else if_lev=0;
break;
case '\\':
string[j++]=c;
string[j++]=getchr();
break;
case '?':
q_flg=1;
string[j++]=c;
break;
case ':':
string[j++]=c;
peekc=getchr();
if (peekc == ':') {
indent_puts();
fprintf(outfil,":");
peek=-1;
peekc='`';
break;
}
 else {
int double_colon=0;
peek=1;
}
if (q_flg == 1) {
q_flg=0;
break;
}
if (lookup(w_ds) == 0 && lookup(w_case) == 0) {
s_flg=0;
indent_puts();
}
 else {
tabs--;
indent_puts();
tabs++;
}
peekc=getchr();
if (peekc == ';') {
fprintf(outfil,";");
peek=-1;
peekc='`';
}
 else {
peek=1;
}
getnl();
indent_puts();
fprintf(outfil,"\n");
s_flg=1;
break;
case '/':
c0=string[j];
string[j++]=c;
peekc=getchr();
if (peekc == '/') {
string[j++]=peekc;
peekc='`';
peek=-1;
cpp_comment();
fprintf(outfil,"\n");
break;
}
 else {
peek=1;
}
if (peekc != '*') {
break;
}
 else {
if (j > 0) string[j--]='\0';
if (j > 0) indent_puts();
string[j++]='/';
string[j++]='*';
peek=-1;
peekc='`';
comment();
break;
}
case '#':
string[j++]=c;
cc=getchr();
while (cc != '\n') {
string[j++]=cc;
cc=getchr();
}
string[j++]=cc;
s_flg=0;
indent_puts();
s_flg=1;
break;
case ')':
paren--;
if (paren < 0) {
EOF=1;
}
string[j++]=c;
indent_puts();
if (getnl() == 1) {
peekc='\n';
peek=1;
if (paren != 0) {
a_flg=1;
}
 else if (tabs > 0) {
p_flg[level]++;
tabs++;
ind[level]=0;
}
}
break;
case '(':
string[j++]=c;
paren++;
if ((lookup(w_for) == 1)) {
c=get_string();
while (c != ';') c=get_string();
ct=0;
int for_done=0;
while (for_done == 0) {
c=get_string();
while (c != ')') {
if (c == '(') ct++;
c=get_string();
}
if (ct != 0) {
ct--;
}
 else for_done=1;
}
paren--;
if (paren < 0) {
EOF=1;
}
indent_puts();
if (getnl() == 1) {
peekc='\n';
peek=1;
p_flg[level]++;
tabs++;
ind[level]=0;
}
break;
}
if (lookup(w_if_) == 1) {
indent_puts();
s_tabs[c_level][if_lev]=tabs;
sp_flg[c_level][if_lev]=p_flg[level];
s_ind[c_level][if_lev]=ind[level];
if_lev++;
if_flg=1;
}
}
String j_string=new String(string);
}
int selectionEnd=editor.textarea.getSelectionEnd();
if (strOut.length() < selectionEnd - 1) {
selectionEnd=strOut.length() - 1;
}
editor.setText(strOut.toString(),selectionEnd,selectionEnd);
editor.sketch.setModified();
bin.close();
}
 catch (Exception e) {
editor.error(e);
}
if (paren != 0) {
System.err.println("Warning: Too many " + ((paren < 0) ? "right" : "left") + " parentheses.");
}
 else if (c_level != 0) {
System.err.println("Warning: Too many " + ((c_level < 0) ? "right" : "left") + " curly braces.");
}
}

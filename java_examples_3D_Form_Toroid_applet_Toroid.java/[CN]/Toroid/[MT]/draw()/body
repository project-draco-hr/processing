{
  background(51);
  lights();
  if (isWireFrame) {
    stroke(255);
    noFill();
  }
 else {
    noStroke();
    fill(204);
  }
  translate(width / 2,height / 2,-100);
  rotateX(frameCount * PI / 150);
  rotateY(frameCount * PI / 170);
  rotateZ(frameCount * PI / 90);
  vertices=new Point3D[pts + 1];
  vertices2=new Point3D[pts + 1];
  for (int i=0; i <= pts; i++) {
    vertices[i]=new Point3D();
    vertices2[i]=new Point3D();
    vertices[i].x=latheRadius + sin(radians(angle)) * radius;
    if (isHelix) {
      vertices[i].z=cos(radians(angle)) * radius - (helixOffset * segments) / 2;
    }
 else {
      vertices[i].z=cos(radians(angle)) * radius;
    }
    angle+=360.0f / pts;
  }
  latheAngle=0;
  for (int i=0; i <= segments; i++) {
    beginShape(QUAD_STRIP);
    for (int j=0; j <= pts; j++) {
      if (i > 0) {
        vertex(vertices2[j].x,vertices2[j].y,vertices2[j].z);
      }
      vertices2[j].x=cos(radians(latheAngle)) * vertices[j].x;
      vertices2[j].y=sin(radians(latheAngle)) * vertices[j].x;
      vertices2[j].z=vertices[j].z;
      if (isHelix) {
        vertices[j].z+=helixOffset;
      }
      vertex(vertices2[j].x,vertices2[j].y,vertices2[j].z);
    }
    if (isHelix) {
      latheAngle+=720.0f / segments;
    }
 else {
      latheAngle+=360.0f / segments;
    }
    endShape();
  }
}

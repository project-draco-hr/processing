{
  for (int i=0; i < vertexCount; i++) {
    sp[i]=0;
    sdp[i]=0;
  }
  int lx=(int)(l[X] + 0.49999f);
  if (lx < 0)   lx=0;
  int rx=(int)(r[X] - 0.5f);
  if (rx > width1)   rx=width1;
  if (lx > rx)   return;
  if (smooth) {
    int mody=MODYRES(y);
    aaleft[mody]=lx;
    aaright[mody]=rx;
    if (firstModY == -1) {
      firstModY=mody;
      aaleftmin=lx;
      aaleftmax=lx;
      aarightmin=rx;
      aarightmax=rx;
    }
 else {
      if (aaleftmin > aaleft[mody])       aaleftmin=aaleft[mody];
      if (aaleftmax < aaleft[mody])       aaleftmax=aaleft[mody];
      if (aarightmin > aaright[mody])       aarightmin=aaright[mody];
      if (aarightmax < aaright[mody])       aarightmax=aaright[mody];
    }
    lastModY=mody;
    if ((mody != SUBYRES1) && (y != lastY))     return;
    aaleftfull=aaleftmax / SUBXRES + 1;
    aarightfull=aarightmin / SUBXRES - 1;
  }
  incrementalize_x(l,r,sp,sdp,lx);
  int offset=smooth ? parent.width * (y / SUBYRES) : parent.width * y;
  int truelx=0, truerx=0;
  if (smooth) {
    truelx=lx / SUBXRES;
    truerx=(rx + SUBXRES1) / SUBXRES;
    lx=aaleftmin / SUBXRES;
    rx=(aarightmax + SUBXRES1) / SUBXRES;
    if (lx < 0)     lx=0;
    if (rx > parent.width1)     rx=parent.width1;
  }
  interpX=false;
  int tr, tg, tb, ta;
  for (int x=lx; x <= rx; x++) {
    if (noDepthTest || (sp[Z] <= zbuffer[offset + x])) {
      if (interpUV) {
        int tu=(int)sp[U];
        int tv=(int)sp[V];
        if (tu > twidth1)         tu=twidth1;
        if (tv > theight1)         tv=theight1;
        if (tu < 0)         tu=0;
        if (tv < 0)         tv=0;
        int txy=tv * twidth + tu;
        float[] uv=new float[2];
        txy=getTextureIndex(x,y * 1.0f / SUBYRES,uv);
        tu=(int)uv[0];
        tv=(int)uv[1];
        txy=twidth * tv + tu;
        if (smooth || texture_smooth) {
          int tuf1=(int)(255f * (uv[0] - tu));
          int tvf1=(int)(255f * (uv[1] - tv));
          int tuf=255 - tuf1;
          int tvf=255 - tvf1;
          int pixel00=tpixels[txy];
          int pixel01=(tv < theight1) ? tpixels[txy + twidth] : tpixels[txy];
          int pixel10=(tu < twidth1) ? tpixels[txy + 1] : tpixels[txy];
          int pixel11=((tv < theight1) && (tu < twidth1)) ? tpixels[txy + twidth + 1] : tpixels[txy];
          int p00, p01, p10, p11;
          int px0, px1;
          if (tformat == ALPHA) {
            px0=(pixel00 * tuf + pixel10 * tuf1) >> 8;
            px1=(pixel01 * tuf + pixel11 * tuf1) >> 8;
            ta=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[A] * 255)) : a2orig)) >> 8;
          }
 else           if (tformat == ARGB) {
            p00=(pixel00 >> 24) & 0xff;
            p01=(pixel01 >> 24) & 0xff;
            p10=(pixel10 >> 24) & 0xff;
            p11=(pixel11 >> 24) & 0xff;
            px0=(p00 * tuf + p10 * tuf1) >> 8;
            px1=(p01 * tuf + p11 * tuf1) >> 8;
            ta=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[A] * 255)) : a2orig)) >> 8;
          }
 else {
            ta=interpARGB ? ((int)(sp[A] * 255)) : a2orig;
          }
          if ((tformat == RGB) || (tformat == ARGB)) {
            p00=(pixel00 >> 16) & 0xff;
            p01=(pixel01 >> 16) & 0xff;
            p10=(pixel10 >> 16) & 0xff;
            p11=(pixel11 >> 16) & 0xff;
            px0=(p00 * tuf + p10 * tuf1) >> 8;
            px1=(p01 * tuf + p11 * tuf1) >> 8;
            tr=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[R] * 255)) : r2)) >> 8;
            p00=(pixel00 >> 8) & 0xff;
            p01=(pixel01 >> 8) & 0xff;
            p10=(pixel10 >> 8) & 0xff;
            p11=(pixel11 >> 8) & 0xff;
            px0=(p00 * tuf + p10 * tuf1) >> 8;
            px1=(p01 * tuf + p11 * tuf1) >> 8;
            tg=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[G] * 255)) : g2)) >> 8;
            p00=pixel00 & 0xff;
            p01=pixel01 & 0xff;
            p10=pixel10 & 0xff;
            p11=pixel11 & 0xff;
            px0=(p00 * tuf + p10 * tuf1) >> 8;
            px1=(p01 * tuf + p11 * tuf1) >> 8;
            tb=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[B] * 255)) : b2)) >> 8;
          }
 else {
            if (interpARGB) {
              tr=(int)(sp[R] * 255);
              tg=(int)(sp[G] * 255);
              tb=(int)(sp[B] * 255);
            }
 else {
              tr=r2;
              tg=g2;
              tb=b2;
            }
          }
          int weight=smooth ? coverage(x) : 255;
          if (weight != 255)           ta=(ta * weight) >> 8;
        }
 else {
          int tpixel=tpixels[txy];
          if (tformat == ALPHA) {
            ta=tpixel;
            if (interpARGB) {
              tr=(int)(sp[R] * 255);
              tg=(int)(sp[G] * 255);
              tb=(int)(sp[B] * 255);
              if (sp[A] != 1) {
                ta=(((int)(sp[A] * 255)) * ta) >> 8;
              }
            }
 else {
              tr=r2;
              tg=g2;
              tb=b2;
              ta=(a2orig * ta) >> 8;
            }
          }
 else {
            ta=(tformat == RGB) ? 255 : (tpixel >> 24) & 0xff;
            if (interpARGB) {
              tr=(((int)(sp[R] * 255)) * ((tpixel >> 16) & 0xff)) >> 8;
              tg=(((int)(sp[G] * 255)) * ((tpixel >> 8) & 0xff)) >> 8;
              tb=(((int)(sp[B] * 255)) * ((tpixel) & 0xff)) >> 8;
              ta=(((int)(sp[A] * 255)) * ta) >> 8;
            }
 else {
              tr=(r2 * ((tpixel >> 16) & 0xff)) >> 8;
              tg=(g2 * ((tpixel >> 8) & 0xff)) >> 8;
              tb=(b2 * ((tpixel) & 0xff)) >> 8;
              ta=(a2orig * ta) >> 8;
            }
          }
        }
        if ((ta == 254) || (ta == 255)) {
          pixels[offset + x]=0xff000000 | (tr << 16) | (tg << 8)| tb;
          if (updateZBuffer)           zbuffer[offset + x]=sp[Z];
        }
 else {
          int a1=255 - ta;
          int r1=(pixels[offset + x] >> 16) & 0xff;
          int g1=(pixels[offset + x] >> 8) & 0xff;
          int b1=(pixels[offset + x]) & 0xff;
          pixels[offset + x]=0xff000000 | (((tr * ta + r1 * a1) >> 8) << 16) | ((tg * ta + g1 * a1) & 0xff00)| ((tb * ta + b1 * a1) >> 8);
          if (updateZBuffer && ta > ZBUFFER_MIN_COVERAGE)           zbuffer[offset + x]=sp[Z];
        }
      }
 else {
        int weight=smooth ? coverage(x) : 255;
        if (interpARGB) {
          r2=(int)(sp[R] * 255);
          g2=(int)(sp[G] * 255);
          b2=(int)(sp[B] * 255);
          if (sp[A] != 1)           weight=(weight * ((int)(sp[A] * 255))) >> 8;
          if (weight == 255) {
            rgba=0xff000000 | (r2 << 16) | (g2 << 8)| b2;
          }
        }
 else {
          if (a2orig != 255)           weight=(weight * a2orig) >> 8;
        }
        if (weight == 255) {
          pixels[offset + x]=rgba;
          if (updateZBuffer)           zbuffer[offset + x]=sp[Z];
        }
 else {
          int r1=(pixels[offset + x] >> 16) & 0xff;
          int g1=(pixels[offset + x] >> 8) & 0xff;
          int b1=(pixels[offset + x]) & 0xff;
          a2=weight;
          int a1=255 - a2;
          pixels[offset + x]=(0xff000000 | ((r1 * a1 + r2 * a2) >> 8) << 16 | ((g1 * a1 + g2 * a2) >> 8) << 8 | ((b1 * a1 + b2 * a2) >> 8));
          if (updateZBuffer && a2 > ZBUFFER_MIN_COVERAGE)           zbuffer[offset + x]=sp[Z];
        }
      }
    }
    if (!smooth || ((x >= truelx) && (x <= truerx))) {
      increment(sp,sdp);
    }
  }
  firstModY=-1;
  interpX=true;
}

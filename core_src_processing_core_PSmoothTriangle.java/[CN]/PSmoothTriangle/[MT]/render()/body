{
  if (vertexCount < 3)   return;
  smooth=true;
  pixels=parent.pixels;
  zbuffer=parent.zbuffer;
  noDepthTest=false;
  texture_smooth=true;
  width=smooth ? parent.width * SUBXRES : parent.width;
  height=smooth ? parent.height * SUBYRES : parent.height;
  width1=width - 1;
  height1=height - 1;
  if (!interpARGB) {
    r2=(int)(vertices[0][R] * 255);
    g2=(int)(vertices[0][G] * 255);
    b2=(int)(vertices[0][B] * 255);
    a2=(int)(vertices[0][A] * 255);
    a2orig=a2;
    rgba=0xff000000 | (r2 << 16) | (g2 << 8)| b2;
  }
  for (int i=0; i < vertexCount; i++) {
    r[i]=0;
    dr[i]=0;
    l[i]=0;
    dl[i]=0;
  }
  if (smooth) {
    for (int i=0; i < vertexCount; i++) {
      vertices[i][X]*=SUBXRES;
      vertices[i][Y]*=SUBYRES;
    }
    firstModY=-1;
  }
  int topi=0;
  float ymin=vertices[0][Y];
  float ymax=vertices[0][Y];
  for (int i=1; i < vertexCount; i++) {
    if (vertices[i][Y] < ymin) {
      ymin=vertices[i][Y];
      topi=i;
    }
    if (vertices[i][Y] > ymax)     ymax=vertices[i][Y];
  }
  lastY=(int)(ymax - 0.5f);
  int lefti=topi;
  int righti=topi;
  int y=(int)(ymin + 0.5f);
  int lefty=y - 1;
  int righty=y - 1;
  interpX=true;
  int remaining=vertexCount;
  while (remaining > 0) {
    while ((lefty <= y) && (remaining > 0)) {
      remaining--;
      int i=(lefti != 0) ? (lefti - 1) : (vertexCount - 1);
      incrementalize_y(vertices[lefti],vertices[i],l,dl,y);
      lefty=(int)(vertices[i][Y] + 0.5f);
      lefti=i;
    }
    while ((righty <= y) && (remaining > 0)) {
      remaining--;
      int i=(righti != vertexCount - 1) ? (righti + 1) : 0;
      incrementalize_y(vertices[righti],vertices[i],r,dr,y);
      righty=(int)(vertices[i][Y] + 0.5f);
      righti=i;
    }
    while (y < lefty && y < righty) {
      if ((y >= 0) && (y < height)) {
        if (l[X] <= r[X])         scanline(y,l,r);
 else         scanline(y,r,l);
      }
      y++;
      increment(l,dl);
      increment(r,dr);
    }
  }
}

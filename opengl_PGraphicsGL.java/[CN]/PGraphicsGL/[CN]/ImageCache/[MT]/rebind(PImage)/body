{
  if (tindex != -1) {
    gl.glDeleteTextures(1,new int[]{tindex},0);
  }
  int[] tmp=new int[1];
  gl.glGenTextures(1,tmp,0);
  tindex=tmp[0];
  int width2=nextPowerOfTwo(source.width);
  int height2=nextPowerOfTwo(source.height);
  if (maxTextureSize == 0) {
    int maxSize[]=new int[1];
    gl.glGetIntegerv(GL.GL_MAX_TEXTURE_SIZE,maxSize,0);
    maxTextureSize=maxSize[0];
  }
  if ((width2 > maxTextureSize) || (height2 > maxTextureSize)) {
    throw new RuntimeException("Image width and height cannot be" + " larger than " + maxTextureSize + " with your graphics card.");
  }
  if ((width2 > twidth) || (height2 > theight)) {
    tpixels=null;
  }
  if (tpixels == null) {
    twidth=width2;
    theight=height2;
    tpixels=new int[twidth * theight];
    tbuffer=BufferUtil.newIntBuffer(twidth * theight);
  }
  int p=0;
  int t=0;
  if (BIG_ENDIAN) {
switch (source.format) {
case ALPHA:
      for (int y=0; y < source.height; y++) {
        for (int x=0; x < source.width; x++) {
          tpixels[t++]=0xFFFFFF00 | source.pixels[p++];
        }
        t+=twidth - source.width;
      }
    break;
case RGB:
  for (int y=0; y < source.height; y++) {
    for (int x=0; x < source.width; x++) {
      int pixel=source.pixels[p++];
      tpixels[t++]=(pixel << 8) | 0xff;
    }
    t+=twidth - source.width;
  }
break;
case ARGB:
for (int y=0; y < source.height; y++) {
for (int x=0; x < source.width; x++) {
  int pixel=source.pixels[p++];
  tpixels[t++]=(pixel << 8) | ((pixel >> 24) & 0xff);
}
t+=twidth - source.width;
}
break;
}
}
 else {
switch (source.format) {
case ALPHA:
for (int y=0; y < source.height; y++) {
for (int x=0; x < source.width; x++) {
tpixels[t++]=(source.pixels[p++] << 24) | 0x00FFFFFF;
}
t+=twidth - source.width;
}
break;
case RGB:
for (int y=0; y < source.height; y++) {
for (int x=0; x < source.width; x++) {
int pixel=source.pixels[p++];
tpixels[t++]=0xff000000 | ((pixel & 0xFF) << 16) | ((pixel & 0xFF0000) >> 16)| (pixel & 0x0000FF00);
}
t+=twidth - source.width;
}
break;
case ARGB:
for (int y=0; y < source.height; y++) {
for (int x=0; x < source.width; x++) {
int pixel=source.pixels[p++];
tpixels[t++]=((pixel & 0xFF) << 16) | ((pixel & 0xFF0000) >> 16) | (pixel & 0xFF00FF00);
}
t+=twidth - source.width;
}
break;
}
}
tbuffer.put(tpixels);
tbuffer.rewind();
gl.glBindTexture(GL.GL_TEXTURE_2D,tindex);
gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT,1);
gl.glTexImage2D(GL.GL_TEXTURE_2D,0,4,twidth,theight,0,GL.GL_RGBA,GL.GL_UNSIGNED_BYTE,tbuffer);
gl.glTexParameterf(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);
gl.glTexParameterf(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);
gl.glTexEnvf(GL.GL_TEXTURE_ENV,GL.GL_TEXTURE_ENV_MODE,GL.GL_MODULATE);
}

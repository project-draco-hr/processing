{
  if ((program.length() > 0) && program.charAt(program.length() - 1) != '\n') {
    program+="\n";
  }
  if (PdePreferences.getBoolean("preproc.substitute_unicode")) {
    char p[]=program.toCharArray();
    int unicodeCount=0;
    for (int i=0; i < p.length; i++) {
      if (p[i] > 127)       unicodeCount++;
    }
    if (unicodeCount != 0) {
      int index=0;
      char p2[]=new char[p.length + unicodeCount * 5];
      for (int i=0; i < p.length; i++) {
        if (p[i] < 128) {
          p2[index++]=p[i];
        }
 else         if (p[i] == 160) {
          p2[index++]=' ';
        }
 else {
          int c=p[i];
          p2[index++]='\\';
          p2[index++]='u';
          char str[]=Integer.toHexString(c).toCharArray();
          for (int m=0; m < 4 - str.length; m++)           p2[index++]='0';
          System.arraycopy(str,0,p2,index,str.length);
          index+=str.length;
        }
      }
      program=new String(p2,0,index);
    }
  }
  PatternMatcher matcher=new Perl5Matcher();
  PatternCompiler compiler=new Perl5Compiler();
  String mess="^\\s*(import\\s+\\S+\\s*;)";
  java.util.Vector imports=new java.util.Vector();
  Pattern pattern=null;
  try {
    pattern=compiler.compile(mess);
  }
 catch (  MalformedPatternException e) {
    e.printStackTrace();
    return null;
  }
  do {
    PatternMatcherInput input=new PatternMatcherInput(program);
    if (!matcher.contains(input,pattern))     break;
    MatchResult result=matcher.getMatch();
    String piece=result.group(1).toString();
    int len=piece.length();
    imports.add(piece);
    int idx=program.indexOf(piece);
    program=program.substring(0,idx) + program.substring(idx + len);
  }
 while (true);
  extraImports=new String[imports.size()];
  imports.copyInto(extraImports);
  this.programReader=new StringReader(program);
  this.buildPath=buildPath;
  PdeLexer lexer=new PdeLexer(programReader);
  lexer.setTokenObjectClass("antlr.CommonHiddenStreamToken");
  filter=new TokenStreamCopyingHiddenTokenFilter(lexer);
  filter.hide(PdeRecognizer.SL_COMMENT);
  filter.hide(PdeRecognizer.ML_COMMENT);
  filter.hide(PdeRecognizer.WS);
  filter.copy(PdeRecognizer.SEMI);
  filter.copy(PdeRecognizer.LPAREN);
  filter.copy(PdeRecognizer.RPAREN);
  filter.copy(PdeRecognizer.LCURLY);
  filter.copy(PdeRecognizer.RCURLY);
  filter.copy(PdeRecognizer.COMMA);
  filter.copy(PdeRecognizer.RBRACK);
  filter.copy(PdeRecognizer.LBRACK);
  filter.copy(PdeRecognizer.COLON);
  PdeRecognizer parser=new PdeRecognizer(filter);
  parser.setASTNodeClass("antlr.ExtendedCommonASTWithHiddenTokens");
  parser.pdeProgram();
  ASTFactory factory=new ASTFactory();
  AST parserAST=parser.getAST();
  AST rootNode=factory.create(ROOT_ID,"AST ROOT");
  rootNode.setFirstChild(parserAST);
  ((CommonAST)parserAST).setVerboseStringConversion(true,parser.getTokenNames());
  if (programType == JAVA) {
    name=getFirstClassName(parserAST);
  }
  if (name == null)   return null;
  PdeEmitter emitter=new PdeEmitter();
  File streamFile=new File(buildPath,name + ".java");
  PrintStream stream=new PrintStream(new FileOutputStream(streamFile));
  writeHeader(stream,extraImports,name);
  emitter.setOut(stream);
  emitter.print(rootNode);
  writeFooter(stream);
  stream.close();
  if (PdePreferences.getBoolean("preproc.output_parse_tree")) {
    stream=new PrintStream(new FileOutputStream("parseTree.xml"));
    stream.println("<?xml version=\"1.0\"?>");
    stream.println("<document>");
    OutputStreamWriter writer=new OutputStreamWriter(stream);
    if (parserAST != null) {
      ((CommonAST)parserAST).xmlSerialize(writer);
    }
    writer.flush();
    stream.println("</document>");
    writer.close();
  }
  return name;
}

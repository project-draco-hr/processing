{
  ActiveRegion regLo=RegionBelow(regUp);
  GLUhalfEdge eUp, eLo;
  for (; ; ) {
    while (regLo.dirty) {
      regUp=regLo;
      regLo=RegionBelow(regLo);
    }
    if (!regUp.dirty) {
      regLo=regUp;
      regUp=RegionAbove(regUp);
      if (regUp == null || !regUp.dirty) {
        return;
      }
    }
    regUp.dirty=false;
    eUp=regUp.eUp;
    eLo=regLo.eUp;
    if (eUp.Sym.Org != eLo.Sym.Org) {
      if (CheckForLeftSplice(tess,regUp)) {
        if (regLo.fixUpperEdge) {
          DeleteRegion(tess,regLo);
          if (!Mesh.__gl_meshDelete(eLo))           throw new RuntimeException();
          regLo=RegionBelow(regUp);
          eLo=regLo.eUp;
        }
 else         if (regUp.fixUpperEdge) {
          DeleteRegion(tess,regUp);
          if (!Mesh.__gl_meshDelete(eUp))           throw new RuntimeException();
          regUp=RegionAbove(regLo);
          eUp=regUp.eUp;
        }
      }
    }
    if (eUp.Org != eLo.Org) {
      if (eUp.Sym.Org != eLo.Sym.Org && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.Sym.Org == tess.event || eLo.Sym.Org == tess.event)) {
        if (CheckForIntersect(tess,regUp)) {
          return;
        }
      }
 else {
        CheckForRightSplice(tess,regUp);
      }
    }
    if (eUp.Org == eLo.Org && eUp.Sym.Org == eLo.Sym.Org) {
      AddWinding(eLo,eUp);
      DeleteRegion(tess,regUp);
      if (!Mesh.__gl_meshDelete(eUp))       throw new RuntimeException();
      regUp=RegionAbove(regLo);
    }
  }
}

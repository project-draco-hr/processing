{
  Map<String,JMenuItem> toolItems=new HashMap<String,JMenuItem>();
  for (  final ToolContribution tool : tools) {
    try {
      tool.init(Editor.this);
      addToolItem(tool,toolItems);
    }
 catch (    VerifyError ve) {
      System.err.println("\"" + tool.getMenuTitle() + "\" is not "+ "compatible with this version of Processing");
    }
catch (    NoSuchMethodError nsme) {
      System.err.println("\"" + tool.getMenuTitle() + "\" is not "+ "compatible with this version of Processing");
      System.err.println("The " + nsme.getMessage() + " method no longer exists.");
      Messages.loge("Incompatible Tool found during tool.init()",nsme);
    }
catch (    NoClassDefFoundError ncdfe) {
      System.err.println("\"" + tool.getMenuTitle() + "\" is not "+ "compatible with this version of Processing");
      System.err.println("The " + ncdfe.getMessage() + " class is no longer available.");
      Messages.loge("Incompatible Tool found during tool.init()",ncdfe);
    }
catch (    AbstractMethodError ame) {
      System.err.println("\"" + tool.getMenuTitle() + "\" is not "+ "compatible with this version of Processing");
    }
catch (    Error err) {
      System.err.println("An error occurred inside \"" + tool.getMenuTitle() + "\"");
      err.printStackTrace();
    }
catch (    Exception ex) {
      System.err.println("An exception occurred inside \"" + tool.getMenuTitle() + "\"");
      ex.printStackTrace();
    }
  }
  ArrayList<String> toolList=new ArrayList<String>(toolItems.keySet());
  if (toolList.size() > 0) {
    menu.addSeparator();
    Collections.sort(toolList);
    for (    String title : toolList) {
      menu.add(toolItems.get(title));
    }
  }
}

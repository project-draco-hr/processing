{
  int nInVert=in.getNumEdgeVertices(false);
  if (noCapsJoins(nInVert)) {
    int nInInd=in.getNumEdgeIndices(false);
    tess.polyVertexCheck(nInVert);
    tess.polyIndexCheck(nInInd);
    int index=in.renderMode == RETAINED ? tess.polyIndexCache.addNew() : tess.polyIndexCache.getLast();
    firstLineIndexCache=index;
    if (firstPolyIndexCache == -1)     firstPolyIndexCache=index;
    for (int i=in.firstEdge; i <= in.lastEdge; i++) {
      int[] edge=in.edges[i];
      int i0=edge[0];
      int i1=edge[1];
      index=addLine2D(i0,i1,index,true);
    }
    lastLineIndexCache=lastPolyIndexCache=index;
  }
 else {
    LinePath path=new LinePath(LinePath.WIND_NON_ZERO);
    for (int i=in.firstEdge; i <= in.lastEdge; i++) {
      int[] edge=in.edges[i];
      int i0=edge[0];
      int i1=edge[1];
switch (edge[2]) {
case EDGE_MIDDLE:
        path.lineTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
      break;
case EDGE_START:
    path.moveTo(in.vertices[3 * i0 + 0],in.vertices[3 * i0 + 1]);
  path.lineTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
break;
case EDGE_STOP:
path.lineTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
path.moveTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
break;
case EDGE_SINGLE:
path.moveTo(in.vertices[3 * i0 + 0],in.vertices[3 * i0 + 1]);
path.lineTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
path.moveTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
break;
}
}
tessellateLinePath(path);
}
}

{
  OPENGL_VENDOR=pgl.getString(PGL.VENDOR);
  OPENGL_RENDERER=pgl.getString(PGL.RENDERER);
  OPENGL_VERSION=pgl.getString(PGL.VERSION);
  OPENGL_EXTENSIONS=pgl.getString(PGL.EXTENSIONS);
  GLSL_VERSION=pgl.getString(PGL.SHADING_LANGUAGE_VERSION);
  int major=pgl.getGLVersion()[0];
  if (major < 2) {
    PGraphics.showWarning("The OpenGL version in this is less than 2.0 so " + "Processing might not draw things properly");
    if (OPENGL_EXTENSIONS.indexOf("_fragment_shader") == -1 || OPENGL_EXTENSIONS.indexOf("_vertex_shader") == -1 || OPENGL_EXTENSIONS.indexOf("_shader_objects") == -1 || OPENGL_EXTENSIONS.indexOf("_shading_language") == -1) {
      throw new RuntimeException("GLSL shaders are not supported by this " + "video card");
    }
  }
  npotTexSupported=-1 < OPENGL_EXTENSIONS.indexOf("_texture_non_power_of_two");
  autoMipmapGenSupported=-1 < OPENGL_EXTENSIONS.indexOf("_generate_mipmap");
  fboMultisampleSupported=-1 < OPENGL_EXTENSIONS.indexOf("_framebuffer_multisample");
  packedDepthStencilSupported=-1 < OPENGL_EXTENSIONS.indexOf("_packed_depth_stencil");
  try {
    pgl.blendEquation(PGL.FUNC_ADD);
    blendEqSupported=true;
  }
 catch (  Exception e) {
    blendEqSupported=false;
  }
  int temp[]=new int[2];
  pgl.getIntegerv(PGL.MAX_TEXTURE_SIZE,temp,0);
  maxTextureSize=temp[0];
  pgl.getIntegerv(PGL.MAX_SAMPLES,temp,0);
  maxSamples=temp[0];
  pgl.getIntegerv(PGL.ALIASED_LINE_WIDTH_RANGE,temp,0);
  maxLineWidth=temp[1];
  pgl.getIntegerv(PGL.ALIASED_POINT_SIZE_RANGE,temp,0);
  maxPointSize=temp[1];
  pgl.getIntegerv(PGL.DEPTH_BITS,temp,0);
  depthBits=temp[0];
  pgl.getIntegerv(PGL.STENCIL_BITS,temp,0);
  stencilBits=temp[0];
  glParamsRead=true;
}

{
  OPENGL_VENDOR=pgl.getString(PGL.VENDOR);
  OPENGL_RENDERER=pgl.getString(PGL.RENDERER);
  OPENGL_VERSION=pgl.getString(PGL.VERSION);
  OPENGL_EXTENSIONS=pgl.getString(PGL.EXTENSIONS);
  GLSL_VERSION=pgl.getString(PGL.SHADING_LANGUAGE_VERSION);
  if (-1 == OPENGL_EXTENSIONS.indexOf("_framebuffer_object")) {
    throw new RuntimeException("No framebuffer objects available");
  }
  if (-1 == OPENGL_EXTENSIONS.indexOf("_vertex_buffer_object")) {
    throw new RuntimeException("No vertex buffer objects available");
  }
  if (-1 == OPENGL_EXTENSIONS.indexOf("_vertex_shader")) {
    throw new RuntimeException("No vertex shaders available");
  }
  if (-1 == OPENGL_EXTENSIONS.indexOf("_fragment_shader")) {
    throw new RuntimeException("No fragment shaders available");
  }
  npotTexSupported=-1 < OPENGL_EXTENSIONS.indexOf("_texture_non_power_of_two");
  autoMipmapGenSupported=-1 < OPENGL_EXTENSIONS.indexOf("_generate_mipmap");
  fboMultisampleSupported=-1 < OPENGL_EXTENSIONS.indexOf("_framebuffer_multisample");
  packedDepthStencilSupported=-1 < OPENGL_EXTENSIONS.indexOf("_packed_depth_stencil");
  try {
    pgl.blendEquation(PGL.FUNC_ADD);
    blendEqSupported=true;
  }
 catch (  Exception e) {
    blendEqSupported=false;
  }
  int temp[]=new int[2];
  pgl.getIntegerv(PGL.MAX_TEXTURE_SIZE,temp,0);
  maxTextureSize=temp[0];
  pgl.getIntegerv(PGL.MAX_SAMPLES,temp,0);
  maxSamples=temp[0];
  pgl.getIntegerv(PGL.ALIASED_LINE_WIDTH_RANGE,temp,0);
  maxLineWidth=temp[1];
  pgl.getIntegerv(PGL.ALIASED_POINT_SIZE_RANGE,temp,0);
  maxPointSize=temp[1];
  pgl.getIntegerv(PGL.DEPTH_BITS,temp,0);
  depthBits=temp[0];
  pgl.getIntegerv(PGL.STENCIL_BITS,temp,0);
  stencilBits=temp[0];
  glParamsRead=true;
}

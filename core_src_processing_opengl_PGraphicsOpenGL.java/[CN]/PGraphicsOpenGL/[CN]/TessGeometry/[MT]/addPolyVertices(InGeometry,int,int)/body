{
  int index;
  int nvert=i1 - i0 + 1;
  polyVertexCheck(nvert);
  if (renderMode == IMMEDIATE && flushMode == FLUSH_WHEN_FULL) {
    PMatrix3D mm=modelview;
    PMatrix3D nm=modelviewInv;
    for (int i=0; i < nvert; i++) {
      int inIdx=i0 + i;
      int tessIdx=firstPolyVertex + i;
      index=3 * inIdx;
      float x=in.vertices[index++];
      float y=in.vertices[index++];
      float z=in.vertices[index];
      index=3 * inIdx;
      float nx=in.normals[index++];
      float ny=in.normals[index++];
      float nz=in.normals[index];
      index=4 * tessIdx;
      polyVertices.put(index++,x * mm.m00 + y * mm.m01 + z * mm.m02 + mm.m03);
      polyVertices.put(index++,x * mm.m10 + y * mm.m11 + z * mm.m12 + mm.m13);
      polyVertices.put(index++,x * mm.m20 + y * mm.m21 + z * mm.m22 + mm.m23);
      polyVertices.put(index,x * mm.m30 + y * mm.m31 + z * mm.m32 + mm.m33);
      index=3 * tessIdx;
      polyNormals.put(index++,nx * nm.m00 + ny * nm.m10 + nz * nm.m20);
      polyNormals.put(index++,nx * nm.m01 + ny * nm.m11 + nz * nm.m21);
      polyNormals.put(index,nx * nm.m02 + ny * nm.m12 + nz * nm.m22);
    }
  }
 else {
    if (nvert <= PGL.MIN_ARRAYCOPY_SIZE) {
      for (int i=0; i < nvert; i++) {
        int inIdx=i0 + i;
        int tessIdx=firstPolyVertex + i;
        index=3 * inIdx;
        float x=in.vertices[index++];
        float y=in.vertices[index++];
        float z=in.vertices[index];
        index=3 * inIdx;
        float nx=in.normals[index++];
        float ny=in.normals[index++];
        float nz=in.normals[index];
        index=4 * tessIdx;
        polyVertices.put(index++,x);
        polyVertices.put(index++,y);
        polyVertices.put(index++,z);
        polyVertices.put(index,1);
        index=3 * tessIdx;
        polyNormals.put(index++,nx);
        polyNormals.put(index++,ny);
        polyNormals.put(index,nz);
      }
    }
 else {
      for (int i=0; i < nvert; i++) {
        int inIdx=i0 + i;
        int tessIdx=firstPolyVertex + i;
        polyVertices.position(4 * tessIdx);
        polyVertices.put(in.vertices,3 * inIdx,3);
        polyVertices.put(4 * tessIdx + 3,1);
      }
      polyNormals.position(3 * firstPolyVertex);
      polyNormals.put(in.normals,3 * i0,3 * nvert);
    }
  }
  if (nvert <= PGL.MIN_ARRAYCOPY_SIZE) {
    for (int i=0; i < nvert; i++) {
      int inIdx=i0 + i;
      int tessIdx=firstPolyVertex + i;
      index=2 * inIdx;
      float u=in.texcoords[index++];
      float v=in.texcoords[index];
      polyColors.put(tessIdx,in.colors[inIdx]);
      index=2 * tessIdx;
      polyTexcoords.put(index++,u);
      polyTexcoords.put(index,v);
      polyAmbient.put(tessIdx,in.ambient[inIdx]);
      polySpecular.put(tessIdx,in.specular[inIdx]);
      polyEmissive.put(tessIdx,in.emissive[inIdx]);
      polyShininess.put(tessIdx,in.shininess[inIdx]);
    }
  }
 else {
    polyColors.position(firstPolyVertex);
    polyColors.put(in.colors,i0,nvert);
    polyTexcoords.position(2 * firstPolyVertex);
    polyTexcoords.put(in.texcoords,2 * i0,2 * nvert);
    polyAmbient.position(firstPolyVertex);
    polyAmbient.put(in.ambient,i0,nvert);
    polySpecular.position(firstPolyVertex);
    polySpecular.put(in.specular,i0,nvert);
    polyEmissive.position(firstPolyVertex);
    polyEmissive.put(in.emissive,i0,nvert);
    polyShininess.position(firstPolyVertex);
    polyShininess.put(in.shininess,i0,nvert);
  }
}

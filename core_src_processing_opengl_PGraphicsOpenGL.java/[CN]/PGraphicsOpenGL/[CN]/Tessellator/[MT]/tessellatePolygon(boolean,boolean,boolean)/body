{
  beginTex();
  int nInVert=in.vertexCount;
  if (fill && 3 <= nInVert) {
    firstPolyIndexCache=-1;
    boolean clamp=clampPolygon();
    callback.init(in.renderMode == RETAINED,false,calcNormals,clamp);
    gluTess.beginPolygon();
    if (solid) {
      gluTess.setWindingRule(PGL.TESS_WINDING_NONZERO);
    }
 else {
      gluTess.setWindingRule(PGL.TESS_WINDING_ODD);
    }
    gluTess.beginContour();
    int vidx=0;
    int cidx=0;
    while (vidx < in.vertexCount) {
      int code=VERTEX;
      boolean brk=false;
      if (in.codes != null) {
        code=in.codes[cidx];
        if (code == BREAK) {
          brk=true;
          code=in.codes[cidx++];
        }
      }
      if (brk) {
        gluTess.endContour();
        gluTess.beginContour();
      }
      if (code == BEZIER_VERTEX) {
        addBezierVertex(vidx);
        vidx+=3;
      }
 else       if (code == QUADRATIC_VERTEX) {
        addQuadraticVertex(vidx);
        vidx+=2;
      }
 else       if (code == CURVE_VERTEX) {
        addCurveVertex(vidx);
        vidx++;
      }
 else {
        addVertex(vidx);
        vidx++;
      }
    }
    gluTess.endContour();
    gluTess.endPolygon();
  }
  endTex();
  tessellateEdges();
}

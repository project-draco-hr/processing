{
  IndexCache cache=tess.polyIndexCache;
  int count=cache.vertexCount[index];
  if (PGL.MAX_VERTEX_INDEX1 <= count + 4) {
    index=cache.addNew();
    count=0;
  }
  int iidx=cache.indexOffset[index] + cache.indexCount[index];
  int vidx=cache.vertexOffset[index] + cache.vertexCount[index];
  int color=constStroke ? strokeColor : in.strokeColors[i0];
  float weight=constStroke ? strokeWeight : in.strokeWeights[i0];
  if (subPixelStroke(weight))   clampingEnabled=false;
  float x0=in.vertices[3 * i0 + 0];
  float y0=in.vertices[3 * i0 + 1];
  float x1=in.vertices[3 * i1 + 0];
  float y1=in.vertices[3 * i1 + 1];
  float dirx=x1 - x0;
  float diry=y1 - y0;
  float llen=PApplet.sqrt(dirx * dirx + diry * diry);
  float normx=0, normy=0;
  float dirdx=0, dirdy=0;
  if (nonZero(llen)) {
    normx=-diry / llen;
    normy=+dirx / llen;
    dirdx=(dirx / llen) * PApplet.min(0.75f,weight / 2);
    dirdy=(diry / llen) * PApplet.min(0.75f,weight / 2);
  }
  float normdx=normx * weight / 2;
  float normdy=normy * weight / 2;
  tess.setPolyVertex(vidx++,x0 + normdx - dirdx,y0 + normdy - dirdy,0,color);
  tess.polyIndices[iidx++]=(short)(count + 0);
  tess.setPolyVertex(vidx++,x0 - normdx - dirdx,y0 - normdy - dirdy,0,color);
  tess.polyIndices[iidx++]=(short)(count + 1);
  if (!constStroke) {
    color=in.strokeColors[i1];
    weight=in.strokeWeights[i1];
    normdx=normx * weight / 2;
    normdy=normy * weight / 2;
    if (subPixelStroke(weight))     clampingEnabled=false;
  }
  tess.setPolyVertex(vidx++,x1 - normdx + dirdx,y1 - normdy + dirdy,0,color);
  tess.polyIndices[iidx++]=(short)(count + 2);
  tess.polyIndices[iidx++]=(short)(count + 2);
  tess.polyIndices[iidx++]=(short)(count + 0);
  tess.setPolyVertex(vidx++,x1 + normdx + dirdx,y1 + normdy + dirdy,0,color);
  tess.polyIndices[iidx++]=(short)(count + 3);
  cache.incCounts(index,6,4);
  clampingEnabled=true;
  return index;
}

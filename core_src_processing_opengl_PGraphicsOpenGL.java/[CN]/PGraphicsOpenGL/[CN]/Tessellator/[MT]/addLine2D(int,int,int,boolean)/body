{
  IndexCache cache=tess.polyIndexCache;
  int count=cache.vertexCount[index];
  if (PGL.MAX_VERTEX_INDEX1 <= count + 4) {
    index=cache.addNew();
    count=0;
  }
  int iidx=cache.indexOffset[index] + cache.indexCount[index];
  int vidx=cache.vertexOffset[index] + cache.vertexCount[index];
  int color=constStroke ? strokeColor : in.strokeColors[i0];
  float weight=constStroke ? strokeWeight : in.strokeWeights[i0];
  float x0=in.vertices[3 * i0 + 0];
  float y0=in.vertices[3 * i0 + 1];
  float x1=in.vertices[3 * i1 + 0];
  float y1=in.vertices[3 * i1 + 1];
  float dirx=x1 - x0;
  float diry=y1 - y0;
  float llen=PApplet.sqrt(dirx * dirx + diry * diry);
  float normx=0, normy=0;
  if (nonZero(llen)) {
    normx=-diry / llen;
    normy=+dirx / llen;
  }
  tess.setPolyVertex(vidx++,x0 + normx * weight / 2,y0 + normy * weight / 2,0,color);
  tess.polyIndices.put(iidx++,(short)(count + 0));
  tess.setPolyVertex(vidx++,x0 - normx * weight / 2,y0 - normy * weight / 2,0,color);
  tess.polyIndices.put(iidx++,(short)(count + 1));
  if (!constStroke) {
    color=in.strokeColors[i1];
    weight=in.strokeWeights[i1];
  }
  tess.setPolyVertex(vidx++,x1 - normx * weight / 2,y1 - normy * weight / 2,0,color);
  tess.polyIndices.put(iidx++,(short)(count + 2));
  tess.polyIndices.put(iidx++,(short)(count + 2));
  tess.polyIndices.put(iidx++,(short)(count + 0));
  tess.setPolyVertex(vidx++,x1 + normx * weight / 2,y1 + normy * weight / 2,0,color);
  tess.polyIndices.put(iidx++,(short)(count + 3));
  cache.incCounts(index,6,4);
  return index;
}

{
  long beforeTime=System.nanoTime();
  long overSleepTime=0L;
  int noDelays=0;
  final int NO_DELAYS_PER_YIELD=15;
  if (!online) {
    start();
  }
  while ((Thread.currentThread() == thread) && !finished) {
    if (paused) {
      debug("PApplet.run() paused, calling object wait...");
synchronized (pauseObject) {
        try {
          pauseObject.wait();
          debug("out of wait");
        }
 catch (        InterruptedException e) {
        }
      }
    }
    debug("done with pause");
    if (g != null) {
      getSize(currentSize);
      if (currentSize.width != g.width || currentSize.height != g.height) {
        resizeRenderer(currentSize.width,currentSize.height);
      }
    }
    if (g != null)     g.requestDraw();
    if (frameCount == 1) {
      EventQueue.invokeLater(new Runnable(){
        public void run(){
          requestFocusInWindow();
        }
      }
);
    }
    long afterTime=System.nanoTime();
    long timeDiff=afterTime - beforeTime;
    long sleepTime=(frameRatePeriod - timeDiff) - overSleepTime;
    if (sleepTime > 0) {
      try {
        Thread.sleep(sleepTime / 1000000L,(int)(sleepTime % 1000000L));
        noDelays=0;
      }
 catch (      InterruptedException ex) {
      }
      overSleepTime=(System.nanoTime() - afterTime) - sleepTime;
    }
 else {
      overSleepTime=0L;
      noDelays++;
      if (noDelays > NO_DELAYS_PER_YIELD) {
        Thread.yield();
        noDelays=0;
      }
    }
    beforeTime=System.nanoTime();
  }
  dispose();
  if (exitCalled) {
    exitActual();
  }
}

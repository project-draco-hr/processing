{
  for (int i=0; i < vertexCount; i++) {
    sp[i]=0;
    sdp[i]=0;
  }
  int lx=(int)(l[TX] + 0.49999f);
  if (lx < 0)   lx=0;
  int rx=(int)(r[TX] - 0.5f);
  if (rx > width1)   rx=width1;
  if (lx > rx)   return;
  if (smooth) {
    int mody=MODYRES(y);
    aaleft[mody]=lx;
    aaright[mody]=rx;
    if (firstModY == -1) {
      firstModY=mody;
      aaleftmin=lx;
      aaleftmax=lx;
      aarightmin=rx;
      aarightmax=rx;
    }
 else {
      if (aaleftmin > aaleft[mody])       aaleftmin=aaleft[mody];
      if (aaleftmax < aaleft[mody])       aaleftmax=aaleft[mody];
      if (aarightmin > aaright[mody])       aarightmin=aaright[mody];
      if (aarightmax < aaright[mody])       aarightmax=aaright[mody];
    }
    lastModY=mody;
    if ((mody != SUBYRES1) && (y != lastY))     return;
    aaleftfull=aaleftmax / SUBXRES + 1;
    aarightfull=aarightmin / SUBXRES - 1;
  }
  incrementalizeX(l,r,sp,sdp,lx);
  int offset=smooth ? parent.width * (y / SUBYRES) : parent.width * y;
  int truelx=0, truerx=0;
  if (smooth) {
    truelx=lx / SUBXRES;
    truerx=(rx + SUBXRES1) / SUBXRES;
    lx=aaleftmin / SUBXRES;
    rx=(aarightmax + SUBXRES1) / SUBXRES;
    if (lx < 0)     lx=0;
    if (rx > parent.width1)     rx=parent.width1;
  }
  interpX=false;
  int tr, tg, tb, ta;
  for (int x=lx; x <= rx; x++) {
    if (interpUV) {
      int tu=(int)(sp[U] * twidth);
      int tv=(int)(sp[V] * theight);
      if (tu > twidth1)       tu=twidth1;
      if (tv > theight1)       tv=theight1;
      if (tu < 0)       tu=0;
      if (tv < 0)       tv=0;
      int txy=tv * twidth + tu;
      int tuf1=(int)(255f * (sp[U] * twidth - (float)tu));
      int tvf1=(int)(255f * (sp[V] * theight - (float)tv));
      int tuf=255 - tuf1;
      int tvf=255 - tvf1;
      int pixel00=tpixels[txy];
      int pixel01=(tv < theight1) ? tpixels[txy + twidth] : tpixels[txy];
      int pixel10=(tu < twidth1) ? tpixels[txy + 1] : tpixels[txy];
      int pixel11=((tv < theight1) && (tu < twidth1)) ? tpixels[txy + twidth + 1] : tpixels[txy];
      int p00, p01, p10, p11;
      int px0, px1;
      if (tformat == ALPHA) {
        px0=(pixel00 * tuf + pixel10 * tuf1) >> 8;
        px1=(pixel01 * tuf + pixel11 * tuf1) >> 8;
        ta=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[A] * 255)) : a2orig)) >> 8;
      }
 else       if (tformat == ARGB) {
        p00=(pixel00 >> 24) & 0xff;
        p01=(pixel01 >> 24) & 0xff;
        p10=(pixel10 >> 24) & 0xff;
        p11=(pixel11 >> 24) & 0xff;
        px0=(p00 * tuf + p10 * tuf1) >> 8;
        px1=(p01 * tuf + p11 * tuf1) >> 8;
        ta=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[A] * 255)) : a2orig)) >> 8;
      }
 else {
        ta=interpARGB ? ((int)(sp[A] * 255)) : a2orig;
      }
      if ((tformat == RGB) || (tformat == ARGB)) {
        p00=(pixel00 >> 16) & 0xff;
        p01=(pixel01 >> 16) & 0xff;
        p10=(pixel10 >> 16) & 0xff;
        p11=(pixel11 >> 16) & 0xff;
        px0=(p00 * tuf + p10 * tuf1) >> 8;
        px1=(p01 * tuf + p11 * tuf1) >> 8;
        tr=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[R] * 255)) : r2)) >> 8;
        p00=(pixel00 >> 8) & 0xff;
        p01=(pixel01 >> 8) & 0xff;
        p10=(pixel10 >> 8) & 0xff;
        p11=(pixel11 >> 8) & 0xff;
        px0=(p00 * tuf + p10 * tuf1) >> 8;
        px1=(p01 * tuf + p11 * tuf1) >> 8;
        tg=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[G] * 255)) : g2)) >> 8;
        p00=pixel00 & 0xff;
        p01=pixel01 & 0xff;
        p10=pixel10 & 0xff;
        p11=pixel11 & 0xff;
        px0=(p00 * tuf + p10 * tuf1) >> 8;
        px1=(p01 * tuf + p11 * tuf1) >> 8;
        tb=(((px0 * tvf + px1 * tvf1) >> 8) * (interpARGB ? ((int)(sp[B] * 255)) : b2)) >> 8;
      }
 else {
        if (interpARGB) {
          tr=(int)(sp[R] * 255);
          tg=(int)(sp[G] * 255);
          tb=(int)(sp[B] * 255);
        }
 else {
          tr=r2;
          tg=g2;
          tb=b2;
        }
      }
      int weight=smooth ? coverage(x) : 255;
      if (weight != 255)       ta=ta * weight >> 8;
      if ((ta == 254) || (ta == 255)) {
        pixels[offset + x]=0xff000000 | (tr << 16) | (tg << 8)| tb;
      }
 else {
        int a1=255 - ta;
        int r1=(pixels[offset + x] >> 16) & 0xff;
        int g1=(pixels[offset + x] >> 8) & 0xff;
        int b1=(pixels[offset + x]) & 0xff;
        pixels[offset + x]=0xff000000 | (((tr * ta + r1 * a1) >> 8) << 16) | ((tg * ta + g1 * a1) & 0xff00)| ((tb * ta + b1 * a1) >> 8);
      }
    }
 else {
      int weight=smooth ? coverage(x) : 255;
      if (interpARGB) {
        r2=(int)(sp[R] * 255);
        g2=(int)(sp[G] * 255);
        b2=(int)(sp[B] * 255);
        if (sp[A] != 1)         weight=(weight * ((int)(sp[A] * 255))) >> 8;
        if (weight == 255) {
          rgba=0xff000000 | (r2 << 16) | (g2 << 8)| b2;
        }
      }
 else {
        if (a2orig != 255)         weight=(weight * a2orig) >> 8;
      }
      if (weight == 255) {
        pixels[offset + x]=rgba;
      }
 else {
        int r1=(pixels[offset + x] >> 16) & 0xff;
        int g1=(pixels[offset + x] >> 8) & 0xff;
        int b1=(pixels[offset + x]) & 0xff;
        a2=weight;
        int a1=255 - a2;
        pixels[offset + x]=(0xff000000 | ((r1 * a1 + r2 * a2) >> 8) << 16 | ((g1 * a1 + g2 * a2) >> 8) << 8 | ((b1 * a1 + b2 * a2) >> 8));
      }
    }
    if (!smooth || ((x >= truelx) && (x <= truerx))) {
      increment(sp,sdp);
    }
  }
  firstModY=-1;
  interpX=true;
}

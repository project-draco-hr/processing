{
  report("render_triangles in");
  for (int i=0; i < triangleCount; i++) {
    float a[]=vertices[triangles[i][VERTEX1]];
    float b[]=vertices[triangles[i][VERTEX2]];
    float c[]=vertices[triangles[i][VERTEX3]];
    float ar=clamp(triangleColors[i][0][TRI_DIFFUSE_R] + triangleColors[i][0][TRI_SPECULAR_R]);
    float ag=clamp(triangleColors[i][0][TRI_DIFFUSE_G] + triangleColors[i][0][TRI_SPECULAR_G]);
    float ab=clamp(triangleColors[i][0][TRI_DIFFUSE_B] + triangleColors[i][0][TRI_SPECULAR_B]);
    float br=clamp(triangleColors[i][1][TRI_DIFFUSE_R] + triangleColors[i][1][TRI_SPECULAR_R]);
    float bg=clamp(triangleColors[i][1][TRI_DIFFUSE_G] + triangleColors[i][1][TRI_SPECULAR_G]);
    float bb=clamp(triangleColors[i][1][TRI_DIFFUSE_B] + triangleColors[i][1][TRI_SPECULAR_B]);
    float cr=clamp(triangleColors[i][2][TRI_DIFFUSE_R] + triangleColors[i][2][TRI_SPECULAR_R]);
    float cg=clamp(triangleColors[i][2][TRI_DIFFUSE_G] + triangleColors[i][2][TRI_SPECULAR_G]);
    float cb=clamp(triangleColors[i][2][TRI_DIFFUSE_B] + triangleColors[i][2][TRI_SPECULAR_B]);
    if (raw != null) {
      raw.colorMode(RGB,1);
      raw.noStroke();
      raw.beginShape(TRIANGLES);
    }
    int textureIndex=triangles[i][TEXTURE_INDEX];
    if (textureIndex != -1) {
      report("before enable");
      gl.glEnable(GL.GL_TEXTURE_2D);
      report("after enable");
      PImage texture=textures[textureIndex];
      bindTexture(texture);
      report("before bind");
      report("after bind");
      ImageCache cash=(ImageCache)texture.cache;
      float uscale=(float)texture.width / (float)cash.twidth;
      float vscale=(float)texture.height / (float)cash.theight;
      gl.glBegin(GL.GL_TRIANGLES);
      gl.glColor4f(ar,ag,ab,a[A]);
      gl.glTexCoord2f(a[U] * uscale,a[V] * vscale);
      gl.glNormal3f(a[NX],a[NY],a[NZ]);
      gl.glVertex3f(a[VX],a[VY],a[VZ]);
      gl.glColor4f(br,bg,bb,b[A]);
      gl.glTexCoord2f(b[U] * uscale,b[V] * vscale);
      gl.glNormal3f(b[NX],b[NY],b[NZ]);
      gl.glVertex3f(b[VX],b[VY],b[VZ]);
      gl.glColor4f(cr,cg,cb,c[A]);
      gl.glTexCoord2f(c[U] * uscale,c[V] * vscale);
      gl.glNormal3f(c[NX],c[NY],c[NZ]);
      gl.glVertex3f(c[VX],c[VY],c[VZ]);
      gl.glEnd();
      report("non-binding 6");
      gl.glDisable(GL.GL_TEXTURE_2D);
      if (raw != null) {
        if (raw instanceof PGraphics3D) {
          if ((a[VW] != 0) && (b[VW] != 0) && (c[VW] != 0)) {
            raw.texture(texture);
            raw.fill(ar,ag,ab,a[A]);
            raw.vertex(a[VX] / a[VW],a[VY] / a[VW],a[VZ] / a[VW],a[U] * uscale,a[V] * vscale);
            raw.fill(br,bg,bb,b[A]);
            raw.vertex(b[VX] / b[VW],b[VY] / b[VW],b[VZ] / b[VW],b[U] * uscale,b[V] * vscale);
            raw.fill(cr,cg,cb,c[A]);
            raw.vertex(c[VX] / c[VW],c[VY] / c[VW],c[VZ] / c[VW],c[U] * uscale,c[V] * vscale);
          }
 else {
            if (reasonablePoint(a[TX],a[TY],a[TZ]) && reasonablePoint(b[TX],b[TY],b[TZ]) && reasonablePoint(c[TX],c[TY],c[TZ])) {
              raw.fill(ar,ag,ab,a[A]);
              raw.vertex(a[TX],a[TY],a[U] * uscale,a[V] * vscale);
              raw.fill(br,bg,bb,b[A]);
              raw.vertex(b[TX],b[TY],b[U] * uscale,b[V] * vscale);
              raw.fill(cr,cg,cb,c[A]);
              raw.vertex(c[TX],c[TY],c[U] * uscale,c[V] * vscale);
            }
          }
        }
      }
    }
 else {
      gl.glBegin(GL.GL_TRIANGLES);
      gl.glColor4f(ar,ag,ab,a[A]);
      gl.glNormal3f(a[NX],a[NY],a[NZ]);
      gl.glVertex3f(a[VX],a[VY],a[VZ]);
      gl.glColor4f(br,bg,bb,b[A]);
      gl.glNormal3f(b[NX],b[NY],b[NZ]);
      gl.glVertex3f(b[VX],b[VY],b[VZ]);
      gl.glColor4f(cr,cg,cb,c[A]);
      gl.glNormal3f(c[NX],c[NY],c[NZ]);
      gl.glVertex3f(c[VX],c[VY],c[VZ]);
      if (raw != null) {
        if (raw instanceof PGraphics3D) {
          if ((a[VW] != 0) && (b[VW] != 0) && (c[VW] != 0)) {
            raw.fill(ar,ag,ab,a[A]);
            raw.vertex(a[VX] / a[VW],a[VY] / a[VW],a[VZ] / a[VW]);
            raw.fill(br,bg,bb,b[A]);
            raw.vertex(b[VX] / b[VW],b[VY] / b[VW],b[VZ] / b[VW]);
            raw.fill(cr,cg,cb,c[A]);
            raw.vertex(c[VX] / c[VW],c[VY] / c[VW],c[VZ] / c[VW]);
          }
        }
 else {
          if (reasonablePoint(a[TX],a[TY],a[TZ]) && reasonablePoint(b[TX],b[TY],b[TZ]) && reasonablePoint(c[TX],c[TY],c[TZ])) {
            raw.fill(ar,ag,ab,a[A]);
            raw.vertex(a[TX],a[TY]);
            raw.fill(br,bg,bb,b[A]);
            raw.vertex(b[TX],b[TY]);
            raw.fill(cr,cg,cb,c[A]);
            raw.vertex(c[TX],c[TY]);
          }
        }
      }
      gl.glEnd();
    }
  }
  if (raw != null) {
    raw.endShape();
  }
  triangleCount=0;
  report("render_triangles out");
}

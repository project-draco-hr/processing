{
  if ((textMode == SHAPE) && (textFontNative == null)) {
    throw new RuntimeException("textMode(SHAPE) is disabled " + "because the font \"" + textFont.name + "\" is not available.");
  }
  if ((textMode != SHAPE) || (textFontNative == null)) {
    super.textCharImpl(ch,x,y);
    return;
  }
  boolean strokeSaved=stroke;
  stroke=false;
  float textPoints[]=new float[6];
  char textArray[]=new char[]{ch};
  Graphics2D graphics=(Graphics2D)canvas.getGraphics();
  FontRenderContext frc=graphics.getFontRenderContext();
  GlyphVector gv=textFontNative.createGlyphVector(frc,textArray);
  Shape shp=gv.getOutline();
  PathIterator iter=shp.getPathIterator(null);
  glu.gluTessBeginPolygon(tobj,null);
  float lastX=0;
  float lastY=0;
  double vertex[];
  final boolean DEBUG_OPCODES=false;
  while (!iter.isDone()) {
    int type=iter.currentSegment(textPoints);
switch (type) {
case PathIterator.SEG_MOVETO:
case PathIterator.SEG_LINETO:
      if (type == PathIterator.SEG_MOVETO) {
        if (DEBUG_OPCODES) {
          System.out.println("moveto\t" + textPoints[0] + "\t"+ textPoints[1]);
        }
        glu.gluTessBeginContour(tobj);
      }
 else {
        if (DEBUG_OPCODES) {
          System.out.println("lineto\t" + textPoints[0] + "\t"+ textPoints[1]);
        }
      }
    vertex=new double[]{x + textPoints[0],y + textPoints[1],0};
  glu.gluTessVertex(tobj,vertex,0,vertex);
lastX=textPoints[0];
lastY=textPoints[1];
break;
case PathIterator.SEG_QUADTO:
if (DEBUG_OPCODES) {
System.out.println("quadto\t" + textPoints[0] + "\t"+ textPoints[1]+ "\t"+ textPoints[2]+ "\t"+ textPoints[3]);
}
for (int i=1; i < bezierDetail; i++) {
float t=(float)i / (float)bezierDetail;
vertex=new double[]{x + bezierPoint(lastX,textPoints[0],textPoints[2],textPoints[2],t),y + bezierPoint(lastY,textPoints[1],textPoints[3],textPoints[3],t),0};
glu.gluTessVertex(tobj,vertex,0,vertex);
}
lastX=textPoints[2];
lastY=textPoints[3];
break;
case PathIterator.SEG_CUBICTO:
if (DEBUG_OPCODES) {
System.out.println("cubicto\t" + textPoints[0] + "\t"+ textPoints[1]+ "\t"+ textPoints[2]+ "\t"+ textPoints[3]+ "\t"+ textPoints[4]+ "\t"+ textPoints[5]);
}
for (int i=1; i < bezierDetail; i++) {
float t=(float)i / (float)bezierDetail;
vertex=new double[]{x + bezierPoint(lastX,textPoints[0],textPoints[2],textPoints[4],t),y + bezierPoint(lastY,textPoints[1],textPoints[3],textPoints[5],t),0};
glu.gluTessVertex(tobj,vertex,0,vertex);
}
lastX=textPoints[4];
lastY=textPoints[5];
break;
case PathIterator.SEG_CLOSE:
if (DEBUG_OPCODES) {
System.out.println("close");
System.out.println();
}
glu.gluTessEndContour(tobj);
break;
}
iter.next();
}
glu.gluTessEndPolygon(tobj);
stroke=strokeSaved;
}

{
  report("render_triangles in");
  int tcount=0;
  gl2f.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl2f.glEnableClientState(GL2.GL_COLOR_ARRAY);
  gl2f.glEnableClientState(GL2.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    PImage[] images=faceTextures[j];
    if (1 < numTextures) {
      for (int t=0; t < numTextures; t++) {
        if (images[t] != null) {
          PTexture tex=getTexture(images[t]);
          if (tex == null) {
            break;
          }
          PApplet.println("has texture");
          gl.glEnable(tex.glTarget);
          gl.glActiveTexture(GL.GL_TEXTURE0 + t);
          gl.glBindTexture(tex.glTarget,tex.glID);
          renderTextures[tcount]=tex;
          tcount++;
        }
 else {
          break;
        }
      }
    }
 else     if (images[0] != null) {
      PTexture tex=getTexture(images[0]);
      if (tex != null) {
        gl.glEnable(tex.glTarget);
        gl.glActiveTexture(GL.GL_TEXTURE0);
        gl.glBindTexture(tex.glTarget,tex.glID);
        renderTextures[0]=tex;
        tcount=1;
      }
    }
    if (0 < tcount) {
      if (numTexBuffers < tcount) {
        addTexBuffers(tcount - numTexBuffers);
      }
      for (int t=0; t < tcount; t++) {
        gl2f.glClientActiveTexture(GL.GL_TEXTURE0 + t);
        gl2f.glEnableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
      }
      if (1 < tcount) {
        setupTextureBlend(renderTextures,tcount);
      }
    }
    if (USE_GEO_BUFFER) {
      if (recordingShape) {
        recTexturesCount=PApplet.max(recTexturesCount,tcount);
        int i0=recordedIndices.size() + geoBuffer.idxCount;
        int i1=i0 + 3 * faceLength[j] - 1;
        int n0=recordedVertices.size() + geoBuffer.vertCount;
        int n1=n0 + faceMaxIndex[j] - faceMinIndex[j];
        String name="shape";
        if (mergeRecShapes) {
          name="shape";
        }
 else {
          name=recShapeName.equals("") ? "shape:" + recordedChildren.size() : recShapeName;
        }
        PShape3D child=(PShape3D)PShape3D.createChild(name,n0,n1,i0,i1,TRIANGLES,0,images);
        recordedChildren.add(child);
      }
      if (GEO_BUFFER_ACCUM_ALL) {
        if (geoBuffer.newTextures(renderTextures,tcount)) {
          if (0 < geoBuffer.vertCount) {
            if (recordingShape) {
              geoBuffer.record();
            }
 else {
              geoBuffer.render();
            }
            GEO_BUFFER_COUNT++;
            geoBuffer.init(TRIANGLES,renderTextures,tcount);
          }
 else {
            geoBuffer.setTextures(renderTextures,tcount);
          }
        }
      }
 else {
        if (geoBuffer.newTextures(renderTextures,tcount)) {
          geoBuffer.init(TRIANGLES,renderTextures,tcount);
        }
      }
      geoBuffer.add(triangles,i,i + faceLength[j] - 1,vertices,faceMinIndex[j],faceMaxIndex[j]);
      if (GEO_BUFFER_ACCUM_ALL) {
        if (0 < GEO_BUFFER_MAXSIZE && GEO_BUFFER_MAXSIZE < geoBuffer.vertCount) {
          if (recordingShape) {
            geoBuffer.record();
          }
 else {
            geoBuffer.render();
          }
          GEO_BUFFER_COUNT++;
          geoBuffer.init(TRIANGLES,renderTextures,tcount);
        }
      }
 else {
        if (recordingShape) {
          geoBuffer.record();
        }
 else {
          geoBuffer.render();
        }
        GEO_BUFFER_COUNT++;
        geoBuffer.init(TRIANGLES);
      }
    }
 else {
      if (recordingShape) {
        recTexturesCount=PApplet.max(recTexturesCount,tcount);
        int n0=recordedVertices.size();
        int n1=n0 + 3 * faceLength[j] - 1;
        String name="shape";
        if (mergeRecShapes) {
          name="shape";
        }
 else {
          name=recShapeName.equals("") ? "shape:" + recordedChildren.size() : recShapeName;
        }
        PShape3D child=(PShape3D)PShape3D.createChild(name,n0,n1,TRIANGLES,0,images);
        recordedChildren.add(child);
      }
      int size=3 * faceLength[j];
      while (vertexBuffer.capacity() / 3 < size) {
        expandBuffers();
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      for (int t=0; t < tcount; t++) {
        texCoordBuffer[t].position(0);
      }
      int n=0;
      for (int k=0; k < faceLength[j]; k++) {
        int na=triangles[i][VERTEX1];
        int nb=triangles[i][VERTEX2];
        int nc=triangles[i][VERTEX3];
        float a[]=vertices[na];
        float b[]=vertices[nb];
        float c[]=vertices[nc];
        if (autoNormal && (a[HAS_NORMAL] == 0 || b[HAS_NORMAL] == 0 || c[HAS_NORMAL] == 0)) {
          float x1=b[X] - a[X];
          float y1=b[Y] - a[Y];
          float z1=b[Z] - a[Z];
          float x2=b[X] - c[X];
          float y2=b[Y] - c[Y];
          float z2=b[Z] - c[Z];
          float cx=y1 * z2 - y2 * z1;
          float cy=z1 * x2 - z2 * x1;
          float cz=x1 * y2 - x2 * y1;
          float norm=PApplet.sqrt(cx * cx + cy * cy + cz * cz);
          cx/=norm;
          cy/=norm;
          cz/=norm;
          a[NX]=b[NX]=c[NX]=cx;
          a[NY]=b[NY]=c[NY]=cy;
          a[NZ]=b[NZ]=c[NZ]=cz;
          a[HAS_NORMAL]=b[HAS_NORMAL]=c[HAS_NORMAL]=1;
        }
        if (tcount == 1) {
          float uscale=1.0f;
          float vscale=1.0f;
          float cx=0.0f;
          float sx=+1.0f;
          float cy=0.0f;
          float sy=+1.0f;
          PTexture tex=renderTextures[0];
          uscale*=tex.getMaxTexCoordU();
          vscale*=tex.getMaxTexCoordV();
          if (tex.isFlippedX()) {
            cx=1.0f;
            sx=-1.0f;
          }
          if (tex.isFlippedY()) {
            cy=1.0f;
            sy=-1.0f;
          }
          renderUa[0]=(cx + sx * a[U]) * uscale;
          renderVa[0]=(cy + sy * a[V]) * vscale;
          renderUb[0]=(cx + sx * b[U]) * uscale;
          renderVb[0]=(cy + sy * b[V]) * vscale;
          renderUc[0]=(cx + sx * c[U]) * uscale;
          renderVc[0]=(cy + sy * c[V]) * vscale;
        }
 else         if (1 < tcount) {
          for (int t=0; t < tcount; t++) {
            float uscale=1.0f;
            float vscale=1.0f;
            float cx=0.0f;
            float sx=+1.0f;
            float cy=0.0f;
            float sy=+1.0f;
            PTexture tex=renderTextures[t];
            uscale*=tex.getMaxTexCoordU();
            vscale*=tex.getMaxTexCoordV();
            if (tex.isFlippedX()) {
              cx=1.0f;
              sx=-1.0f;
            }
            if (tex.isFlippedY()) {
              cy=1.0f;
              sy=-1.0f;
            }
            renderUa[t]=(cx + sx * vertexU[na][t]) * uscale;
            renderVa[t]=(cy + sy * vertexV[na][t]) * vscale;
            renderUb[t]=(cx + sx * vertexU[nb][t]) * uscale;
            renderVb[t]=(cy + sy * vertexV[nb][t]) * vscale;
            renderUc[t]=(cx + sx * vertexU[nc][t]) * uscale;
            renderVc[t]=(cy + sy * vertexV[nc][t]) * vscale;
          }
        }
        if (recordingShape) {
          recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
          recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
          recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
          for (int t=0; t < tcount; t++) {
            recordedTexCoords[t].add(new PVector(vertexU[na][t],vertexV[na][t],0.0f));
          }
          for (int t=tcount; t < maxTextureUnits; t++) {
            recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
          }
        }
 else {
          vertexArray[3 * n + 0]=a[X];
          vertexArray[3 * n + 1]=a[Y];
          vertexArray[3 * n + 2]=a[Z];
          colorArray[4 * n + 0]=a[R];
          colorArray[4 * n + 1]=a[G];
          colorArray[4 * n + 2]=a[B];
          colorArray[4 * n + 3]=a[A];
          normalArray[3 * n + 0]=a[NX];
          normalArray[3 * n + 1]=a[NY];
          normalArray[3 * n + 2]=a[NZ];
          for (int t=0; t < tcount; t++) {
            texCoordArray[t][2 * n + 0]=renderUa[t];
            texCoordArray[t][2 * n + 1]=renderVa[t];
          }
          n++;
        }
        if (recordingShape) {
          recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
          recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
          recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
          for (int t=0; t < tcount; t++) {
            recordedTexCoords[t].add(new PVector(vertexU[nb][t],vertexV[nb][t],0.0f));
          }
          for (int t=tcount; t < maxTextureUnits; t++) {
            recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
          }
        }
 else {
          vertexArray[3 * n + 0]=b[X];
          vertexArray[3 * n + 1]=b[Y];
          vertexArray[3 * n + 2]=b[Z];
          colorArray[4 * n + 0]=b[R];
          colorArray[4 * n + 1]=b[G];
          colorArray[4 * n + 2]=b[B];
          colorArray[4 * n + 3]=b[A];
          normalArray[3 * n + 0]=b[NX];
          normalArray[3 * n + 1]=b[NY];
          normalArray[3 * n + 2]=b[NZ];
          for (int t=0; t < tcount; t++) {
            texCoordArray[t][2 * n + 0]=renderUb[t];
            texCoordArray[t][2 * n + 1]=renderVb[t];
          }
          n++;
        }
        if (recordingShape) {
          recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
          recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
          recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
          for (int t=0; t < tcount; t++) {
            recordedTexCoords[t].add(new PVector(vertexU[nc][t],vertexV[nc][t],0.0f));
          }
          for (int t=tcount; t < maxTextureUnits; t++) {
            recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
          }
        }
 else {
          vertexArray[3 * n + 0]=c[X];
          vertexArray[3 * n + 1]=c[Y];
          vertexArray[3 * n + 2]=c[Z];
          colorArray[4 * n + 0]=c[R];
          colorArray[4 * n + 1]=c[G];
          colorArray[4 * n + 2]=c[B];
          colorArray[4 * n + 3]=c[A];
          normalArray[3 * n + 0]=c[NX];
          normalArray[3 * n + 1]=c[NY];
          normalArray[3 * n + 2]=c[NZ];
          for (int t=0; t < tcount; t++) {
            texCoordArray[t][2 * n + 0]=renderUc[t];
            texCoordArray[t][2 * n + 1]=renderVc[t];
          }
          n++;
        }
        i++;
      }
      if (!recordingShape) {
        vertexBuffer.put(vertexArray);
        colorBuffer.put(colorArray);
        normalBuffer.put(normalArray);
        for (int t=0; t < tcount; t++) {
          texCoordBuffer[t].put(texCoordArray[t]);
        }
        vertexBuffer.position(0);
        colorBuffer.position(0);
        normalBuffer.position(0);
        for (int t=0; t < tcount; t++) {
          texCoordBuffer[t].position(0);
        }
        gl2f.glVertexPointer(3,GL.GL_FLOAT,0,vertexBuffer);
        gl2f.glColorPointer(4,GL.GL_FLOAT,0,colorBuffer);
        gl2f.glNormalPointer(GL.GL_FLOAT,0,normalBuffer);
        for (int t=0; t < tcount; t++) {
          gl2f.glClientActiveTexture(GL.GL_TEXTURE0 + t);
          gl2f.glTexCoordPointer(2,GL.GL_FLOAT,0,texCoordBuffer[t]);
        }
        gl2f.glDrawArrays(GL.GL_TRIANGLES,0,3 * faceLength[j]);
      }
    }
    if (0 < tcount) {
      if (1 < tcount) {
        cleanupTextureBlend(tcount);
      }
      for (int t=0; t < tcount; t++) {
        PTexture tex=renderTextures[t];
        gl.glActiveTexture(GL.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.glTarget,0);
      }
      for (int t=0; t < tcount; t++) {
        PTexture tex=renderTextures[t];
        gl.glDisable(tex.glTarget);
      }
      for (int t=0; t < tcount; t++) {
        gl2f.glClientActiveTexture(GL.GL_TEXTURE0 + t);
        gl2f.glDisableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
      }
    }
  }
  gl2f.glDisableClientState(GL2.GL_NORMAL_ARRAY);
  gl2f.glDisableClientState(GL2.GL_COLOR_ARRAY);
  gl2f.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  report("render_triangles out");
}

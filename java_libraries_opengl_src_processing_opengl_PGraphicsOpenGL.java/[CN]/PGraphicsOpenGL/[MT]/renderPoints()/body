{
  if (!pointVBOsCreated) {
    createPointBuffers();
    pointVBOsCreated=true;
  }
  startPointShader();
  gl2f.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl2f.glEnableClientState(GL2.GL_COLOR_ARRAY);
  gl2f.glEnableClientState(GL2.GL_NORMAL_ARRAY);
  int size=tessGeo.pointVertexCount;
  gl2f.glBindBuffer(GL.GL_ARRAY_BUFFER,glPointVertexBufferID);
  gl2f.glBufferData(GL.GL_ARRAY_BUFFER,3 * size * PGraphicsOpenGL.SIZEOF_FLOAT,FloatBuffer.wrap(tessGeo.pointVertices,0,3 * size),vboMode);
  gl2f.glVertexPointer(3,GL.GL_FLOAT,0,0);
  gl2f.glBindBuffer(GL.GL_ARRAY_BUFFER,glPointColorBufferID);
  gl2f.glBufferData(GL.GL_ARRAY_BUFFER,4 * size * PGraphicsOpenGL.SIZEOF_FLOAT,FloatBuffer.wrap(tessGeo.pointColors,0,4 * size),vboMode);
  gl2f.glColorPointer(4,GL.GL_FLOAT,0,0);
  gl2f.glBindBuffer(GL.GL_ARRAY_BUFFER,glPointNormalBufferID);
  gl2f.glBufferData(GL.GL_ARRAY_BUFFER,3 * size * PGraphicsOpenGL.SIZEOF_FLOAT,FloatBuffer.wrap(tessGeo.pointNormals,0,3 * size),vboMode);
  gl2f.glNormalPointer(GL.GL_FLOAT,0,0);
  setupPointShader(glPointAttribBufferID,tessGeo.pointAttributes,size);
  size=tessGeo.pointIndexCount;
  gl2f.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER,glPointIndexBufferID);
  gl2f.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER,size * PGraphicsOpenGL.SIZEOF_INT,IntBuffer.wrap(tessGeo.pointIndices,0,size),vboMode);
  gl2f.glDrawElements(GL.GL_TRIANGLES,size,GL.GL_UNSIGNED_INT,0);
  gl2f.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER,0);
  gl2f.glBindBuffer(GL.GL_ARRAY_BUFFER,0);
  gl2f.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  gl2f.glDisableClientState(GL2.GL_COLOR_ARRAY);
  gl2f.glDisableClientState(GL2.GL_NORMAL_ARRAY);
  stopPointShader();
}

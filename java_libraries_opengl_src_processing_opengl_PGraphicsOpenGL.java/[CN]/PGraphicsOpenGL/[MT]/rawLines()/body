{
  raw.colorMode(RGB);
  raw.noFill();
  raw.strokeCap(strokeCap);
  raw.strokeJoin(strokeJoin);
  raw.beginShape(LINES);
  float[] vertices=tessGeo.lineVertices;
  int[] color=tessGeo.lineColors;
  float[] attribs=tessGeo.lineAttribs;
  short[] indices=tessGeo.lineIndices;
  IndexCache cache=tessGeo.lineIndexCache;
  for (int n=0; n < cache.size; n++) {
    int ioffset=cache.indexOffset[n];
    int icount=cache.indexCount[n];
    int voffset=cache.vertexOffset[n];
    for (int ln=ioffset / 6; ln < (ioffset + icount) / 6; ln++) {
      int i0=voffset + indices[6 * ln + 0];
      int i1=voffset + indices[6 * ln + 5];
      float[] pt0={0,0,0,0};
      float[] pt1={0,0,0,0};
      int argb0=PGL.nativeToJavaARGB(color[i0]);
      int argb1=PGL.nativeToJavaARGB(color[i1]);
      float sw0=2 * attribs[4 * i0 + 3];
      float sw1=2 * attribs[4 * i1 + 3];
      if (flushMode == FLUSH_CONTINUOUSLY || hints[DISABLE_TRANSFORM_CACHE]) {
        float[] src0={0,0,0,0};
        float[] src1={0,0,0,0};
        PApplet.arrayCopy(vertices,4 * i0,src0,0,4);
        PApplet.arrayCopy(vertices,4 * i1,src1,0,4);
        modelview.mult(src0,pt0);
        modelview.mult(src1,pt1);
      }
 else {
        PApplet.arrayCopy(vertices,4 * i0,pt0,0,4);
        PApplet.arrayCopy(vertices,4 * i1,pt1,0,4);
      }
      if (raw.is3D()) {
        raw.strokeWeight(sw0);
        raw.stroke(argb0);
        raw.vertex(pt0[X],pt0[Y],pt0[Z]);
        raw.strokeWeight(sw1);
        raw.stroke(argb1);
        raw.vertex(pt1[X],pt1[Y],pt1[Z]);
      }
 else       if (raw.is2D()) {
        float sx0=screenX(pt0[0],pt0[1],pt0[2],pt0[3]), sy0=screenY(pt0[0],pt0[1],pt0[2],pt0[3]);
        float sx1=screenX(pt1[0],pt1[1],pt1[2],pt1[3]), sy1=screenY(pt1[0],pt1[1],pt1[2],pt1[3]);
        raw.strokeWeight(sw0);
        raw.stroke(argb0);
        raw.vertex(sx0,sy0);
        raw.strokeWeight(sw1);
        raw.stroke(argb1);
        raw.vertex(sx1,sy1);
      }
    }
  }
  raw.endShape();
}

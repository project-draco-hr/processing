{
  tessellator.setInGeometry(in);
  tessellator.setTessGeometry(tess);
  tessellator.setFill(fill || textureImage != null);
  tessellator.setStroke(stroke);
  tessellator.setStrokeWeight(strokeWeight);
  tessellator.setStrokeCap(strokeCap);
  tessellator.setStrokeJoin(strokeJoin);
  tessellator.setStrokeColor(strokeR,strokeG,strokeB,strokeA);
  if (drawing2D) {
    tessellator.set2D();
  }
 else {
    tessellator.set3D();
  }
  int first=tess.fillIndexCount;
  if (shape == POINTS) {
    tessellator.tessellatePoints();
  }
 else   if (shape == LINES) {
    tessellator.tessellateLines();
  }
 else   if (shape == TRIANGLE || shape == TRIANGLES) {
    if (stroke && defaultEdges)     in.addTrianglesEdges();
    tessellator.tessellateTriangles();
  }
 else   if (shape == TRIANGLE_FAN) {
    if (stroke && defaultEdges)     in.addTriangleFanEdges();
    tessellator.tessellateTriangleFan();
  }
 else   if (shape == TRIANGLE_STRIP) {
    if (stroke && defaultEdges)     in.addTriangleStripEdges();
    tessellator.tessellateTriangleStrip();
  }
 else   if (shape == QUAD || shape == QUADS) {
    if (stroke && defaultEdges)     in.addQuadsEdges();
    tessellator.tessellateQuads();
  }
 else   if (shape == QUAD_STRIP) {
    if (stroke && defaultEdges)     in.addQuadStripEdges();
    tessellator.tessellateQuadStrip();
  }
 else   if (shape == POLYGON) {
    if (stroke && defaultEdges)     in.addPolygonEdges(mode == CLOSE);
    tessellator.tessellatePolygon(false,mode == CLOSE);
  }
  int last=tess.lastFillIndex;
  if (textureImage0 != textureImage || texState.count == 0) {
    texState.addTexture(textureImage,first,last);
  }
 else {
    texState.setLastIndex(last);
  }
}

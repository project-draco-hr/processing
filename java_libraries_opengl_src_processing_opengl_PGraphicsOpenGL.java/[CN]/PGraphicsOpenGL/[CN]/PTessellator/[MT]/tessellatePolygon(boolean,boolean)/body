{
  GLU.gluTessBeginPolygon(gluTess,null);
  if (solid) {
    GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_NONZERO);
  }
 else {
    GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_ODD);
  }
  GLU.gluTessBeginContour(gluTess);
  for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
    boolean breakPt=inGeo.codes[i] == PShape.BREAK;
    if (breakPt) {
      GLU.gluTessEndContour(gluTess);
      GLU.gluTessBeginContour(gluTess);
    }
    double[] vertex=new double[]{inGeo.vertices[3 * i + 0],inGeo.vertices[3 * i + 1],inGeo.vertices[3 * i + 2],inGeo.colors[4 * i + 0],inGeo.colors[4 * i + 1],inGeo.colors[4 * i + 2],inGeo.colors[4 * i + 3],inGeo.normals[3 * i + 0],inGeo.normals[3 * i + 1],inGeo.normals[3 * i + 2],inGeo.texcoords[2 * i + 0],inGeo.texcoords[2 * i + 1]};
    GLU.gluTessVertex(gluTess,vertex,0,vertex);
  }
  GLU.gluTessEndContour(gluTess);
  GLU.gluTessEndPolygon(gluTess);
  int vert0=inGeo.firstVertex;
  int lineCount=0;
  int lnCount=inGeo.lastVertex - inGeo.firstVertex + 1;
  if (!closed) {
    lnCount--;
  }
  int contour0=0;
  for (int ln=0; ln < lnCount; ln++) {
    int i0=vert0 + ln;
    int i1=vert0 + ln + 1;
    if (inGeo.codes[i0] == PShape.BREAK) {
      contour0=i0;
    }
    if ((i1 == lnCount || inGeo.codes[i1] == PShape.BREAK) && closed) {
      i0=contour0;
      i1=vert0 + ln;
    }
    if (inGeo.codes[i1] != PShape.BREAK && (0 < inGeo.strokes[5 * i0 + 4] || 0 < inGeo.strokes[5 * i1 + 4])) {
      lineCount++;
    }
  }
  if (0 < lineCount) {
    int nvertLine=lineCount * 4;
    tessGeo.addLineVertices(nvertLine);
    int nind=lineCount * 2 * 3;
    tessGeo.addLineIndices(nind);
    int vcount=tessGeo.firstLineVertex;
    int icount=tessGeo.firstLineIndex;
    contour0=0;
    for (int ln=0; ln < lnCount; ln++) {
      int i0=vert0 + ln;
      int i1=vert0 + ln + 1;
      if (inGeo.codes[i0] == PShape.BREAK) {
        contour0=i0;
      }
      if ((i1 == lnCount || inGeo.codes[i1] == PShape.BREAK) && closed) {
        i0=contour0;
        i1=vert0 + ln;
      }
      if (inGeo.codes[i1] != PShape.BREAK && (0 < inGeo.strokes[5 * i0 + 4] || 0 < inGeo.strokes[5 * i1 + 4])) {
        addStrokeLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
  }
}

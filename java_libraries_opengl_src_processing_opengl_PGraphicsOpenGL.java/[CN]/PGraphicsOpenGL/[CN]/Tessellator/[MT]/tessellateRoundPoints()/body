{
  int nInVert=inGeo.lastVertex - inGeo.firstVertex + 1;
  if (stroke && 1 <= nInVert) {
    tessGeo.isStroked=true;
    int nvertTot=0;
    int nindTot=0;
    for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
      int perim=PApplet.max(MIN_ACCURACY,(int)(TWO_PI * strokeWeight / 20));
      int nvert=perim + 1;
      nvertTot+=nvert;
      nindTot+=3 * (nvert - 1);
    }
    tessGeo.addPointVertices(nvertTot);
    tessGeo.addPointIndices(nindTot);
    int vertIdx=3 * tessGeo.firstPointVertex;
    int attribIdx=2 * tessGeo.firstPointVertex;
    int indIdx=tessGeo.firstPointIndex;
    int firstVert=tessGeo.firstPointVertex;
    for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
      int perim=PApplet.max(MIN_ACCURACY,(int)(TWO_PI * strokeWeight / 20));
      int nvert=perim + 1;
      for (int k=0; k < nvert; k++) {
        tessGeo.putPointVertex(inGeo,i,vertIdx);
        vertIdx++;
      }
      tessGeo.pointAttributes[2 * attribIdx + 0]=0;
      tessGeo.pointAttributes[2 * attribIdx + 1]=0;
      attribIdx++;
      float val=0;
      float inc=(float)SINCOS_LENGTH / perim;
      for (int k=0; k < perim; k++) {
        tessGeo.pointAttributes[2 * attribIdx + 0]=0.5f * cosLUT[(int)val] * strokeWeight;
        tessGeo.pointAttributes[2 * attribIdx + 1]=0.5f * sinLUT[(int)val] * strokeWeight;
        val=(val + inc) % SINCOS_LENGTH;
        attribIdx++;
      }
      for (int k=1; k < nvert - 1; k++) {
        tessGeo.pointIndices[indIdx++]=firstVert + 0;
        tessGeo.pointIndices[indIdx++]=firstVert + k;
        tessGeo.pointIndices[indIdx++]=firstVert + k + 1;
      }
      tessGeo.pointIndices[indIdx++]=firstVert + 0;
      tessGeo.pointIndices[indIdx++]=firstVert + 1;
      tessGeo.pointIndices[indIdx++]=firstVert + nvert - 1;
      firstVert=vertIdx;
    }
  }
}

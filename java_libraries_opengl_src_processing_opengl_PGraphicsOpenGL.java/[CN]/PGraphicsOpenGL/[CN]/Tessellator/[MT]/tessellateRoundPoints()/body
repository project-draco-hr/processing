{
  int nvertTot=0;
  int nindTot=0;
  for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
    float w=inGeo.strokes[5 * i + 4];
    int perim=PApplet.max(MIN_ACCURACY,(int)(TWO_PI * w / 20));
    int nvert=perim + 1;
    nvertTot+=nvert;
    nindTot+=3 * (nvert - 1);
  }
  tessGeo.addPointVertices(nvertTot);
  tessGeo.addPointIndices(nindTot);
  int vertIdx=3 * tessGeo.firstPointVertex;
  int attribIdx=2 * tessGeo.firstPointVertex;
  int indIdx=tessGeo.firstPointIndex;
  int firstVert=tessGeo.firstPointVertex;
  for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
    float w=inGeo.strokes[5 * i + 4];
    int perim=PApplet.max(MIN_ACCURACY,(int)(TWO_PI * w / 20));
    int nvert=perim + 1;
    for (int k=0; k < nvert; k++) {
      tessGeo.putPointVertex(inGeo,i,vertIdx);
      vertIdx++;
    }
    tessGeo.pointAttributes[2 * attribIdx + 0]=0;
    tessGeo.pointAttributes[2 * attribIdx + 1]=0;
    attribIdx++;
    float val=0;
    float inc=(float)SINCOS_LENGTH / perim;
    for (int k=0; k < perim; k++) {
      tessGeo.pointAttributes[2 * attribIdx + 0]=cosLUT[(int)val] * w / 2;
      tessGeo.pointAttributes[2 * attribIdx + 1]=sinLUT[(int)val] * w / 2;
      val=(val + inc) % SINCOS_LENGTH;
      attribIdx++;
    }
    for (int k=1; k < nvert - 1; k++) {
      tessGeo.pointIndices[indIdx++]=firstVert + 0;
      tessGeo.pointIndices[indIdx++]=firstVert + k;
      tessGeo.pointIndices[indIdx++]=firstVert + k + 1;
    }
    tessGeo.pointIndices[indIdx++]=firstVert + 0;
    tessGeo.pointIndices[indIdx++]=firstVert + 1;
    tessGeo.pointIndices[indIdx++]=firstVert + nvert - 1;
    firstVert=vertIdx;
  }
}

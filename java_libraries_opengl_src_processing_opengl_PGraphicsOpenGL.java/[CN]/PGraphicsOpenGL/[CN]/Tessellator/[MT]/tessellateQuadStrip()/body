{
  int nvertFill=inGeo.lastVertex - inGeo.firstVertex + 1;
  if (fill) {
    tessGeo.addFillVertices(inGeo);
    int quadCount=nvertFill / 2 - 1;
    tessGeo.addFillIndices(6 * quadCount);
    int idx=tessGeo.firstFillIndex;
    int offset=tessGeo.firstFillVertex;
    for (int qd=1; qd < nvertFill / 2; qd++) {
      int i0=offset + 2 * (qd - 1);
      int i1=offset + 2 * (qd - 1) + 1;
      int i2=offset + 2 * qd + 1;
      int i3=offset + 2 * qd;
      tessGeo.fillIndices[idx++]=i0;
      tessGeo.fillIndices[idx++]=i1;
      tessGeo.fillIndices[idx++]=i3;
      tessGeo.fillIndices[idx++]=i1;
      tessGeo.fillIndices[idx++]=i2;
      tessGeo.fillIndices[idx++]=i3;
    }
  }
  if (stroke) {
    tessGeo.isStroked=true;
    if (is3D) {
      int strokeCount=nvertFill / 2 - 1;
      int first=inGeo.firstVertex;
      int nvertLine=strokeCount * 4 * 4;
      tessGeo.addLineVertices(nvertLine);
      int nind=strokeCount * 4 * 2* 3;
      tessGeo.addLineIndices(nind);
      int vcount=tessGeo.firstLineVertex;
      int icount=tessGeo.firstLineIndex;
      for (int qd=1; qd < nvertFill / 2; qd++) {
        int i0=first + 2 * (qd - 1);
        int i1=first + 2 * (qd - 1) + 1;
        int i2=first + 2 * qd + 1;
        int i3=first + 2 * qd;
        addLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
        addLine(i1,i2,vcount,icount);
        vcount+=4;
        icount+=6;
        addLine(i2,i3,vcount,icount);
        vcount+=4;
        icount+=6;
        addLine(i3,i0,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
 else {
      GeneralPath path=new GeneralPath(GeneralPath.WIND_NON_ZERO);
      int first=inGeo.firstVertex;
      for (int qd=1; qd < nvertFill / 2; qd++) {
        int i0=first + 2 * (qd - 1);
        int i1=first + 2 * (qd - 1) + 1;
        int i2=first + 2 * qd + 1;
        int i3=first + 2 * qd;
        path.moveTo(inGeo.vertices[3 * i0 + 0],inGeo.vertices[3 * i0 + 1]);
        path.lineTo(inGeo.vertices[3 * i1 + 0],inGeo.vertices[3 * i1 + 1]);
        path.lineTo(inGeo.vertices[3 * i2 + 0],inGeo.vertices[3 * i2 + 1]);
        path.lineTo(inGeo.vertices[3 * i3 + 0],inGeo.vertices[3 * i3 + 1]);
        path.closePath();
      }
      tessGeo.firstLineIndex=tessGeo.fillIndexCount;
      tessellatePath(path);
      tessGeo.lastLineIndex=tessGeo.fillIndexCount - 1;
    }
  }
}

{
  int nInVert=inGeo.lastVertex - inGeo.firstVertex + 1;
  if (fill && 3 <= nInVert) {
    GLU.gluTessBeginPolygon(gluTess,null);
    if (solid) {
      GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_NONZERO);
    }
 else {
      GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_ODD);
    }
    GLU.gluTessBeginContour(gluTess);
    for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
      boolean breakPt=inGeo.codes[i] == PShape.BREAK;
      if (breakPt) {
        GLU.gluTessEndContour(gluTess);
        GLU.gluTessBeginContour(gluTess);
      }
      double[] vertex=new double[]{inGeo.vertices[3 * i + 0],inGeo.vertices[3 * i + 1],inGeo.vertices[3 * i + 2],inGeo.colors[4 * i + 0],inGeo.colors[4 * i + 1],inGeo.colors[4 * i + 2],inGeo.colors[4 * i + 3],inGeo.normals[3 * i + 0],inGeo.normals[3 * i + 1],inGeo.normals[3 * i + 2],inGeo.texcoords[2 * i + 0],inGeo.texcoords[2 * i + 1]};
      GLU.gluTessVertex(gluTess,vertex,0,vertex);
    }
    GLU.gluTessEndContour(gluTess);
    GLU.gluTessEndPolygon(gluTess);
  }
  if (stroke) {
    tessGeo.isStroked=true;
    tessellateEdges();
  }
}

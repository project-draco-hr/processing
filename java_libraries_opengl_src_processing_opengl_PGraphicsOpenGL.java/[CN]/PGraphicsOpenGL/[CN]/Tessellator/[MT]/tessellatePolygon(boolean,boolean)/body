{
  if (fill) {
    GLU.gluTessBeginPolygon(gluTess,null);
    if (solid) {
      GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_NONZERO);
    }
 else {
      GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_ODD);
    }
    GLU.gluTessBeginContour(gluTess);
    for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
      boolean breakPt=inGeo.codes[i] == PShape.BREAK;
      if (breakPt) {
        GLU.gluTessEndContour(gluTess);
        GLU.gluTessBeginContour(gluTess);
      }
      double[] vertex=new double[]{inGeo.vertices[3 * i + 0],inGeo.vertices[3 * i + 1],inGeo.vertices[3 * i + 2],inGeo.colors[4 * i + 0],inGeo.colors[4 * i + 1],inGeo.colors[4 * i + 2],inGeo.colors[4 * i + 3],inGeo.normals[3 * i + 0],inGeo.normals[3 * i + 1],inGeo.normals[3 * i + 2],inGeo.texcoords[2 * i + 0],inGeo.texcoords[2 * i + 1]};
      GLU.gluTessVertex(gluTess,vertex,0,vertex);
    }
    GLU.gluTessEndContour(gluTess);
    GLU.gluTessEndPolygon(gluTess);
  }
  if (stroke) {
    tessGeo.isStroked=true;
    if (is3D) {
      int lineCount=0;
      int lnCount=inGeo.lastVertex - inGeo.firstVertex + 1;
      int first=inGeo.firstVertex;
      if (!closed) {
        lnCount--;
      }
      int contour0=first;
      for (int ln=0; ln < lnCount; ln++) {
        int i=first + ln + 1;
        if ((i == lnCount || inGeo.codes[i] == PShape.BREAK) && closed) {
          i=first + ln;
        }
        if (inGeo.codes[i] != PShape.BREAK) {
          lineCount++;
        }
      }
      if (0 < lineCount) {
        int nvertLine=lineCount * 4;
        tessGeo.addLineVertices(nvertLine);
        int nind=lineCount * 2 * 3;
        tessGeo.addLineIndices(nind);
        int vcount=tessGeo.firstLineVertex;
        int icount=tessGeo.firstLineIndex;
        contour0=first;
        for (int ln=0; ln < lnCount; ln++) {
          int i0=first + ln;
          int i1=first + ln + 1;
          if (inGeo.codes[i0] == PShape.BREAK) {
            contour0=i0;
          }
          if ((i1 == lnCount || inGeo.codes[i1] == PShape.BREAK) && closed) {
            i0=contour0;
            i1=first + ln;
          }
          if (inGeo.codes[i1] != PShape.BREAK) {
            addLine(i0,i1,vcount,icount);
            vcount+=4;
            icount+=6;
          }
        }
      }
    }
 else {
      GeneralPath path=new GeneralPath(GeneralPath.WIND_NON_ZERO);
      int lnCount=inGeo.lastVertex - inGeo.firstVertex + 1;
      int first=inGeo.firstVertex;
      if (!closed) {
        lnCount--;
      }
      int contour0=first;
      path.moveTo(inGeo.vertices[3 * first + 0],inGeo.vertices[3 * first + 1]);
      for (int ln=0; ln < lnCount; ln++) {
        int i0=first + ln;
        int i1=first + ln + 1;
        if (inGeo.codes[i0] == PShape.BREAK) {
          contour0=i0;
          path.moveTo(inGeo.vertices[3 * i0 + 0],inGeo.vertices[3 * i0 + 1]);
        }
        boolean close=false;
        if ((i1 == lnCount || inGeo.codes[i1] == PShape.BREAK) && closed) {
          i0=contour0;
          path.moveTo(inGeo.vertices[3 * i0 + 0],inGeo.vertices[3 * i0 + 1]);
          i1=first + ln;
          close=true;
        }
        if (inGeo.codes[i1] != PShape.BREAK) {
          path.lineTo(inGeo.vertices[3 * i1 + 0],inGeo.vertices[3 * i1 + 1]);
        }
 else {
          path.moveTo(inGeo.vertices[3 * i1 + 0],inGeo.vertices[3 * i1 + 1]);
        }
        if (close) {
          path.closePath();
        }
      }
      tessGeo.firstLineIndex=tessGeo.fillIndexCount;
      tessellatePath(path);
      tessGeo.lastLineIndex=tessGeo.fillIndexCount - 1;
    }
  }
}

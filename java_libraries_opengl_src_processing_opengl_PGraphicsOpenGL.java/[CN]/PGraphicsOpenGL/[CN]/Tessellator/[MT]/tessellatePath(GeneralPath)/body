{
  BasicStroke bs;
  int bstrokeCap=strokeCap == ROUND ? BasicStroke.CAP_ROUND : strokeCap == PROJECT ? BasicStroke.CAP_SQUARE : BasicStroke.CAP_BUTT;
  int bstrokeJoin=strokeJoin == ROUND ? BasicStroke.JOIN_ROUND : strokeJoin == BEVEL ? BasicStroke.JOIN_BEVEL : BasicStroke.JOIN_MITER;
  bs=new BasicStroke(strokeWeight,bstrokeCap,bstrokeJoin);
  Shape sh=bs.createStrokedShape(path);
  gluTess.beginPolygon();
  float lastX=0;
  float lastY=0;
  double[] vertex;
  float[] coords=new float[6];
  PathIterator iter=sh.getPathIterator(null);
  int rule=iter.getWindingRule();
switch (rule) {
case PathIterator.WIND_EVEN_ODD:
    gluTess.setWindingRule(PGL.GLU_TESS_WINDING_ODD);
  break;
case PathIterator.WIND_NON_ZERO:
gluTess.setWindingRule(PGL.GLU_TESS_WINDING_NONZERO);
break;
}
while (!iter.isDone()) {
float strokeRed=0;
float strokeGreen=0;
float strokeBlue=0;
float strokeAlpha=0;
switch (iter.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
gluTess.beginContour();
case PathIterator.SEG_LINETO:
vertex=new double[]{coords[0],coords[1],0,strokeRed,strokeGreen,strokeBlue,strokeAlpha,0,0,1,0,0};
gluTess.addVertex(vertex);
lastX=coords[0];
lastY=coords[1];
break;
case PathIterator.SEG_QUADTO:
for (int i=1; i < bezierDetail; i++) {
float t=(float)i / (float)bezierDetail;
vertex=new double[]{bezierPoint(lastX,coords[0],coords[2],coords[2],t),bezierPoint(lastY,coords[1],coords[3],coords[3],t),0,strokeRed,strokeGreen,strokeBlue,strokeAlpha,0,0,1,0,0};
gluTess.addVertex(vertex);
}
lastX=coords[2];
lastY=coords[3];
break;
case PathIterator.SEG_CUBICTO:
for (int i=1; i < bezierDetail; i++) {
float t=(float)i / (float)bezierDetail;
vertex=new double[]{bezierPoint(lastX,coords[0],coords[2],coords[4],t),bezierPoint(lastY,coords[1],coords[3],coords[5],t),0,strokeRed,strokeGreen,strokeBlue,strokeAlpha,0,0,1,0,0};
gluTess.addVertex(vertex);
}
lastX=coords[4];
lastY=coords[5];
break;
case PathIterator.SEG_CLOSE:
gluTess.endContour();
break;
}
iter.next();
}
gluTess.endPolygon();
}

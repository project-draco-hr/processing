{
  int nInVert=in.lastVertex - in.firstVertex + 1;
  if (stroke && 2 <= nInVert) {
    int lineCount=nInVert / 2;
    int first=in.firstVertex;
    int nvert=lineCount * 4;
    int nind=lineCount * 2 * 3;
    if (is3D()) {
      tess.lineVertexCheck(nvert);
      tess.lineIndexCheck(nind);
      int index=in.renderMode == RETAINED ? tess.lineIndexCache.addNew() : tess.lineIndexCache.getLast();
      firstLineIndexCache=index;
      for (int ln=0; ln < lineCount; ln++) {
        int i0=first + 2 * ln + 0;
        int i1=first + 2 * ln + 1;
        index=addLine(i0,i1,index,false);
      }
      lastLineIndexCache=index;
    }
 else {
      prevTexImage=newTexImage;
      newTexImage=null;
      setFirstTexIndex(tess.fillIndexCount,tess.fillIndexCache.size - 1);
      if (strokeWeight < PGL.MIN_CAPS_JOINS_WEIGHT) {
        tess.fillVertexCheck(nvert);
        tess.fillIndexCheck(nind);
        int index=in.renderMode == RETAINED ? tess.fillIndexCache.addNew() : tess.fillIndexCache.getLast();
        firstFillIndexCache=index;
        for (int ln=0; ln < lineCount; ln++) {
          int i0=first + 2 * ln + 0;
          int i1=first + 2 * ln + 1;
          index=addLine2D(i0,i1,index,false);
        }
        lastFillIndexCache=index;
      }
 else {
        LinePath path=new LinePath(LinePath.WIND_NON_ZERO);
        for (int ln=0; ln < lineCount; ln++) {
          int i0=first + 2 * ln + 0;
          int i1=first + 2 * ln + 1;
          path.moveTo(in.vertices[4 * i0 + 0],in.vertices[4 * i0 + 1]);
          path.lineTo(in.vertices[4 * i1 + 0],in.vertices[4 * i1 + 1]);
          if (tess.renderMode == RETAINED) {
            in.tessMap.addFillIndex(i0,-1);
            in.tessMap.addFillIndex(i1,-1);
          }
        }
        tessellateLinePath(path,false);
      }
    }
    setLastTexIndex(tess.lastFillIndex,tess.fillIndexCache.size - 1);
  }
}

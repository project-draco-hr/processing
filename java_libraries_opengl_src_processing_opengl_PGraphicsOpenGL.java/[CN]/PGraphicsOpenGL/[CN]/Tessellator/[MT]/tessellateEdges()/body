{
  if (stroke) {
    int nInVert=in.getNumLineVertices();
    int nInInd=in.getNumLineIndices();
    if (is3D()) {
      tess.lineVertexCheck(nInVert);
      tess.lineIndexCheck(nInInd);
      int index=in.renderMode == RETAINED ? tess.lineIndexCache.addNew() : tess.lineIndexCache.getLast();
      firstLineIndexCache=index;
      for (int i=in.firstEdge; i <= in.lastEdge; i++) {
        int[] edge=in.edges[i];
        index=addLine(edge[0],edge[1],index,true);
      }
      lastLineIndexCache=index;
    }
 else {
      if (strokeWeight < PGL.MIN_CAPS_JOINS_WEIGHT) {
        tess.fillVertexCheck(nInVert);
        tess.fillIndexCheck(nInInd);
        int index=in.renderMode == RETAINED ? tess.fillIndexCache.addNew() : tess.fillIndexCache.getLast();
        firstFillIndexCache=index;
        for (int i=in.firstEdge; i <= in.lastEdge; i++) {
          int[] edge=in.edges[i];
          index=addLine2D(edge[0],edge[1],index,true);
        }
        lastFillIndexCache=index;
      }
 else {
        LinePath path=new LinePath(LinePath.WIND_NON_ZERO);
        for (int i=in.firstEdge; i <= in.lastEdge; i++) {
          int[] edge=in.edges[i];
          int i0=edge[0];
          int i1=edge[1];
switch (edge[2]) {
case EDGE_MIDDLE:
            path.lineTo(in.vertices[4 * i1 + 0],in.vertices[4 * i1 + 1]);
          break;
case EDGE_START:
        path.moveTo(in.vertices[4 * i0 + 0],in.vertices[4 * i0 + 1]);
      path.lineTo(in.vertices[4 * i1 + 0],in.vertices[4 * i1 + 1]);
    break;
case EDGE_STOP:
  path.lineTo(in.vertices[4 * i1 + 0],in.vertices[4 * i1 + 1]);
path.closePath();
break;
case EDGE_SINGLE:
path.moveTo(in.vertices[4 * i0 + 0],in.vertices[4 * i0 + 1]);
path.lineTo(in.vertices[4 * i1 + 0],in.vertices[4 * i1 + 1]);
path.closePath();
break;
}
}
tessellateLinePath(path);
}
}
}
}

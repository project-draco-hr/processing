{
  IndexCache cache=tess.polyIndexCache;
  int count=cache.vertexCount[index];
  if (PGL.MAX_VERTEX_INDEX1 <= count + 4) {
    index=cache.addNew();
    count=0;
  }
  int iidx=cache.indexOffset[index] + cache.indexCount[index];
  int vidx=cache.vertexOffset[index] + cache.vertexCount[index];
  int color;
  float weight;
  color=constStroke ? strokeColor : in.strokeColors[i0];
  weight=constStroke ? strokeWeight : in.strokeWeights[i0];
  float x0=in.vertices[3 * i0 + 0];
  float y0=in.vertices[3 * i0 + 1];
  float x1=in.vertices[3 * i1 + 0];
  float y1=in.vertices[3 * i1 + 1];
  float dirx=x1 - x0;
  float diry=y1 - y0;
  float llen=PApplet.sqrt(dirx * dirx + diry * diry);
  float normx=-diry / llen;
  float normy=+dirx / llen;
  tess.setPolyVertex(vidx,x0 + normx * weight / 2,y0 + normy * weight / 2,0,color);
  tess.polyIndices[iidx++]=(short)(count + 0);
  vidx++;
  tess.setPolyVertex(vidx,x0 - normx * weight / 2,y0 - normy * weight / 2,0,color);
  tess.polyIndices[iidx++]=(short)(count + 1);
  color=constStroke ? strokeColor : in.strokeColors[i1];
  weight=constStroke ? strokeWeight : in.strokeWeights[i1];
  vidx++;
  tess.setPolyVertex(vidx,x1 - normx * weight / 2,y1 - normy * weight / 2,0,color);
  tess.polyIndices[iidx++]=(short)(count + 2);
  tess.polyIndices[iidx++]=(short)(count + 2);
  tess.polyIndices[iidx++]=(short)(count + 0);
  vidx++;
  tess.setPolyVertex(vidx,x1 + normx * weight / 2,y1 + normy * weight / 2,0,color);
  tess.polyIndices[iidx++]=(short)(count + 3);
  cache.incCounts(index,6,4);
  return index;
}

{
  int nInVert=in.lastVertex - in.firstVertex + 1;
  if (stroke && 2 <= nInVert) {
    int lineCount=nInVert;
    int nvert=lineCount * 4;
    int nind=lineCount * 2 * 3;
    if (is3D()) {
      tess.lineVertexCheck(nvert);
      tess.lineIndexCheck(nind);
      int index=in.renderMode == RETAINED ? tess.lineIndexCache.addNew() : tess.lineIndexCache.getLast();
      firstLineIndexCache=index;
      int i0=in.firstVertex;
      for (int ln=0; ln < lineCount - 1; ln++) {
        int i1=in.firstVertex + ln + 1;
        index=addLine(i0,i1,index,false);
        i0=i1;
      }
      index=addLine(in.lastVertex,in.firstVertex,index,false);
      lastLineIndexCache=index;
    }
 else     if (is2D()) {
      prevTexImage=newTexImage;
      newTexImage=null;
      setFirstTexIndex(tess.polyIndexCount,tess.polyIndexCache.size - 1);
      if (strokeWeight < PGL.MIN_CAPS_JOINS_WEIGHT) {
        tess.polyVertexCheck(nvert);
        tess.polyIndexCheck(nind);
        int index=in.renderMode == RETAINED ? tess.polyIndexCache.addNew() : tess.polyIndexCache.getLast();
        firstPolyIndexCache=index;
        int i0=in.firstVertex;
        for (int ln=0; ln < lineCount - 1; ln++) {
          int i1=in.firstVertex + ln + 1;
          index=addLine2D(i0,i1,index,false);
          i0=i1;
        }
        index=addLine2D(in.lastVertex,in.firstVertex,index,false);
        lastPolyIndexCache=index;
      }
 else {
        int first=in.firstVertex;
        LinePath path=new LinePath(LinePath.WIND_NON_ZERO);
        path.moveTo(in.vertices[3 * first + 0],in.vertices[3 * first + 1]);
        if (tess.renderMode == RETAINED) {
        }
        for (int ln=0; ln < lineCount - 1; ln++) {
          int i1=first + ln + 1;
          path.lineTo(in.vertices[3 * i1 + 0],in.vertices[3 * i1 + 1]);
          if (tess.renderMode == RETAINED) {
          }
        }
        path.closePath();
        tessellateLinePath(path,false);
      }
    }
    setLastTexIndex(tess.lastPolyIndex,tess.polyIndexCache.size - 1);
  }
}

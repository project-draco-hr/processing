{
  BasicStroke bs;
  int bstrokeCap=strokeCap == ROUND ? BasicStroke.CAP_ROUND : strokeCap == PROJECT ? BasicStroke.CAP_SQUARE : BasicStroke.CAP_BUTT;
  int bstrokeJoin=strokeJoin == ROUND ? BasicStroke.JOIN_ROUND : strokeJoin == BEVEL ? BasicStroke.JOIN_BEVEL : BasicStroke.JOIN_MITER;
  bs=new BasicStroke(strokeWeight,bstrokeCap,bstrokeJoin);
  Shape sh=bs.createStrokedShape(path);
  GLU.gluTessBeginPolygon(gluTess,null);
  float lastX=0;
  float lastY=0;
  double[] vertex;
  float[] coords=new float[6];
  PathIterator iter=sh.getPathIterator(null);
  int rule=iter.getWindingRule();
switch (rule) {
case PathIterator.WIND_EVEN_ODD:
    GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_ODD);
  break;
case PathIterator.WIND_NON_ZERO:
GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_NONZERO);
break;
}
while (!iter.isDone()) {
switch (iter.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
GLU.gluTessBeginContour(gluTess);
case PathIterator.SEG_LINETO:
vertex=new double[]{coords[0],coords[1],0,strokeRed,strokeGreen,strokeBlue,strokeAlpha,0,0,1,0,0};
GLU.gluTessVertex(gluTess,vertex,0,vertex);
lastX=coords[0];
lastY=coords[1];
break;
case PathIterator.SEG_QUADTO:
for (int i=1; i < bezierDetail; i++) {
float t=(float)i / (float)bezierDetail;
vertex=new double[]{bezierPoint(lastX,coords[0],coords[2],coords[2],t),bezierPoint(lastY,coords[1],coords[3],coords[3],t),0,strokeRed,strokeGreen,strokeBlue,strokeAlpha,0,0,1,0,0};
GLU.gluTessVertex(gluTess,vertex,0,vertex);
}
lastX=coords[2];
lastY=coords[3];
break;
case PathIterator.SEG_CUBICTO:
for (int i=1; i < bezierDetail; i++) {
float t=(float)i / (float)bezierDetail;
vertex=new double[]{bezierPoint(lastX,coords[0],coords[2],coords[4],t),bezierPoint(lastY,coords[1],coords[3],coords[5],t),0,strokeRed,strokeGreen,strokeBlue,strokeAlpha,0,0,1,0,0};
GLU.gluTessVertex(gluTess,vertex,0,vertex);
}
lastX=coords[4];
lastY=coords[5];
break;
case PathIterator.SEG_CLOSE:
GLU.gluTessEndContour(gluTess);
break;
}
iter.next();
}
GLU.gluTessEndPolygon(gluTess);
}

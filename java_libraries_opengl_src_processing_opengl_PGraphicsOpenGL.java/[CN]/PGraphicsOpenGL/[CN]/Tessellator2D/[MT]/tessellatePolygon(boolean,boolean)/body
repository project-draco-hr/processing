{
  if (fill) {
    GLU.gluTessBeginPolygon(gluTess,null);
    if (solid) {
      GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_NONZERO);
    }
 else {
      GLU.gluTessProperty(gluTess,GLU.GLU_TESS_WINDING_RULE,GLU.GLU_TESS_WINDING_ODD);
    }
    GLU.gluTessBeginContour(gluTess);
    for (int i=inGeo.firstVertex; i <= inGeo.lastVertex; i++) {
      boolean breakPt=inGeo.codes[i] == PShape.BREAK;
      if (breakPt) {
        GLU.gluTessEndContour(gluTess);
        GLU.gluTessBeginContour(gluTess);
      }
      double[] vertex=new double[]{inGeo.vertices[3 * i + 0],inGeo.vertices[3 * i + 1],inGeo.vertices[3 * i + 2],inGeo.colors[4 * i + 0],inGeo.colors[4 * i + 1],inGeo.colors[4 * i + 2],inGeo.colors[4 * i + 3],inGeo.normals[3 * i + 0],inGeo.normals[3 * i + 1],inGeo.normals[3 * i + 2],inGeo.texcoords[2 * i + 0],inGeo.texcoords[2 * i + 1]};
      GLU.gluTessVertex(gluTess,vertex,0,vertex);
    }
    GLU.gluTessEndContour(gluTess);
    GLU.gluTessEndPolygon(gluTess);
  }
  if (stroke) {
    GeneralPath path=new GeneralPath(GeneralPath.WIND_NON_ZERO);
    path.moveTo(inGeo.vertices[3 * inGeo.firstVertex + 0],inGeo.vertices[3 * inGeo.firstVertex + 1]);
    for (int i=inGeo.firstVertex + 1; i <= inGeo.lastVertex; i++) {
      path.lineTo(inGeo.vertices[3 * i + 0],inGeo.vertices[3 * i + 1]);
    }
    path.closePath();
    tessellatePath(path);
  }
}

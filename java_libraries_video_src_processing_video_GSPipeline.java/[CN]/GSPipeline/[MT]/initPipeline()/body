{
  int idx;
  String lastElem, lastElemName;
  String[] parts;
  idx=pipeline.lastIndexOf('!');
  lastElem=pipeline.substring(idx + 1,pipeline.length()).trim();
  parts=lastElem.split(" ");
  if (0 < parts.length)   lastElemName=parts[0];
 else   lastElemName="";
  boolean fakeSink=lastElemName.equals("fakesink");
  boolean fileSink=lastElemName.equals("filesink");
  if (PApplet.platform == WINDOWS) {
    pipeline=pipeline.replace("\\","\\\\");
  }
  if (fakeSink || fileSink) {
    gpipeline=Pipeline.launch(pipeline);
  }
 else {
    if (streamType == GSVideo.VIDEO) {
      if (copyHandler != null) {
        try {
          copyBufferMethod=copyHandler.getClass().getMethod("addPixelsToBuffer",new Class[]{Object.class,IntBuffer.class,int.class,int.class});
          copyBufferMode=true;
        }
 catch (        Exception e) {
          copyBufferMode=false;
        }
        if (copyBufferMode) {
          try {
            Method meth=copyHandler.getClass().getMethod("setPixelSource",new Class[]{Object.class});
            meth.invoke(copyHandler,new Object[]{this});
          }
 catch (          Exception e) {
            copyBufferMode=false;
          }
          if (copyBufferMode) {
            String caps=" ! ffmpegcolorspace ! video/x-raw-rgb, bpp=32, depth=24, endianness=(int)4321, ";
            caps+=copyMask;
            StringBuilder finalPipeStr=new StringBuilder(pipeline);
            finalPipeStr.append(caps);
            finalPipeStr.append(" ! fakesink name=nat");
            pipeline=finalPipeStr.toString();
            gpipeline=Pipeline.launch(pipeline);
            natSink=new BufferDataSink("nat",gpipeline,new BufferDataSink.Listener(){
              public void bufferFrame(              int w,              int h,              Buffer buffer){
                invokeEvent(w,h,buffer);
              }
            }
);
            natSink.setAutoDisposeBuffer(false);
          }
        }
      }
      if (!copyBufferMode) {
        String caps=" ! ffmpegcolorspace ! video/x-raw-rgb, bpp=32, depth=24, endianness=(int)4321, ";
        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN)         caps+="red_mask=(int)0xFF00, green_mask=(int)0xFF0000, blue_mask=(int)0xFF000000";
 else         caps+="red_mask=(int)0xFF0000, green_mask=(int)0xFF00, blue_mask=(int)0xFF";
        StringBuilder finalPipeStr=new StringBuilder(pipeline);
        finalPipeStr.append(caps);
        finalPipeStr.append(" ! fakesink name=rgb");
        pipeline=finalPipeStr.toString();
        gpipeline=Pipeline.launch(pipeline);
        rgbSink=new RGBDataSink("rgb",gpipeline,new RGBDataSink.Listener(){
          public void rgbFrame(          boolean pre,          int w,          int h,          IntBuffer buffer){
            invokeEvent(w,h,buffer);
          }
        }
);
        rgbSink.setPassDirectBuffer(GSVideo.passDirectBuffer);
      }
    }
 else     if (streamType == GSVideo.AUDIO) {
      gpipeline=Pipeline.launch(pipeline);
    }
 else     if (streamType == GSVideo.RAW) {
      StringBuilder finalPipeStr=new StringBuilder(pipeline);
      finalPipeStr.append(" ! fakesink name=data");
      pipeline=finalPipeStr.toString();
      gpipeline=Pipeline.launch(pipeline);
      dataSink=new ByteDataSink("data",gpipeline,new ByteDataSink.Listener(){
        public void byteFrame(        boolean pre,        Caps caps,        int size,        ByteBuffer buffer){
          invokeEvent(caps,size,buffer);
        }
      }
);
      dataSink.setPassDirectBuffer(GSVideo.passDirectBuffer);
    }
 else {
      System.err.println("Unrecognized stream type: Please use VIDEO, AUDIO, or RAW.");
      return;
    }
  }
  Bus bus=gpipeline.getBus();
  bus.connect(new Bus.EOS(){
    public void endOfStream(    GstObject element){
      eosEvent();
    }
  }
);
  pipelineReady=true;
}

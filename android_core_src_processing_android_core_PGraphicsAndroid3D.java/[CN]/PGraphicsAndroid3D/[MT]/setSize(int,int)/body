{
  width=iwidth;
  height=iheight;
  width1=width - 1;
  height1=height - 1;
  allocate();
  reapplySettings();
  vertexCheck();
  projection=new PMatrix3D();
  modelview=new PMatrix3D();
  modelviewInv=new PMatrix3D();
  forwardTransform=modelview;
  reverseTransform=modelviewInv;
  cameraFOV=60 * DEG_TO_RAD;
  cameraX=width / 2.0f;
  cameraY=height / 2.0f;
  cameraZ=cameraY / ((float)Math.tan(cameraFOV / 2.0f));
  cameraNear=cameraZ / 10.0f;
  cameraFar=cameraZ * 10.0f;
  cameraAspect=(float)width / (float)height;
  camera=new PMatrix3D();
  cameraInv=new PMatrix3D();
  projectionGL=new float[16];
  modelviewGL=new float[16];
  modelviewInvGL=new float[16];
  cameramat=new float[16];
  cameramatInv=new float[16];
  texTriangleRanges=new ArrayList<TexturedTriangleRange>();
  lightTypeGL=new int[MAX_LIGHTS_GL];
  lightPositionGL=new float[MAX_LIGHTS_GL][4];
  lightNormalGL=new float[MAX_LIGHTS_GL][4];
  lightDiffuseGL=new float[MAX_LIGHTS_GL][4];
  lightSpecularGL=new float[MAX_LIGHTS_GL][4];
  lightFalloffConstantGL=new float[MAX_LIGHTS_GL];
  lightFalloffLinearGL=new float[MAX_LIGHTS_GL];
  lightFalloffQuadraticGL=new float[MAX_LIGHTS_GL];
  lightSpotAngleGL=new float[MAX_LIGHTS_GL];
  lightSpotAngleCosGL=new float[MAX_LIGHTS_GL];
  lightSpotConcentrationGL=new float[MAX_LIGHTS_GL];
  currentLightSpecularGL=new float[4];
}

{
  report("render_triangles in");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  TexturedTriangleRange texRange;
  for (int i=0; i < texTriangleRanges.size(); i++) {
    texRange=(TexturedTriangleRange)texTriangleRanges.get(i);
    if (texRange.textureImage != null && textureImage instanceof GLTexture) {
      tex=(GLTexture)textureImage;
      gl.glEnable(tex.getTextureTarget());
      gl.glBindTexture(tex.getTextureTarget(),tex.getTextureID());
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      texturing=true;
    }
 else     texturing=false;
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,3 * texRange.firstTriangle,3 * (texRange.lastTriangle - texRange.firstTriangle));
    if (texturing) {
      gl.glDisable(tex.getTextureTarget());
      ;
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report("render_triangles out");
}

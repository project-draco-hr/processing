{
  report("render_triangles in");
  GLTexture tex=null;
  boolean texturing=false;
  TexturedTriangleRange texRange;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int i=0; i < texTriangleRanges.size(); i++) {
    texRange=(TexturedTriangleRange)texTriangleRanges.get(i);
    if (texRange.textureImage != null) {
      try {
        tex=(GLTexture)texRange.textureImage;
      }
 catch (      ClassCastException cce) {
        throw new RuntimeException("A3D only accepts GLTextures for texturing!");
      }
      gl.glEnable(tex.getGLTarget());
      gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      texturing=true;
    }
 else     texturing=false;
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,3 * texRange.firstTriangle,3 * (texRange.lastTriangle - texRange.firstTriangle));
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      ;
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report("render_triangles out");
}

{
  report("render_lines in");
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=0; j < pathCount; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      linesVertexBuffer.rewind();
      linesColorBuffer.rewind();
      float a[]=vertices[lines[i][VERTEX1]];
      linesColorBuffer.put(toFixed32(a[SR]));
      linesColorBuffer.put(toFixed32(a[SG]));
      linesColorBuffer.put(toFixed32(a[SB]));
      linesColorBuffer.put(toFixed32(a[SA]));
      linesVertexBuffer.put(toFixed32(a[X]));
      linesVertexBuffer.put(toFixed32(a[Y]));
      linesVertexBuffer.put(toFixed32(a[Z]));
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        linesColorBuffer.put(toFixed32(b[SR]));
        linesColorBuffer.put(toFixed32(b[SG]));
        linesColorBuffer.put(toFixed32(b[SB]));
        linesColorBuffer.put(toFixed32(b[SA]));
        linesVertexBuffer.put(toFixed32(b[X]));
        linesVertexBuffer.put(toFixed32(b[Y]));
        linesVertexBuffer.put(toFixed32(b[Z]));
        i++;
      }
      linesVertexBuffer.position(0);
      linesColorBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,linesVertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,linesColorBuffer);
      gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
    }
  }
  gl.glPopMatrix();
  report("render_lines out");
}

{
  this.font=font;
  this.smooth=smooth;
  name=font.getName();
  psname=font.getPSName();
  if (charset != null) {
    Arrays.sort(charset);
  }
  this.charCount=(charset == null) ? 65536 : charset.length;
  this.size=font.getSize();
  glyphs=new Glyph[charCount];
  ascii=new int[128];
  for (int i=0; i < 128; i++)   ascii[i]=-1;
  int mbox3=size * 3;
  BufferedImage playground=new BufferedImage(mbox3,mbox3,BufferedImage.TYPE_INT_RGB);
  Graphics2D g=(Graphics2D)playground.getGraphics();
  g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,smooth ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
  g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,smooth ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
  g.setFont(font);
  FontMetrics metrics=g.getFontMetrics();
  int samples[]=new int[mbox3 * mbox3];
  int maxWidthHeight=0;
  int index=0;
  for (int i=0; i < charCount; i++) {
    Glyph glyph=new Glyph();
    char c=(charset == null) ? (char)i : charset[i];
    if (!font.canDisplay(c)) {
      continue;
    }
    g.setColor(Color.white);
    g.fillRect(0,0,mbox3,mbox3);
    g.setColor(Color.black);
    g.drawString(String.valueOf(c),size,size * 2);
    WritableRaster raster=playground.getRaster();
    raster.getDataElements(0,0,mbox3,mbox3,samples);
    int minX=1000, maxX=0;
    int minY=1000, maxY=0;
    boolean pixelFound=false;
    for (int y=0; y < mbox3; y++) {
      for (int x=0; x < mbox3; x++) {
        int sample=samples[y * mbox3 + x] & 0xff;
        if (sample != 255) {
          if (x < minX)           minX=x;
          if (y < minY)           minY=y;
          if (x > maxX)           maxX=x;
          if (y > maxY)           maxY=y;
          pixelFound=true;
        }
      }
    }
    if (!pixelFound) {
      minX=minY=0;
      maxX=maxY=0;
    }
    glyph.value=c;
    glyph.height=(maxY - minY) + 1;
    glyph.width=(maxX - minX) + 1;
    glyph.setWidth=metrics.charWidth(c);
    if (c < 128)     ascii[c]=index;
    glyph.topExtent=size * 2 - minY;
    glyph.leftExtent=minX - size;
    ascent=metrics.getAscent();
    descent=metrics.getDescent();
    if (glyph.width > maxWidthHeight)     maxWidthHeight=glyph.width;
    if (glyph.height > maxWidthHeight)     maxWidthHeight=glyph.height;
    glyph.image=new PImage(glyph.width,glyph.height,ALPHA);
    int[] pixels=glyph.image.pixels;
    for (int y=minY; y <= maxY; y++) {
      for (int x=minX; x <= maxX; x++) {
        int val=255 - (samples[y * mbox3 + x] & 0xff);
        int pindex=(y - minY) * glyph.width + (x - minX);
        pixels[pindex]=val;
      }
    }
    glyphs[index++]=glyph;
  }
  if (charCount != index) {
    glyphs=(Glyph[])PApplet.subset(glyphs,0,index);
    charCount=index;
  }
  if ((ascent == 0) && (descent == 0)) {
    for (    Glyph glyph : glyphs) {
      char cc=(char)glyph.value;
      if (Character.isWhitespace(cc) || (cc == '\u00A0') || (cc == '\u2007')|| (cc == '\u202F')) {
        continue;
      }
      if (glyph.topExtent > ascent) {
        ascent=glyph.topExtent;
      }
      int d=-glyph.topExtent + glyph.height;
      if (d > descent) {
        descent=d;
      }
    }
  }
}

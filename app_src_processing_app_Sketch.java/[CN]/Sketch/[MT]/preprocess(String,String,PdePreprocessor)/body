{
  ensureExistence();
  String[] codeFolderPackages=null;
  classPath=buildPath;
  if (codeFolder.exists()) {
    libraryPath=codeFolder.getAbsolutePath();
    String codeFolderClassPath=Compiler.contentsToClassPath(codeFolder);
    classPath+=File.pathSeparator + codeFolderClassPath;
    codeFolderPackages=Compiler.packageListFromClassPath(codeFolderClassPath);
  }
 else {
    libraryPath="";
  }
  StringBuffer bigCode=new StringBuffer();
  int bigCount=0;
  for (  SketchCode sc : code) {
    if (sc.isExtension("pde")) {
      sc.setPreprocOffset(bigCount);
      bigCode.append(sc.getProgram());
      bigCode.append('\n');
      bigCount+=sc.getLineCount();
    }
  }
  final PreprocessResult result;
  try {
    final File outputFolder=new File(buildPath,packageName.replace('.','/'));
    outputFolder.mkdirs();
    final File java=new File(outputFolder,name + ".java");
    final PrintWriter stream=new PrintWriter(new FileWriter(java));
    try {
      result=preprocessor.write(stream,bigCode.toString(),codeFolderPackages);
    }
  finally {
      stream.close();
    }
  }
 catch (  FileNotFoundException fnfe) {
    fnfe.printStackTrace();
    String msg="Build folder disappeared or could not be written";
    throw new RunnerException(msg);
  }
catch (  antlr.RecognitionException re) {
    int errorFile=0;
    int errorLine=re.getLine() - 1;
    for (int i=1; i < codeCount; i++) {
      if (code[i].isExtension("pde") && (code[i].getPreprocOffset() < errorLine)) {
        errorFile=i;
      }
    }
    errorLine-=code[errorFile].getPreprocOffset();
    String msg=re.getMessage();
    if (msg.equals("expecting RCURLY, found 'null'")) {
      throw new RunnerException("Found one too many { characters " + "without a } to match it.",errorFile,errorLine,re.getColumn());
    }
    if (msg.indexOf("expecting RBRACK") != -1) {
      System.err.println(msg);
      throw new RunnerException("Syntax error, " + "maybe a missing ] character?",errorFile,errorLine,re.getColumn());
    }
    if (msg.indexOf("expecting SEMI") != -1) {
      System.err.println(msg);
      throw new RunnerException("Syntax error, " + "maybe a missing semicolon?",errorFile,errorLine,re.getColumn());
    }
    if (msg.indexOf("expecting RPAREN") != -1) {
      System.err.println(msg);
      throw new RunnerException("Syntax error, " + "maybe a missing right parenthesis?",errorFile,errorLine,re.getColumn());
    }
    if (msg.indexOf("preproc.web_colors") != -1) {
      throw new RunnerException("A web color (such as #ffcc00) " + "must be six digits.",errorFile,errorLine,re.getColumn(),false);
    }
    throw new RunnerException(msg,errorFile,errorLine,re.getColumn());
  }
catch (  antlr.TokenStreamRecognitionException tsre) {
    String mess="^line (\\d+):(\\d+):\\s";
    String[] matches=PApplet.match(tsre.toString(),mess);
    if (matches != null) {
      int errorLine=Integer.parseInt(matches[1]) - 1;
      int errorColumn=Integer.parseInt(matches[2]);
      int errorFile=0;
      for (int i=1; i < codeCount; i++) {
        if (code[i].isExtension("pde") && (code[i].getPreprocOffset() < errorLine)) {
          errorFile=i;
        }
      }
      errorLine-=code[errorFile].getPreprocOffset();
      throw new RunnerException(tsre.getMessage(),errorFile,errorLine,errorColumn);
    }
 else {
      String msg=tsre.toString();
      throw new RunnerException(msg,0,-1,-1);
    }
  }
catch (  RunnerException pe) {
    throw pe;
  }
catch (  Exception ex) {
    System.err.println("Uncaught exception type:" + ex.getClass());
    ex.printStackTrace();
    throw new RunnerException(ex.toString());
  }
  importedLibraries=new ArrayList<File>();
  for (  String item : result.extraImports) {
    int dot=item.lastIndexOf('.');
    String entry=(dot == -1) ? item : item.substring(0,dot);
    File libFolder=(File)Base.importToLibraryTable.get(entry);
    if (libFolder != null) {
      if (!importedLibraries.contains(libFolder)) {
        importedLibraries.add(libFolder);
        classPath+=Compiler.contentsToClassPath(libFolder);
        libraryPath+=File.pathSeparator + libFolder.getAbsolutePath();
      }
    }
  }
  String javaClassPath=System.getProperty("java.class.path");
  if (javaClassPath.startsWith("\"") && javaClassPath.endsWith("\"")) {
    javaClassPath=javaClassPath.substring(1,javaClassPath.length() - 1);
  }
  classPath+=File.pathSeparator + javaClassPath;
  for (  SketchCode sc : code) {
    if (sc.isExtension("java")) {
      String filename=sc.getFileName();
      try {
        String program=sc.getProgram();
        String[] pkg=PApplet.match(program,PACKAGE_REGEX);
        if (pkg == null) {
          pkg=new String[]{packageName};
          program="package " + packageName + ";"+ program;
        }
        File packageFolder=new File(buildPath,pkg[0].replace('.','/'));
        packageFolder.mkdirs();
        Base.saveFile(program,new File(packageFolder,filename));
      }
 catch (      IOException e) {
        e.printStackTrace();
        throw new RunnerException("Problem moving " + filename + " to the build folder");
      }
    }
 else     if (sc.isExtension("pde")) {
      sc.addPreprocOffset(result.headerOffset);
    }
  }
  foundMain=preprocessor.getFoundMain();
  return result.className;
}

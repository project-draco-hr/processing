{
  if (PApplet.javaVersion < 1.3) {
    throw new RuntimeException("Can only create fonts with " + "Java 1.3 or higher");
  }
  try {
    this.charCount=all ? 65536 : charset.length;
    this.size=font.getSize();
    fwidth=fheight=size;
    PImage bitmaps[]=new PImage[charCount];
    value=new int[charCount];
    height=new int[charCount];
    width=new int[charCount];
    setWidth=new int[charCount];
    topExtent=new int[charCount];
    leftExtent=new int[charCount];
    ascii=new int[128];
    for (int i=0; i < 128; i++)     ascii[i]=-1;
    int mbox3=size * 3;
    Class bufferedImageClass=Class.forName("java.awt.image.BufferedImage");
    Constructor bufferedImageConstructor=bufferedImageClass.getConstructor(new Class[]{Integer.TYPE,Integer.TYPE,Integer.TYPE});
    Field typeIntRgbField=bufferedImageClass.getField("TYPE_INT_RGB");
    int typeIntRgb=typeIntRgbField.getInt(typeIntRgbField);
    Object playground=bufferedImageConstructor.newInstance(new Object[]{new Integer(mbox3),new Integer(mbox3),new Integer(typeIntRgb)});
    Class graphicsClass=Class.forName("java.awt.Graphics2D");
    Method getGraphicsMethod=bufferedImageClass.getMethod("getGraphics",new Class[]{});
    Graphics g=(Graphics)getGraphicsMethod.invoke(playground,new Object[]{});
    Class renderingHintsClass=Class.forName("java.awt.RenderingHints");
    Class renderingHintsKeyClass=Class.forName("java.awt.RenderingHints$Key");
    Field antialiasingKeyField=renderingHintsClass.getDeclaredField("KEY_TEXT_ANTIALIASING");
    Object antialiasingKey=antialiasingKeyField.get(renderingHintsClass);
    Field antialiasField=smooth ? renderingHintsClass.getField("VALUE_TEXT_ANTIALIAS_ON") : renderingHintsClass.getField("VALUE_TEXT_ANTIALIAS_OFF");
    Object antialiasState=antialiasField.get(renderingHintsClass);
    Method setRenderingHintMethod=graphicsClass.getMethod("setRenderingHint",new Class[]{renderingHintsKeyClass,Object.class});
    setRenderingHintMethod.invoke(g,new Object[]{antialiasingKey,antialiasState});
    g.setFont(font);
    FontMetrics metrics=g.getFontMetrics();
    Method canDisplayMethod=null;
    Method getDataMethod=null;
    Method getSamplesMethod=null;
    int samples[]=new int[mbox3 * mbox3];
    canDisplayMethod=Font.class.getMethod("canDisplay",new Class[]{Character.TYPE});
    getDataMethod=bufferedImageClass.getMethod("getData",new Class[]{});
    Class rasterClass=Class.forName("java.awt.image.Raster");
    getSamplesMethod=rasterClass.getMethod("getSamples",new Class[]{Integer.TYPE,Integer.TYPE,Integer.TYPE,Integer.TYPE,Integer.TYPE,samples.getClass()});
    int maxWidthHeight=0;
    int index=0;
    for (int i=0; i < charCount; i++) {
      char c=all ? (char)i : charset[i];
      try {
        Character ch=new Character(c);
        Boolean canDisplay=(Boolean)canDisplayMethod.invoke(font,new Object[]{ch});
        if (canDisplay.booleanValue() == false) {
          continue;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        return;
      }
      g.setColor(Color.white);
      g.fillRect(0,0,mbox3,mbox3);
      g.setColor(Color.black);
      g.drawString(String.valueOf(c),size,size * 2);
      Object raster=getDataMethod.invoke(playground,new Object[]{});
      getSamplesMethod.invoke(raster,new Object[]{new Integer(0),new Integer(0),new Integer(mbox3),new Integer(mbox3),new Integer(0),samples});
      int minX=1000, maxX=0;
      int minY=1000, maxY=0;
      boolean pixelFound=false;
      for (int y=0; y < mbox3; y++) {
        for (int x=0; x < mbox3; x++) {
          int sample=samples[y * mbox3 + x] & 0xff;
          if (sample != 255) {
            if (x < minX)             minX=x;
            if (y < minY)             minY=y;
            if (x > maxX)             maxX=x;
            if (y > maxY)             maxY=y;
            pixelFound=true;
          }
        }
      }
      if (!pixelFound) {
        minX=minY=0;
        maxX=maxY=0;
      }
      value[index]=c;
      height[index]=(maxY - minY) + 1;
      width[index]=(maxX - minX) + 1;
      setWidth[index]=metrics.charWidth(c);
      if (c < 128)       ascii[c]=index;
      topExtent[index]=size * 2 - minY;
      leftExtent[index]=minX - size;
      if (c == 'd') {
        ascent=topExtent[index];
      }
      if (c == 'p') {
        descent=-topExtent[index] + height[index];
      }
      if (width[index] > maxWidthHeight)       maxWidthHeight=width[index];
      if (height[index] > maxWidthHeight)       maxWidthHeight=height[index];
      bitmaps[index]=new PImage(new int[width[index] * height[index]],width[index],height[index],ALPHA);
      for (int y=minY; y <= maxY; y++) {
        for (int x=minX; x <= maxX; x++) {
          int val=255 - (samples[y * mbox3 + x] & 0xff);
          int pindex=(y - minY) * width[index] + (x - minX);
          bitmaps[index].pixels[pindex]=val;
        }
      }
      index++;
    }
    charCount=index;
    if ((ascent == 0) && (descent == 0)) {
      for (int i=0; i < charCount; i++) {
        char cc=(char)value[i];
        if (Character.isWhitespace(cc) || (cc == '\u00A0') || (cc == '\u2007')|| (cc == '\u202F')) {
          continue;
        }
        if (topExtent[i] > ascent) {
          ascent=topExtent[i];
        }
        int d=-topExtent[i] + height[i];
        if (d > descent) {
          descent=d;
        }
      }
    }
    mbox2=(int)Math.pow(2,Math.ceil(Math.log(maxWidthHeight) / Math.log(2)));
    twidth=theight=mbox2;
    images=new PImage[charCount];
    for (int i=0; i < charCount; i++) {
      images[i]=new PImage(new int[mbox2 * mbox2],mbox2,mbox2,ALPHA);
      for (int y=0; y < height[i]; y++) {
        System.arraycopy(bitmaps[i].pixels,y * width[i],images[i].pixels,y * mbox2,width[i]);
      }
      bitmaps[i]=null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e.getMessage());
  }
}

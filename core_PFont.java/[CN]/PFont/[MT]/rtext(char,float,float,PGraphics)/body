{
  int glyph=index(c);
  if (glyph == -1)   return;
  parent.stroke(150);
  parent.line(x,y,x,y + 10);
  int sx=(int)x + topExtent[glyph];
  int sy=(int)y + leftExtent[glyph];
  int px=0;
  int py=0;
  int pw=width[glyph];
  int ph=height[glyph];
  if ((sx + ph >= parent.width) || (sy >= parent.height) || (sy + pw < 0)|| (sx < 0))   return;
  if (sx < ph) {
    ph-=(ph - sx);
  }
  if (sx >= parent.width) {
    int extra=sx - (parent.width - 1);
    py+=extra;
    ph-=extra;
    sx=parent.width - 1;
  }
  if (sy < 0) {
    int extra=-sy;
    px+=extra;
    pw-=extra;
    sy=0;
  }
  if (sy + pw >= parent.height - 1) {
    int extra=(sy + pw) - (parent.height - 1);
    pw-=extra;
  }
  int fr=parent.fillRi;
  int fg=parent.fillGi;
  int fb=parent.fillBi;
  int fa=parent.fillAi;
  int fpixels[]=images[glyph].pixels;
  int spixels[]=parent.pixels;
  for (int row=py; row < py + ph; row++) {
    for (int col=px; col < px + pw; col++) {
      int a1=(fa * fpixels[row * twidth + col]) >> 8;
      int a2=a1 ^ 0xff;
      int p1=fpixels[row * width[glyph] + col];
      try {
        int index=(sy + px + col) * parent.width + (sx + row - py);
        int p2=spixels[index];
        spixels[index]=(0xff000000 | (((a1 * fr + a2 * ((p2 >> 16) & 0xff)) & 0xff00) << 8) | ((a1 * fg + a2 * ((p2 >> 8) & 0xff)) & 0xff00)| ((a1 * fb + a2 * (p2 & 0xff)) >> 8));
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        System.out.println("out of bounds " + sy + " "+ px+ " "+ col);
      }
    }
  }
}

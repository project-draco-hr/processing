{
  SwingWorker worker=new SwingWorker(){
    @Override protected Object doInBackground() throws Exception {
      return null;
    }
    protected void done(){
      String word2=word;
      boolean noCompare=false;
      if (word2.endsWith(".")) {
        word2=word2.substring(0,word.length() - 1);
        noCompare=true;
      }
      int lineNumber=line;
      if (errorCheckerService != null) {
        editor=errorCheckerService.getEditor();
        int codeIndex=editor.getSketch().getCodeIndex(editor.getCurrentTab());
        if (codeIndex > 0)         for (int i=0; i < codeIndex; i++) {
          SketchCode sc=editor.getSketch().getCode(i);
          int len=Base.countLines(sc.getProgram()) + 1;
          lineNumber+=len;
        }
      }
      ASTNode anode=null;
      ASTParser parser=ASTParser.newParser(AST.JLS4);
      parser.setKind(ASTParser.K_EXPRESSION);
      parser.setSource(word2.toCharArray());
      ASTNode testnode=parser.createAST(null);
      System.err.print("Typed: " + word2 + "|");
      anode=findClosestNode(lineNumber,(ASTNode)compilationUnit.types().get(0));
      System.err.println(lineNumber + " Nearest ASTNode to PRED " + getNodeAsString(anode));
      ArrayList<String> candidates=new ArrayList<String>();
      if (testnode instanceof SimpleName && !noCompare) {
        System.err.println("One word expression " + getNodeAsString(testnode));
        anode=anode.getParent();
        while (anode != null) {
          List<StructuralPropertyDescriptor> sprops=anode.structuralPropertiesForType();
          for (          StructuralPropertyDescriptor sprop : sprops) {
            ASTNode cnode=null;
            if (!sprop.isChildListProperty()) {
              if (anode.getStructuralProperty(sprop) instanceof ASTNode) {
                cnode=(ASTNode)anode.getStructuralProperty(sprop);
                String[] types=checkForTypes(cnode);
                if (types != null) {
                  for (int i=0; i < types.length; i++) {
                    if (types[i].startsWith(word2))                     candidates.add(types[i]);
                  }
                }
              }
            }
 else {
              List<ASTNode> nodelist=(List<ASTNode>)anode.getStructuralProperty(sprop);
              for (              ASTNode clnode : nodelist) {
                String[] types=checkForTypes(clnode);
                if (types != null) {
                  for (int i=0; i < types.length; i++) {
                    if (types[i].startsWith(word2))                     candidates.add(types[i]);
                  }
                }
              }
            }
          }
          anode=anode.getParent();
        }
      }
 else {
        System.err.println("Complex expression " + getNodeAsString(testnode));
        ASTNode det=resolveExpression(anode,testnode);
        System.err.println("DET " + getNodeAsString(det));
        if (det != null) {
          TypeDeclaration td=null;
          SimpleType stp=null;
          if (det instanceof MethodDeclaration) {
            if (((MethodDeclaration)det).getReturnType2() instanceof SimpleType) {
              stp=(SimpleType)(((MethodDeclaration)det).getReturnType2());
              td=(TypeDeclaration)findDeclaration(stp.getName());
            }
          }
 else           if (det instanceof FieldDeclaration) {
            if (((FieldDeclaration)det).getType() instanceof SimpleType) {
              stp=(SimpleType)(((FieldDeclaration)det).getType());
              td=(TypeDeclaration)findDeclaration(stp.getName());
            }
          }
 else           if (det instanceof VariableDeclarationStatement) {
            stp=(SimpleType)(((VariableDeclarationStatement)det).getType());
            td=(TypeDeclaration)findDeclaration(stp.getName());
          }
          System.out.println("ST is " + stp.getName());
          System.err.println(getNodeAsString(det) + " defined in " + getNodeAsString(td));
          if (td != null) {
            ASTNode child=resolveChildExpression(testnode);
            System.out.println("Completion candidate: " + getNodeAsString(child));
            for (int i=0; i < td.getFields().length; i++) {
              List<VariableDeclarationFragment> vdfs=td.getFields()[i].fragments();
              for (              VariableDeclarationFragment vdf : vdfs) {
                if (noCompare) {
                  candidates.add(getNodeAsString(vdf));
                }
 else                 if (vdf.getName().toString().startsWith(child.toString()))                 candidates.add(getNodeAsString(vdf));
              }
            }
            for (int i=0; i < td.getMethods().length; i++) {
              if (noCompare) {
                candidates.add(getNodeAsString(td.getMethods()[i]));
              }
 else               if (td.getMethods()[i].getName().toString().startsWith(child.toString()))               candidates.add(getNodeAsString(td.getMethods()[i]));
            }
          }
 else {
            if (stp != null) {
              System.out.println("Couldn't determine type! " + stp.getName().toString());
              RegExpResourceFilter regExpResourceFilter;
              regExpResourceFilter=new RegExpResourceFilter(".*",stp.getName().toString() + ".class");
              String[] resources=classPath.findResources("",regExpResourceFilter);
              for (              String className : resources) {
                System.out.println("-> " + className);
              }
              if (resources.length > 0) {
                String matchedClass=resources[0];
                matchedClass=matchedClass.substring(0,matchedClass.length() - 6);
                matchedClass=matchedClass.replace('/','.');
                System.out.println("Matched class: " + matchedClass);
                try {
                  Class<?> probableClass=Class.forName(matchedClass,false,errorCheckerService.classLoader);
                  for (                  Method method : probableClass.getMethods()) {
                    StringBuffer label=new StringBuffer(method.getName() + "(");
                    for (                    Class<?> type : method.getParameterTypes()) {
                      label.append(type.getSimpleName() + ",");
                    }
                    label.append(")");
                    candidates.add(label.toString());
                  }
                  for (                  Field field : probableClass.getFields()) {
                    candidates.add(field.getName());
                  }
                }
 catch (                ClassNotFoundException e) {
                  e.printStackTrace();
                  System.out.println("Couldn't load " + matchedClass);
                }
              }
            }
          }
        }
      }
      String[][] candi=new String[candidates.size()][1];
      for (int i=0; i < candi.length; i++) {
        candi[i][0]=candidates.get(i);
      }
      System.out.println("K = " + candidates.size());
      DefaultTableModel tm=new DefaultTableModel(candi,new String[]{"Suggestions"});
      tableAuto.setModel(tm);
      tableAuto.validate();
      tableAuto.repaint();
    }
  }
;
  worker.execute();
}

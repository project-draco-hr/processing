{
  String importPackageList[]=null;
  String javaClassPath=System.getProperty("java.class.path");
  if (javaClassPath.startsWith("\"") && javaClassPath.endsWith("\"")) {
    javaClassPath=javaClassPath.substring(1,javaClassPath.length() - 1);
  }
  classPath=buildPath + File.pathSeparator + javaClassPath;
  if (codeFolder.exists()) {
    externalRuntime=true;
    classPath+=File.pathSeparator + PdeCompiler.contentsToClassPath(codeFolder);
    importPackageList=PdeCompiler.makeImportsFromClassPath(classPath);
    libraryPath=codeFolder.getAbsolutePath();
  }
 else {
    externalRuntime=(codeCount > 1);
    importPackageList=null;
    libraryPath="";
  }
  if (PdeBase.calcFolderSize(dataFolder) > 768 * 1024) {
    externalRuntime=true;
  }
  String primaryClassName=null;
  for (int i=0; i < codeCount; i++) {
    if (code[i].flavor == JAVA) {
      String filename=code[i].name + ".java";
      try {
        PdeBase.saveFile(code[i].program,new File(buildPath,filename));
      }
 catch (      IOException e) {
        e.printStackTrace();
        throw new PdeException("Problem moving " + filename + " to the build folder");
      }
      code[i].preprocName=filename;
    }
 else     if (code[i].flavor == PDE) {
      PdePreprocessor preprocessor=new PdePreprocessor();
      try {
        String className=preprocessor.write(code[i].program,buildPath,(i == 0) ? suggestedClassName : null,importPackageList);
        if (className == null) {
          System.out.println("No class found in " + code[i].name);
          System.out.println("(any code in that file will be ignored)");
          System.out.println();
        }
 else {
          code[i].preprocName=className + ".java";
        }
        if (i == 0) {
          primaryClassName=className;
          if (PdePreprocessor.programType == PdePreprocessor.JAVA) {
            externalRuntime=true;
          }
        }
      }
 catch (      antlr.RecognitionException re) {
        throw new PdeException(re.getMessage(),i,re.getLine() - 1,re.getColumn());
      }
catch (      antlr.TokenStreamRecognitionException tsre) {
        PatternMatcher matcher=new Perl5Matcher();
        PatternCompiler compiler=new Perl5Compiler();
        String mess="^line (\\d+):(\\d+):\\s";
        Pattern pattern=null;
        try {
          pattern=compiler.compile(mess);
        }
 catch (        MalformedPatternException e) {
          PdeBase.showWarning("Internal Problem","An internal error occurred while trying\n" + "to compile the sketch. Please report\n" + "this online at http://processing.org/bugs",e);
        }
        PatternMatcherInput input=new PatternMatcherInput(tsre.toString());
        if (matcher.contains(input,pattern)) {
          MatchResult result=matcher.getMatch();
          int line=Integer.parseInt(result.group(1).toString());
          int column=Integer.parseInt(result.group(2).toString());
          throw new PdeException(tsre.getMessage(),i,line - 1,column);
        }
 else {
          throw new PdeException(tsre.toString(),i,-1,-1);
        }
      }
catch (      PdeException pe) {
        throw pe;
      }
catch (      Exception ex) {
        System.err.println("Uncaught exception type:" + ex.getClass());
        ex.printStackTrace();
        throw new PdeException(ex.toString());
      }
    }
  }
  PdeCompiler compiler=new PdeCompiler();
  boolean success=compiler.compile(this,buildPath);
  return success ? primaryClassName : null;
}

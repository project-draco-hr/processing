{
  String importPackageList[]=null;
  String javaClassPath=System.getProperty("java.class.path");
  if (javaClassPath.startsWith("\"") && javaClassPath.endsWith("\"")) {
    javaClassPath=javaClassPath.substring(1,javaClassPath.length() - 1);
  }
  classPath=buildPath + File.pathSeparator + javaClassPath;
  if (codeFolder.exists()) {
    externalRuntime=true;
    classPath+=File.pathSeparator + PdeCompiler.contentsToClassPath(codeFolder);
    importPackageList=PdeCompiler.makeImportsFromClassPath(classPath);
    libraryPath=codeFolder.getAbsolutePath();
  }
 else {
    externalRuntime=(codeCount > 1);
    importPackageList=null;
    libraryPath="";
  }
  if (dataFolder.exists() && PdeBase.calcFolderSize(dataFolder) > 768 * 1024) {
    externalRuntime=true;
  }
  StringBuffer bigCode=new StringBuffer(code[0].program);
  int bigCount=countLines(code[0].program);
  for (int i=1; i < codeCount; i++) {
    if (code[i].flavor == PDE) {
      code[i].lineOffset=++bigCount;
      bigCode.append('\n');
      bigCode.append(code[i].program);
      bigCount+=countLines(code[i].program);
      code[i].preprocName=null;
    }
  }
  String primaryClassName=null;
  PdePreprocessor preprocessor=new PdePreprocessor();
  try {
    String className=preprocessor.write(bigCode.toString(),buildPath,suggestedClassName,importPackageList);
    if (className == null) {
      throw new PdeException("Could not find main class");
    }
 else {
      code[0].preprocName=className + ".java";
    }
    primaryClassName=className;
    if (PdePreprocessor.programType == PdePreprocessor.JAVA) {
      externalRuntime=true;
    }
  }
 catch (  antlr.RecognitionException re) {
    int errorFile=0;
    int errorLine=re.getLine() - 1;
    for (int i=1; i < codeCount; i++) {
      if ((code[i].flavor == PDE) && (code[i].lineOffset < errorLine)) {
        errorFile=i;
      }
    }
    errorLine-=code[errorFile].lineOffset;
    throw new PdeException(re.getMessage(),errorFile,errorLine,re.getColumn());
  }
catch (  antlr.TokenStreamRecognitionException tsre) {
    PatternMatcher matcher=new Perl5Matcher();
    PatternCompiler compiler=new Perl5Compiler();
    String mess="^line (\\d+):(\\d+):\\s";
    Pattern pattern=null;
    try {
      pattern=compiler.compile(mess);
    }
 catch (    MalformedPatternException e) {
      PdeBase.showWarning("Internal Problem","An internal error occurred while trying\n" + "to compile the sketch. Please report\n" + "this online at http://processing.org/bugs",e);
    }
    PatternMatcherInput input=new PatternMatcherInput(tsre.toString());
    if (matcher.contains(input,pattern)) {
      MatchResult result=matcher.getMatch();
      int errorLine=Integer.parseInt(result.group(1).toString()) - 1;
      int errorColumn=Integer.parseInt(result.group(2).toString());
      int errorFile=0;
      for (int i=1; i < codeCount; i++) {
        if ((code[i].flavor == PDE) && (code[i].lineOffset < errorLine)) {
          errorFile=i;
        }
      }
      errorLine-=code[errorFile].lineOffset;
      throw new PdeException(tsre.getMessage(),errorFile,errorLine,errorColumn);
    }
 else {
      throw new PdeException(tsre.toString(),0,-1,-1);
    }
  }
catch (  PdeException pe) {
    throw pe;
  }
catch (  Exception ex) {
    System.err.println("Uncaught exception type:" + ex.getClass());
    ex.printStackTrace();
    throw new PdeException(ex.toString());
  }
  for (int i=0; i < codeCount; i++) {
    if (code[i].flavor == JAVA) {
      String filename=code[i].name + ".java";
      try {
        PdeBase.saveFile(code[i].program,new File(buildPath,filename));
      }
 catch (      IOException e) {
        e.printStackTrace();
        throw new PdeException("Problem moving " + filename + " to the build folder");
      }
      code[i].preprocName=filename;
    }
  }
  PdeCompiler compiler=new PdeCompiler();
  boolean success=compiler.compile(this,buildPath);
  return success ? primaryClassName : null;
}

{
  monitor.beginTask("Full Project Build",400);
  sketch=getProject();
  if (!sketch.isOpen()) {
    return;
  }
  if (checkCancel(monitor)) {
    return;
  }
  if (!deleteProblemMarkers(sketch)) {
    return;
  }
  IResource[] folderContents=sketch.members();
  codeFolder=sketch.getFolder("code");
  dataFolder=sketch.getFolder("data");
  outputFolder=sketch.getFolder("bin");
  if (!outputFolder.exists())   outputFolder.create(IResource.NONE,true,null);
  monitor.worked(100);
  if (checkCancel(monitor)) {
    return;
  }
  spoof_preferences();
  PdePreprocessor preprocessor=new PdePreprocessor(sketch.getName(),4);
  String[] codeFolderPackages=null;
  String classPath=outputFolder.getLocation().toOSString();
  if (codeFolder.exists()) {
    libraryPath=codeFolder.getLocationURI().toString();
    String codeFolderClassPath=Compiler.contentsToClassPath(codeFolder.getLocation().toFile());
    classPath+=File.pathSeparator + codeFolderClassPath;
    codeFolderPackages=Compiler.packageListFromClassPath(codeFolderClassPath);
  }
 else {
    libraryPath="";
  }
  StringBuffer bigCode=new StringBuffer();
  int bigCount=0;
  for (int i=0; i < folderContents.length; i++) {
    IResource file=folderContents[i];
    if (file instanceof IFile && file.getFileExtension().equalsIgnoreCase("pde")) {
      setPreprocOffset((IFile)file,bigCount);
      String content=readFile((IFile)file);
      bigCode.append(content);
      bigCode.append("\n");
      bigCount+=getLineCount(content);
    }
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return;
  }
  PreprocessResult result=null;
  try {
    IFile outputFile=outputFolder.getFile(sketch.getName() + ".java");
    StringWriter stream=new StringWriter();
    result=preprocessor.write(stream,bigCode.toString(),codeFolderPackages);
    ByteArrayInputStream inStream=new ByteArrayInputStream(stream.toString().getBytes());
    if (outputFile.exists()) {
      outputFile.setContents(inStream,true,false,monitor);
    }
 else {
      outputFile.create(inStream,true,monitor);
    }
    outputFile.setDerived(true);
  }
 catch (  CoreException e) {
    ProcessingLog.logError(e);
    return;
  }
catch (  antlr.RecognitionException re) {
    int errorFile=0;
    int errorLine=re.getLine() - 1;
    for (int i=1; i < folderContents.length; i++) {
      IResource file=folderContents[i];
      if (file instanceof IFile && file.getFileExtension().equalsIgnoreCase("pde") && (getPreprocOffset((IFile)file) < errorLine)) {
        errorFile=i;
      }
    }
    errorLine-=getPreprocOffset((IFile)folderContents[errorFile]);
    String msg=re.getMessage();
    if (msg.equals("expecting RCURLY, found 'null'")) {
      msg="Found one too many { characters without a } to match it.";
    }
    if (msg.indexOf("expecting RBRACK") != -1) {
      msg="Syntax error, maybe a missing right ] character?";
    }
    if (msg.indexOf("expecting SEMI") != -1) {
      msg="Syntax error, maybe a missing semicolon?";
    }
    if (msg.indexOf("expecting RPAREN") != -1) {
      msg="Syntax error, maybe a missing right parenthesis?";
    }
    if (msg.indexOf("preproc.web_colors") != -1) {
      msg="A web color (such as #ffcc00) must be six digits.";
    }
    reportProblem(msg,(IFile)folderContents[errorFile],errorLine,true);
    return;
  }
catch (  antlr.TokenStreamRecognitionException tsre) {
    String mess="^line (\\d+):(\\d+):\\s";
    String[] matches=PApplet.match(tsre.toString(),mess);
    if (matches != null) {
      int errorLine=Integer.parseInt(matches[1]) - 1;
      int errorColumn=Integer.parseInt(matches[2]);
      int errorFile=0;
      for (int i=1; i < folderContents.length; i++) {
        IResource file=folderContents[i];
        if (file instanceof IFile && file.getFileExtension().equalsIgnoreCase("pde") && (getPreprocOffset((IFile)file) < errorLine)) {
          errorFile=i;
        }
      }
      errorLine-=getPreprocOffset((IFile)folderContents[errorFile]);
      reportProblem(tsre.getMessage(),(IFile)folderContents[errorFile],errorLine,true);
    }
 else {
      try {
        reportProblem(tsre.toString(),sketch.getFile(sketch.getName() + ".pde"),0,true);
      }
 catch (      Exception e) {
        ProcessingLog.logError(e);
        return;
      }
    }
    return;
  }
catch (  Exception e) {
    ProcessingLog.logError(e);
    return;
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return;
  }
  importedLibraries=new ArrayList<File>();
  for (  String item : result.extraImports) {
    int dot=item.lastIndexOf('.');
    String entry=(dot == -1) ? item : item.substring(0,dot);
    File libFolder=null;
    if (libFolder.exists()) {
      importedLibraries.add(libFolder);
      classPath+=Compiler.contentsToClassPath(libFolder);
      libraryPath+=File.pathSeparator + libFolder.getAbsolutePath();
    }
  }
  String javaClassPath=System.getProperty("java.class.path");
  if (javaClassPath.startsWith("\"") && javaClassPath.endsWith("\"")) {
    javaClassPath=javaClassPath.substring(1,javaClassPath.length() - 1);
  }
  classPath+=File.pathSeparator + javaClassPath;
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return;
  }
  for (int i=0; i < folderContents.length; i++) {
    IResource file=folderContents[i];
    if (file instanceof IFile && file.getFileExtension().equalsIgnoreCase("java")) {
      folderContents[i].copy(outputFolder.getProjectRelativePath(),IResource.DERIVED,monitor);
    }
 else     if (file instanceof IFile && file.getFileExtension().equalsIgnoreCase("pde")) {
      if (result == null)       System.out.println("Danger!");
      addPreprocOffset((IFile)file,result.headerOffset);
    }
  }
  boolean foundMain=preprocessor.getFoundMain();
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return;
  }
  monitor.done();
}

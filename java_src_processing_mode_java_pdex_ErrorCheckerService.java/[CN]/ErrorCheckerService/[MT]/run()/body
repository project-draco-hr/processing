{
  stopThread.set(false);
  checkCode();
  lastErrorCheckCall=System.currentTimeMillis();
  if (!hasSyntaxErrors()) {
    editor.showConsole();
  }
synchronized (astGenerator) {
    astGenerator.buildAST(cu);
  }
  handleErrorCheckingToggle();
  while (!stopThread.get()) {
    try {
      if (!noSleep) {
        Thread.sleep(sleepTime);
      }
 else {
        noSleep=false;
        Messages.log("Didn't sleep!");
      }
    }
 catch (    Exception e) {
      Messages.log("Oops! [ErrorCheckerThreaded]: " + e);
    }
    updatePaintedThingys();
    updateEditorStatus();
    updateSketchCodeListeners();
    if (pauseThread.get())     continue;
    if (textModified.get() == 0)     continue;
    if (System.currentTimeMillis() - lastErrorCheckCall > errorCheckInterval) {
      Messages.log("Interval passed, starting error check");
      checkCode();
      checkForMissingImports();
    }
  }
synchronized (astGenerator) {
    astGenerator.disposeAllWindows();
  }
  compilationChecker=null;
  checkerClass=null;
  classLoader=null;
  System.gc();
  Messages.loge("Thread stopped: " + editor.getSketch().getName());
  System.gc();
}

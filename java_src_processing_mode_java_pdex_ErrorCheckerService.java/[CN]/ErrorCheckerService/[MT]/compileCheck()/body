{
  parser.setSource(sourceCode.toCharArray());
  parser.setKind(ASTParser.K_COMPILATION_UNIT);
  Map<String,String> options=JavaCore.getOptions();
  JavaCore.setComplianceOptions(JavaCore.VERSION_1_6,options);
  options.put(JavaCore.COMPILER_SOURCE,JavaCore.VERSION_1_6);
  options.put(JavaCore.COMPILER_DOC_COMMENT_SUPPORT,JavaCore.ENABLED);
  parser.setCompilerOptions(options);
  if (compileCheckCU == null) {
    compileCheckCU=(CompilationUnit)parser.createAST(null);
  }
 else {
synchronized (compileCheckCU) {
      compileCheckCU=(CompilationUnit)parser.createAST(null);
    }
  }
  if (!hasSyntaxErrors()) {
    lastCorrectCU=compileCheckCU;
  }
  cu=compileCheckCU;
  compilationUnitState=2;
  try {
    if (loadCompClass) {
      classPath=new URL[classpathJars.size()];
      classpathJars.toArray(classPath);
      compilationChecker=null;
      classLoader=null;
      System.gc();
      classLoader=new URLClassLoader(classPath);
      compilationChecker=new CompilationChecker();
      loadCompClass=false;
    }
    if (compilerSettings == null) {
      prepareCompilerSetting();
    }
synchronized (problemsList) {
      problems=compilationChecker.getErrors(className,sourceCode,compilerSettings,classLoader);
      if (problems == null) {
        return;
      }
      for (      IProblem problem : problems) {
        int[] a=calculateTabIndexAndLineNumber(problem.getSourceLineNumber() - 1);
        Problem p=new Problem(problem,a[0],a[1]);
        if (problem.isError()) {
          p.setType(Problem.ERROR);
          containsErrors.set(true);
        }
        if (problem.isWarning()) {
          p.setType(Problem.WARNING);
        }
        if (p.isWarning() && !JavaMode.warningsEnabled) {
          continue;
        }
        problemsList.add(p);
      }
    }
  }
 catch (  Exception e) {
    System.err.println("compileCheck() problem." + e);
    e.printStackTrace();
    pauseThread();
  }
catch (  NoClassDefFoundError e) {
    e.printStackTrace();
    pauseThread();
  }
catch (  OutOfMemoryError e) {
    System.err.println("Out of memory while checking for errors.");
    System.err.println("Close some sketches and then re-open this sketch.");
    pauseThread();
  }
}

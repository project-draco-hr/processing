{
  PreprocessedSketch result=new PreprocessedSketch();
  PreprocessedSketch prevResult=null;
  List<ImportStatement> coreAndDefaultImports=result.coreAndDefaultImports;
  List<ImportStatement> codeFolderImports=result.codeFolderImports;
  List<ImportStatement> programImports=result.programImports;
  Sketch sketch=result.sketch=editor.getSketch();
  String className=result.className=sketch.getName();
  StringBuilder workBuffer=new StringBuilder();
  IntList tabStartsList=new IntList();
  for (  SketchCode sc : sketch.getCode()) {
    if (sc.isExtension("pde")) {
      tabStartsList.append(workBuffer.length());
      if (sketch.getCurrentCode().equals(sc)) {
        try {
          workBuffer.append(sc.getDocumentText());
        }
 catch (        BadLocationException e) {
          e.printStackTrace();
        }
      }
 else {
        workBuffer.append(sc.getProgram());
      }
      workBuffer.append('\n');
    }
  }
  result.tabStarts=tabStartsList.array();
  String pdeStage=result.pdeCode=workBuffer.toString();
  String syntaxStage;
  String javaStage;
{
    PdePreprocessor p=editor.createPreprocessor(null);
    String[] defaultImports=p.getDefaultImports();
    String[] coreImports=p.getCoreImports();
    for (    String imp : coreImports) {
      coreAndDefaultImports.add(ImportStatement.parse(imp));
    }
    for (    String imp : defaultImports) {
      coreAndDefaultImports.add(ImportStatement.parse(imp));
    }
  }
  if (sketch.hasCodeFolder()) {
    File codeFolder=sketch.getCodeFolder();
    String codeFolderClassPath=Util.contentsToClassPath(codeFolder);
    StringList codeFolderPackages=Util.packageListFromClassPath(codeFolderClassPath);
    for (    String item : codeFolderPackages) {
      codeFolderImports.add(ImportStatement.wholePackage(item));
    }
  }
  List<IProblem> syntaxProblems=Collections.emptyList();
  List<IProblem> compilationProblems=Collections.emptyList();
  CompilationUnit syntaxCU;
{
{
      try {
        SourceUtils.scrubCommentsAndStrings(workBuffer);
      }
 catch (      RuntimeException e) {
      }
      Mode mode=PdePreprocessor.parseMode(workBuffer);
      SourceMapping syntaxMapping=new SourceMapping();
      syntaxMapping.addAll(SourceUtils.insertImports(coreAndDefaultImports));
      syntaxMapping.addAll(SourceUtils.insertImports(codeFolderImports));
      syntaxMapping.addAll(SourceUtils.parseProgramImports(workBuffer,programImports));
      syntaxMapping.addAll(SourceUtils.replaceTypeConstructors(workBuffer));
      syntaxMapping.addAll(SourceUtils.replaceHexLiterals(workBuffer));
      syntaxMapping.addAll(SourceUtils.wrapSketch(mode,className,workBuffer.length()));
      syntaxStage=syntaxMapping.apply(pdeStage);
      syntaxCU=makeAST(parser,syntaxStage.toCharArray(),COMPILER_OPTIONS);
      syntaxProblems=Arrays.asList(syntaxCU.getProblems());
      result.mode=mode;
      result.syntaxMapping=syntaxMapping;
      result.compilationUnit=syntaxCU;
      result.preprocessedCode=syntaxStage;
      for (      IProblem problem : syntaxProblems) {
        if (problem.isError()) {
          result.hasSyntaxErrors=true;
        }
      }
    }
  }
  if (!result.hasSyntaxErrors) {
{
{
        SourceMapping compilationMapping=new SourceMapping();
        compilationMapping.addAll(SourceUtils.addPublicToTopLevelMethods(syntaxCU));
        compilationMapping.addAll(SourceUtils.replaceColorAndFixFloats(syntaxCU));
        javaStage=compilationMapping.apply(syntaxStage);
        char[] javaStageChars=javaStage.toCharArray();
        CompilationUnit compilationCU=makeAST(parser,javaStageChars,COMPILER_OPTIONS);
        final URLClassLoader classLoader;
        final ClassPath classPath;
        boolean importsChanged=prevResult == null || prevResult.classPath == null || prevResult.classLoader == null || checkIfImportsChanged(programImports,prevResult.programImports) || checkIfImportsChanged(codeFolderImports,prevResult.codeFolderImports);
        if (!importsChanged) {
          classLoader=result.classLoader=prevResult.classLoader;
          classPath=prevResult.classPath;
        }
 else {
          List<String> paths=prepareCompilerClasspath(programImports,sketch);
          List<URL> urls=new ArrayList<>();
          for (Iterator<String> it=paths.iterator(); it.hasNext(); ) {
            String path=it.next();
            try {
              urls.add(new File(path).toURI().toURL());
            }
 catch (            MalformedURLException e) {
              it.remove();
            }
          }
          URL[] classPathArray=urls.toArray(new URL[urls.size()]);
          classLoader=result.classLoader=new URLClassLoader(classPathArray,null);
          String[] pathArray=paths.toArray(new String[paths.size()]);
          classPath=classPathFactory.createFromPaths(pathArray);
        }
        try {
          compilationProblems=compileAndReturnProblems(className,javaStageChars,COMPILER_OPTIONS,classLoader);
        }
 catch (        NoClassDefFoundError e) {
          e.printStackTrace();
        }
        result.compilationMapping=compilationMapping;
        result.classPath=classPath;
        result.classLoader=classLoader;
        result.preprocessedCode=javaStage;
        result.compilationUnit=compilationCU;
        for (        IProblem problem : compilationProblems) {
          if (problem.isError()) {
            result.hasCompilationErrors=true;
          }
        }
      }
    }
  }
  List<Problem> mappedSyntaxProblems=mapProblems(syntaxProblems,result.tabStarts,result.pdeCode,result.syntaxMapping);
  List<Problem> mappedCompilationProblems=mapProblems(compilationProblems,result.tabStarts,result.pdeCode,result.compilationMapping,result.syntaxMapping);
  result.problems.addAll(mappedSyntaxProblems);
  result.problems.addAll(mappedCompilationProblems);
  return result;
}

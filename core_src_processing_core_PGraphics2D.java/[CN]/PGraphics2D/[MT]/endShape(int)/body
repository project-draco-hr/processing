{
  if (untransformed()) {
    for (int i=0; i < vertexCount; i++) {
      vertices[i][TX]=vertices[i][X];
      vertices[i][TY]=vertices[i][Y];
    }
  }
 else {
    for (int i=0; i < vertexCount; i++) {
      vertices[i][TX]=ctm.multX(vertices[i][X],vertices[i][Y]);
      vertices[i][TX]=ctm.multY(vertices[i][X],vertices[i][Y]);
    }
  }
  fpolygon.texture(textureImage);
  spolygon.interpARGB=true;
  fpolygon.interpARGB=true;
  int increment;
switch (shape) {
case POINTS:
    if ((ctm.m00 == ctm.m11) && (strokeWeight == 1)) {
      for (int i=0; i < vertexCount; i++) {
        thin_point(vertices[i][TX],vertices[i][TY],strokeColor);
      }
    }
 else {
      for (int i=0; i < vertexCount; i++) {
        float[] v=vertices[i];
        thick_point(v[TX],v[TY],v[TZ],v[SR],v[SG],v[SB],v[SA]);
      }
    }
  break;
case LINES:
if (stroke) {
  increment=(shape == LINES) ? 2 : 1;
  draw_lines(vertices,vertexCount - 1,1,increment,0);
}
break;
case TRIANGLES:
case TRIANGLE_STRIP:
increment=(shape == TRIANGLES) ? 3 : 1;
if (fill) {
fpolygon.vertexCount=3;
for (int i=0; i < vertexCount - 2; i+=increment) {
for (int j=0; j < 3; j++) {
fpolygon.vertices[j][R]=vertices[i + j][R];
fpolygon.vertices[j][G]=vertices[i + j][G];
fpolygon.vertices[j][B]=vertices[i + j][B];
fpolygon.vertices[j][A]=vertices[i + j][A];
fpolygon.vertices[j][TX]=vertices[i + j][TX];
fpolygon.vertices[j][TY]=vertices[i + j][TY];
fpolygon.vertices[j][TZ]=vertices[i + j][TZ];
if (textureImage != null) {
  fpolygon.vertices[j][U]=vertices[i + j][U];
  fpolygon.vertices[j][V]=vertices[i + j][V];
}
}
fpolygon.render();
}
}
if (stroke) {
if (shape == TRIANGLE_STRIP) {
draw_lines(vertices,vertexCount - 1,1,1,0);
}
 else {
draw_lines(vertices,vertexCount - 1,1,1,3);
}
draw_lines(vertices,vertexCount - 2,2,increment,0);
}
break;
case QUADS:
case QUAD_STRIP:
increment=(shape == QUADS) ? 4 : 2;
if (fill) {
fpolygon.vertexCount=4;
for (int i=0; i < vertexCount - 3; i+=increment) {
for (int j=0; j < 4; j++) {
fpolygon.vertices[j][R]=vertices[i + j][R];
fpolygon.vertices[j][G]=vertices[i + j][G];
fpolygon.vertices[j][B]=vertices[i + j][B];
fpolygon.vertices[j][A]=vertices[i + j][A];
fpolygon.vertices[j][TX]=vertices[i + j][TX];
fpolygon.vertices[j][TY]=vertices[i + j][TY];
fpolygon.vertices[j][TZ]=vertices[i + j][TZ];
if (textureImage != null) {
fpolygon.vertices[j][U]=vertices[i + j][U];
fpolygon.vertices[j][V]=vertices[i + j][V];
}
}
fpolygon.render();
}
}
if (stroke) {
if (shape == QUAD_STRIP) {
draw_lines(vertices,vertexCount - 1,1,1,0);
}
 else {
draw_lines(vertices,vertexCount,1,1,4);
}
draw_lines(vertices,vertexCount - 2,3,increment,0);
}
break;
case POLYGON:
if (isConvex()) {
if (fill) {
fpolygon.renderPolygon(vertices,vertexCount);
}
if (stroke) {
draw_lines(vertices,vertexCount - 1,1,1,0);
svertices[0]=vertices[vertexCount - 1];
svertices[1]=vertices[0];
draw_lines(svertices,1,1,1,0);
}
}
 else {
if (fill) {
boolean smoov=smooth;
if (stroke) smooth=false;
concaveRender();
if (stroke) smooth=smoov;
}
if (stroke) {
draw_lines(vertices,vertexCount - 1,1,1,0);
if (mode == CLOSE) {
svertices[0]=vertices[vertexCount - 1];
svertices[1]=vertices[0];
draw_lines(svertices,1,1,1,0);
}
}
}
break;
}
shape=0;
}

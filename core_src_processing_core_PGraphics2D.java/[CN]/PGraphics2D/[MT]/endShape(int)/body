{
  if (ctm.isIdentity()) {
    for (int i=0; i < vertexCount; i++) {
      vertices[i][TX]=vertices[i][X];
      vertices[i][TY]=vertices[i][Y];
    }
  }
 else {
    for (int i=0; i < vertexCount; i++) {
      vertices[i][TX]=ctm.multX(vertices[i][X],vertices[i][Y]);
      vertices[i][TY]=ctm.multY(vertices[i][X],vertices[i][Y]);
    }
  }
  fpolygon.texture(textureImage);
  spolygon.interpARGB=true;
  fpolygon.interpARGB=true;
  int increment;
switch (shape) {
case POINTS:
    if (stroke) {
      if ((ctm.m00 == ctm.m11) && (strokeWeight == 1)) {
        for (int i=0; i < vertexCount; i++) {
          thin_point(vertices[i][TX],vertices[i][TY],strokeColor);
        }
      }
 else {
        for (int i=0; i < vertexCount; i++) {
          float[] v=vertices[i];
          thick_point(v[TX],v[TY],v[TZ],v[SR],v[SG],v[SB],v[SA]);
        }
      }
    }
  break;
case LINES:
if (stroke) {
  increment=(shape == LINES) ? 2 : 1;
  draw_lines(vertices,vertexCount - 1,1,increment,0);
}
break;
case TRIANGLE_FAN:
if (fill) {
fpolygon.vertexCount=3;
for (int i=1; i < vertexCount - 1; i++) {
fpolygon.vertices[2][R]=vertices[0][R];
fpolygon.vertices[2][G]=vertices[0][G];
fpolygon.vertices[2][B]=vertices[0][B];
fpolygon.vertices[2][A]=vertices[0][A];
fpolygon.vertices[2][TX]=vertices[0][TX];
fpolygon.vertices[2][TY]=vertices[0][TY];
if (textureImage != null) {
  fpolygon.vertices[2][U]=vertices[0][U];
  fpolygon.vertices[2][V]=vertices[0][V];
}
for (int j=0; j < 2; j++) {
  fpolygon.vertices[j][R]=vertices[i + j][R];
  fpolygon.vertices[j][G]=vertices[i + j][G];
  fpolygon.vertices[j][B]=vertices[i + j][B];
  fpolygon.vertices[j][A]=vertices[i + j][A];
  fpolygon.vertices[j][TX]=vertices[i + j][TX];
  fpolygon.vertices[j][TY]=vertices[i + j][TY];
  if (textureImage != null) {
    fpolygon.vertices[j][U]=vertices[i + j][U];
    fpolygon.vertices[j][V]=vertices[i + j][V];
  }
}
fpolygon.render();
}
}
if (stroke) {
for (int i=1; i < vertexCount; i++) {
draw_line(vertices[0],vertices[i]);
}
for (int i=1; i < vertexCount - 1; i++) {
draw_line(vertices[i],vertices[i + 1]);
}
draw_line(vertices[vertexCount - 1],vertices[1]);
}
break;
case TRIANGLES:
case TRIANGLE_STRIP:
increment=(shape == TRIANGLES) ? 3 : 1;
if (fill) {
fpolygon.vertexCount=3;
for (int i=0; i < vertexCount - 2; i+=increment) {
for (int j=0; j < 3; j++) {
fpolygon.vertices[j][R]=vertices[i + j][R];
fpolygon.vertices[j][G]=vertices[i + j][G];
fpolygon.vertices[j][B]=vertices[i + j][B];
fpolygon.vertices[j][A]=vertices[i + j][A];
fpolygon.vertices[j][TX]=vertices[i + j][TX];
fpolygon.vertices[j][TY]=vertices[i + j][TY];
fpolygon.vertices[j][TZ]=vertices[i + j][TZ];
if (textureImage != null) {
fpolygon.vertices[j][U]=vertices[i + j][U];
fpolygon.vertices[j][V]=vertices[i + j][V];
}
}
fpolygon.render();
}
}
if (stroke) {
if (shape == TRIANGLE_STRIP) {
draw_lines(vertices,vertexCount - 1,1,1,0);
}
 else {
draw_lines(vertices,vertexCount - 1,1,1,3);
}
draw_lines(vertices,vertexCount - 2,2,increment,0);
}
break;
case QUADS:
if (fill) {
fpolygon.vertexCount=4;
for (int i=0; i < vertexCount - 3; i+=4) {
for (int j=0; j < 4; j++) {
int jj=i + j;
if (j == 2) jj=i + 3;
if (j == 3) jj=i + 2;
fpolygon.vertices[j][R]=vertices[jj][R];
fpolygon.vertices[j][G]=vertices[jj][G];
fpolygon.vertices[j][B]=vertices[jj][B];
fpolygon.vertices[j][A]=vertices[jj][A];
fpolygon.vertices[j][TX]=vertices[jj][TX];
fpolygon.vertices[j][TY]=vertices[jj][TY];
fpolygon.vertices[j][TZ]=vertices[jj][TZ];
if (textureImage != null) {
fpolygon.vertices[j][U]=vertices[jj][U];
fpolygon.vertices[j][V]=vertices[jj][V];
}
}
fpolygon.render();
}
}
if (stroke) {
draw_lines(vertices,vertexCount - 1,1,2,4);
draw_lines(vertices,vertexCount - 1,2,4,0);
for (int i=1; i < vertexCount - 2; i+=4) {
draw_line(vertices[i],vertices[i + 2]);
}
}
break;
case QUAD_STRIP:
if (fill) {
fpolygon.vertexCount=4;
for (int i=0; i < vertexCount - 3; i+=2) {
for (int j=0; j < 4; j++) {
int jj=i + j;
if (j == 2) jj=i + 3;
if (j == 3) jj=i + 2;
fpolygon.vertices[j][R]=vertices[jj][R];
fpolygon.vertices[j][G]=vertices[jj][G];
fpolygon.vertices[j][B]=vertices[jj][B];
fpolygon.vertices[j][A]=vertices[jj][A];
fpolygon.vertices[j][TX]=vertices[jj][TX];
fpolygon.vertices[j][TY]=vertices[jj][TY];
fpolygon.vertices[j][TZ]=vertices[jj][TZ];
if (textureImage != null) {
fpolygon.vertices[j][U]=vertices[jj][U];
fpolygon.vertices[j][V]=vertices[jj][V];
}
}
fpolygon.render();
}
}
if (stroke) {
draw_lines(vertices,vertexCount - 1,1,2,0);
draw_lines(vertices,vertexCount - 2,2,1,0);
}
break;
case POLYGON:
if (isConvex()) {
if (fill) {
fpolygon.renderPolygon(vertices,vertexCount);
}
if (stroke) {
draw_lines(vertices,vertexCount - 1,1,1,0);
if (mode == CLOSE) {
draw_line(vertices[vertexCount - 1],vertices[0]);
}
}
}
 else {
if (fill) {
boolean smoov=smooth;
if (stroke) smooth=false;
concaveRender();
if (stroke) smooth=smoov;
}
if (stroke) {
draw_lines(vertices,vertexCount - 1,1,1,0);
if (mode == CLOSE) {
draw_line(vertices[vertexCount - 1],vertices[0]);
}
}
}
break;
}
shape=0;
}

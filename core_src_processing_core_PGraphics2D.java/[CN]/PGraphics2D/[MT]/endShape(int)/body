{
  int polyVertexCount=polygon.vertexCount;
  float polyVertices[][]=polygon.vertices;
  if (untransformed()) {
    for (int i=0; i < polyVertexCount; i++) {
      polyVertices[i][TX]=polyVertices[i][X];
      polyVertices[i][TY]=polyVertices[i][Y];
    }
  }
 else {
    for (int i=0; i < polyVertexCount; i++) {
      polyVertices[i][TX]=ctm.multX(polyVertices[i][X],polyVertices[i][Y]);
      polyVertices[i][TX]=ctm.multY(polyVertices[i][X],polyVertices[i][Y]);
    }
  }
  if (polygon.interpUV) {
    fpolygon.texture(textureImage);
  }
  spolygon.interpARGB=strokeChanged;
  fpolygon.interpARGB=fillChanged;
  int increment;
switch (shape) {
case POINTS:
    if (untransformed() && (strokeWeight == 1)) {
      if (!strokeChanged) {
        for (int i=0; i < polyVertexCount; i++) {
          thin_point((int)polyVertices[i][TX],(int)polyVertices[i][TY],0,strokeColor);
        }
      }
 else {
        for (int i=0; i < polyVertexCount; i++) {
          thin_point((int)polyVertices[i][TX],(int)polyVertices[i][TY],0,float_color(polyVertices[i][SR],polyVertices[i][SG],polyVertices[i][SB]));
        }
      }
    }
 else {
      float f[]=polyVertices[0];
      for (int i=0; i < polyVertexCount; i++) {
        float v[]=polyVertices[i];
        if ((i == 0) || strokeChanged) {
          calc_lighting(v[SR],v[SG],v[SB],v[TX],v[TY],v[TZ],v[NX],v[NY],v[NZ],f,R);
        }
        thick_point(v[TX],v[TY],v[TZ],f[R],f[G],f[B],f[SA]);
      }
    }
  break;
case LINES:
if (!stroke) return;
if (mode == CLOSE) {
float v0[]=polygon.vertices[0];
float v1[]=polygon.nextVertex();
polyVertexCount++;
v1[TX]=v0[TX];
v1[TY]=v0[TY];
v1[TZ]=v0[TZ];
v1[SR]=v0[SR];
v1[SG]=v0[SG];
v1[SB]=v0[SB];
}
increment=(shape == LINES) ? 2 : 1;
draw_lines(polyVertices,polyVertexCount - 1,1,increment,0);
break;
case TRIANGLES:
case TRIANGLE_STRIP:
increment=(shape == TRIANGLES) ? 3 : 1;
if (fill) {
fpolygon.vertexCount=3;
for (int i=0; i < polyVertexCount - 2; i+=increment) {
for (int j=0; j < 3; j++) {
fpolygon.vertices[j][R]=polyVertices[i + j][R];
fpolygon.vertices[j][G]=polyVertices[i + j][G];
fpolygon.vertices[j][B]=polyVertices[i + j][B];
fpolygon.vertices[j][A]=polyVertices[i + j][A];
fpolygon.vertices[j][TX]=polyVertices[i + j][TX];
fpolygon.vertices[j][TY]=polyVertices[i + j][TY];
fpolygon.vertices[j][TZ]=polyVertices[i + j][TZ];
if (polygon.interpUV) {
fpolygon.vertices[j][U]=polyVertices[i + j][U];
fpolygon.vertices[j][V]=polyVertices[i + j][V];
}
}
fpolygon.render();
}
}
if (stroke) {
if (shape == TRIANGLE_STRIP) {
draw_lines(polyVertices,polyVertexCount - 1,1,1,0);
}
 else {
draw_lines(polyVertices,polyVertexCount - 1,1,1,3);
}
draw_lines(polyVertices,polyVertexCount - 2,2,increment,0);
}
break;
case QUADS:
case QUAD_STRIP:
increment=(shape == QUADS) ? 4 : 2;
if (fill) {
fpolygon.vertexCount=4;
for (int i=0; i < polyVertexCount - 3; i+=increment) {
for (int j=0; j < 4; j++) {
fpolygon.vertices[j][R]=polyVertices[i + j][R];
fpolygon.vertices[j][G]=polyVertices[i + j][G];
fpolygon.vertices[j][B]=polyVertices[i + j][B];
fpolygon.vertices[j][A]=polyVertices[i + j][A];
fpolygon.vertices[j][TX]=polyVertices[i + j][TX];
fpolygon.vertices[j][TY]=polyVertices[i + j][TY];
fpolygon.vertices[j][TZ]=polyVertices[i + j][TZ];
if (polygon.interpUV) {
fpolygon.vertices[j][U]=polyVertices[i + j][U];
fpolygon.vertices[j][V]=polyVertices[i + j][V];
}
}
fpolygon.render();
}
}
if (stroke) {
if (shape == QUAD_STRIP) {
draw_lines(polyVertices,polyVertexCount - 1,1,1,0);
}
 else {
draw_lines(polyVertices,polyVertexCount,1,1,4);
}
draw_lines(polyVertices,polyVertexCount - 2,3,increment,0);
}
break;
case POLYGON:
if (isConvex()) {
if (fill) {
polygon.render();
if (stroke) polygon.unexpand();
}
if (stroke) {
draw_lines(polyVertices,polyVertexCount - 1,1,1,0);
svertices[0]=polyVertices[polyVertexCount - 1];
svertices[1]=polyVertices[0];
draw_lines(svertices,1,1,1,0);
}
}
 else {
if (fill) {
boolean smoov=smooth;
if (stroke) smooth=false;
concaveRender();
if (stroke) smooth=smoov;
}
if (stroke) {
draw_lines(polyVertices,polyVertexCount - 1,1,1,0);
svertices[0]=polyVertices[polyVertexCount - 1];
svertices[1]=polyVertices[0];
draw_lines(svertices,1,1,1,0);
}
}
break;
}
shape=0;
}

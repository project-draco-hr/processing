{
  int position=-1;
  int adjustment=0;
  boolean tryAgain=false;
  for (; ; ) {
synchronized (lock) {
      if (v.size() > 0) {
        RecolorEvent re=(RecolorEvent)(v.elementAt(0));
        v.removeElementAt(0);
        position=re.position;
        adjustment=re.adjustment;
      }
 else {
        tryAgain=false;
        position=-1;
        adjustment=0;
      }
    }
    if (position != -1) {
      SortedSet workingSet;
      Iterator workingIt;
      DocPosition startRequest=new DocPosition(position);
      DocPosition endRequest=new DocPosition(position + ((adjustment >= 0) ? adjustment : -adjustment));
      DocPosition dp;
      DocPosition dpStart=null;
      DocPosition dpEnd=null;
      try {
        workingSet=iniPositions.headSet(startRequest);
        dpStart=((DocPosition)workingSet.last());
      }
 catch (      NoSuchElementException x) {
        dpStart=new DocPosition(0);
      }
      if (adjustment < 0) {
        workingSet=iniPositions.subSet(startRequest,endRequest);
        workingIt=workingSet.iterator();
        while (workingIt.hasNext()) {
          workingIt.next();
          workingIt.remove();
        }
      }
      workingSet=iniPositions.tailSet(startRequest);
      workingIt=workingSet.iterator();
      while (workingIt.hasNext()) {
        ((DocPosition)workingIt.next()).adjustPosition(adjustment);
      }
      workingSet=iniPositions.tailSet(dpStart);
      workingIt=workingSet.iterator();
      dp=null;
      if (workingIt.hasNext()) {
        dp=(DocPosition)workingIt.next();
      }
      try {
        Token t;
        boolean done=false;
        dpEnd=dpStart;
synchronized (doclock) {
          syntaxLexer.reset(documentReader,0,dpStart.getPosition(),0);
          documentReader.seek(dpStart.getPosition());
          t=syntaxLexer.getNextToken();
        }
        newPositions.add(dpStart);
        while (!done && t != null) {
synchronized (doclock) {
            if (t.getCharEnd() <= document.getLength()) {
              document.setCharacterAttributes(t.getCharBegin() + change,t.getCharEnd() - t.getCharBegin(),getStyle(t.getDescription()),true);
              dpEnd=new DocPosition(t.getCharEnd());
            }
            lastPosition=(t.getCharEnd() + change);
          }
          if (t.getState() == Token.INITIAL_STATE) {
            while (dp != null && dp.getPosition() <= t.getCharEnd()) {
              if (dp.getPosition() == t.getCharEnd() && dp.getPosition() >= endRequest.getPosition()) {
                done=true;
                dp=null;
              }
 else               if (workingIt.hasNext()) {
                dp=(DocPosition)workingIt.next();
              }
 else {
                dp=null;
              }
            }
            newPositions.add(dpEnd);
          }
synchronized (doclock) {
            t=syntaxLexer.getNextToken();
          }
        }
        workingIt=iniPositions.subSet(dpStart,dpEnd).iterator();
        while (workingIt.hasNext()) {
          workingIt.next();
          workingIt.remove();
        }
        workingIt=iniPositions.tailSet(new DocPosition(document.getLength())).iterator();
        while (workingIt.hasNext()) {
          workingIt.next();
          workingIt.remove();
        }
        iniPositions.addAll(newPositions);
        newPositions.clear();
      }
 catch (      IOException x) {
      }
synchronized (doclock) {
        lastPosition=-1;
        change=0;
      }
      tryAgain=true;
    }
    asleep=true;
    if (!tryAgain) {
      try {
        sleep(0xffffff);
      }
 catch (      InterruptedException x) {
      }
    }
    asleep=false;
  }
}

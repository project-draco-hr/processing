{
  if (vertices == null)   return;
  inGeo.setMaterial(fillColor,strokeColor,strokeWeight,ambientColor,specularColor,emissiveColor,shininess);
  if (vertexCodeCount == 0) {
    if (vertices[0].length == 2) {
      for (int i=0; i < vertexCount; i++) {
        inGeo.addVertex(vertices[i][X],vertices[i][Y],VERTEX);
      }
    }
 else {
      for (int i=0; i < vertexCount; i++) {
        inGeo.addVertex(vertices[i][X],vertices[i][Y],vertices[i][Z],VERTEX);
      }
    }
  }
 else {
    int idx=0;
    int code=BREAK;
    if (vertices[0].length == 2) {
      for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
          inGeo.addVertex(vertices[idx][X],vertices[idx][Y],code);
        code=VERTEX;
      idx++;
    break;
case QUADRATIC_VERTEX:
  inGeo.addQuadraticVertex(vertices[idx + 0][X],vertices[idx + 0][Y],0,vertices[idx + 1][X],vertices[idx + 1][Y],0,fill,stroke,bezierDetail,code);
code=VERTEX;
idx+=2;
break;
case BEZIER_VERTEX:
inGeo.addBezierVertex(vertices[idx + 0][X],vertices[idx + 0][Y],0,vertices[idx + 1][X],vertices[idx + 1][Y],0,vertices[idx + 2][X],vertices[idx + 2][Y],0,fill,stroke,bezierDetail,code);
code=VERTEX;
idx+=3;
break;
case CURVE_VERTEX:
inGeo.addCurveVertex(vertices[idx][X],vertices[idx][Y],0,fill,stroke,curveDetail,code);
code=VERTEX;
idx++;
break;
case BREAK:
code=BREAK;
}
}
}
 else {
for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
inGeo.addVertex(vertices[idx][X],vertices[idx][Y],vertices[idx][Z],code);
code=VERTEX;
idx++;
break;
case QUADRATIC_VERTEX:
inGeo.addQuadraticVertex(vertices[idx + 0][X],vertices[idx + 0][Y],vertices[idx + 0][Z],vertices[idx + 1][X],vertices[idx + 1][Y],vertices[idx + 0][Z],fill,stroke,bezierDetail,code);
code=VERTEX;
idx+=2;
break;
case BEZIER_VERTEX:
inGeo.addBezierVertex(vertices[idx + 0][X],vertices[idx + 0][Y],vertices[idx + 0][Z],vertices[idx + 1][X],vertices[idx + 1][Y],vertices[idx + 1][Z],vertices[idx + 2][X],vertices[idx + 2][Y],vertices[idx + 2][Z],fill,stroke,bezierDetail,code);
code=VERTEX;
idx+=3;
break;
case CURVE_VERTEX:
inGeo.addCurveVertex(vertices[idx][X],vertices[idx][Y],vertices[idx][Z],fill,stroke,curveDetail,code);
code=VERTEX;
idx++;
break;
case BREAK:
code=BREAK;
}
}
}
}
if (stroke) inGeo.addPolygonEdges(close);
tessellator.tessellatePolygon(false,close,true);
}

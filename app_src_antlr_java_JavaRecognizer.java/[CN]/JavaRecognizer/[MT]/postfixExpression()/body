{
  returnAST=null;
  ASTPair currentAST=new ASTPair();
  AST postfixExpression_AST=null;
  Token lp=null;
  AST lp_AST=null;
  Token lp3=null;
  AST lp3_AST=null;
  Token lps=null;
  AST lps_AST=null;
  Token lb=null;
  AST lb_AST=null;
  Token in=null;
  AST in_AST=null;
  Token de=null;
  AST de_AST=null;
  primaryExpression();
  astFactory.addASTChild(currentAST,returnAST);
{
    _loop174:     do {
      if ((LA(1) == DOT) && (LA(2) == IDENT)) {
        AST tmp164_AST=null;
        tmp164_AST=astFactory.create(LT(1));
        astFactory.makeASTRoot(currentAST,tmp164_AST);
        match(DOT);
        AST tmp165_AST=null;
        tmp165_AST=astFactory.create(LT(1));
        astFactory.addASTChild(currentAST,tmp165_AST);
        match(IDENT);
{
switch (LA(1)) {
case LPAREN:
{
              lp=LT(1);
              lp_AST=astFactory.create(lp);
              astFactory.makeASTRoot(currentAST,lp_AST);
              match(LPAREN);
              if (inputState.guessing == 0) {
                lp_AST.setType(METHOD_CALL);
              }
              argList();
              astFactory.addASTChild(currentAST,returnAST);
              match(RPAREN);
              break;
            }
case SEMI:
case LBRACK:
case RBRACK:
case DOT:
case STAR:
case RCURLY:
case COMMA:
case RPAREN:
case ASSIGN:
case COLON:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case QUESTION:
case LOR:
case LAND:
case BOR:
case BXOR:
case BAND:
case NOT_EQUAL:
case EQUAL:
case LT:
case GT:
case LE:
case GE:
case LITERAL_instanceof:
case SL:
case SR:
case BSR:
case PLUS:
case MINUS:
case DIV:
case MOD:
case INC:
case DEC:
{
            break;
          }
default :
{
          throw new NoViableAltException(LT(1),getFilename());
        }
    }
  }
}
 else if ((LA(1) == DOT) && (LA(2) == LITERAL_this)) {
  AST tmp167_AST=null;
  tmp167_AST=astFactory.create(LT(1));
  astFactory.makeASTRoot(currentAST,tmp167_AST);
  match(DOT);
  AST tmp168_AST=null;
  tmp168_AST=astFactory.create(LT(1));
  astFactory.addASTChild(currentAST,tmp168_AST);
  match(LITERAL_this);
}
 else if ((LA(1) == DOT) && (LA(2) == LITERAL_super)) {
  AST tmp169_AST=null;
  tmp169_AST=astFactory.create(LT(1));
  astFactory.makeASTRoot(currentAST,tmp169_AST);
  match(DOT);
  AST tmp170_AST=null;
  tmp170_AST=astFactory.create(LT(1));
  astFactory.addASTChild(currentAST,tmp170_AST);
  match(LITERAL_super);
{
switch (LA(1)) {
case LPAREN:
{
        lp3=LT(1);
        lp3_AST=astFactory.create(lp3);
        astFactory.makeASTRoot(currentAST,lp3_AST);
        match(LPAREN);
        argList();
        astFactory.addASTChild(currentAST,returnAST);
        match(RPAREN);
        if (inputState.guessing == 0) {
          lp3_AST.setType(SUPER_CTOR_CALL);
        }
        break;
      }
case DOT:
{
      AST tmp172_AST=null;
      tmp172_AST=astFactory.create(LT(1));
      astFactory.makeASTRoot(currentAST,tmp172_AST);
      match(DOT);
      AST tmp173_AST=null;
      tmp173_AST=astFactory.create(LT(1));
      astFactory.addASTChild(currentAST,tmp173_AST);
      match(IDENT);
{
switch (LA(1)) {
case LPAREN:
{
            lps=LT(1);
            lps_AST=astFactory.create(lps);
            astFactory.makeASTRoot(currentAST,lps_AST);
            match(LPAREN);
            if (inputState.guessing == 0) {
              lps_AST.setType(METHOD_CALL);
            }
            argList();
            astFactory.addASTChild(currentAST,returnAST);
            match(RPAREN);
            break;
          }
case SEMI:
case LBRACK:
case RBRACK:
case DOT:
case STAR:
case RCURLY:
case COMMA:
case RPAREN:
case ASSIGN:
case COLON:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case QUESTION:
case LOR:
case LAND:
case BOR:
case BXOR:
case BAND:
case NOT_EQUAL:
case EQUAL:
case LT:
case GT:
case LE:
case GE:
case LITERAL_instanceof:
case SL:
case SR:
case BSR:
case PLUS:
case MINUS:
case DIV:
case MOD:
case INC:
case DEC:
{
          break;
        }
default :
{
        throw new NoViableAltException(LT(1),getFilename());
      }
  }
}
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
}
 else if ((LA(1) == DOT) && (LA(2) == LITERAL_new)) {
AST tmp175_AST=null;
tmp175_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp175_AST);
match(DOT);
newExpression();
astFactory.addASTChild(currentAST,returnAST);
}
 else if ((LA(1) == LBRACK)) {
lb=LT(1);
lb_AST=astFactory.create(lb);
astFactory.makeASTRoot(currentAST,lb_AST);
match(LBRACK);
if (inputState.guessing == 0) {
lb_AST.setType(INDEX_OP);
}
expression();
astFactory.addASTChild(currentAST,returnAST);
match(RBRACK);
}
 else {
break _loop174;
}
}
 while (true);
}
{
switch (LA(1)) {
case INC:
{
in=LT(1);
in_AST=astFactory.create(in);
astFactory.makeASTRoot(currentAST,in_AST);
match(INC);
if (inputState.guessing == 0) {
in_AST.setType(POST_INC);
}
break;
}
case DEC:
{
de=LT(1);
de_AST=astFactory.create(de);
astFactory.makeASTRoot(currentAST,de_AST);
match(DEC);
if (inputState.guessing == 0) {
de_AST.setType(POST_DEC);
}
break;
}
case SEMI:
case RBRACK:
case STAR:
case RCURLY:
case COMMA:
case RPAREN:
case ASSIGN:
case COLON:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case QUESTION:
case LOR:
case LAND:
case BOR:
case BXOR:
case BAND:
case NOT_EQUAL:
case EQUAL:
case LT:
case GT:
case LE:
case GE:
case LITERAL_instanceof:
case SL:
case SR:
case BSR:
case PLUS:
case MINUS:
case DIV:
case MOD:
{
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
postfixExpression_AST=(AST)currentAST.root;
returnAST=postfixExpression_AST;
}

{
  if (mode == LINES) {
  }
 else   if (mode == TRIANGLES) {
  }
  int ni=0;
  for (int i=0; i < gcount; i++) {
    indicesTemp[ni++]=indices[i][VERTEX1];
    indicesTemp[ni++]=indices[i][VERTEX2];
    indicesTemp[ni++]=indices[i][VERTEX2];
  }
  int nv=0;
  int nn=0;
  int nc=0;
  int nt=0;
  float x, y, z;
  float nx, ny, nz;
  float[] vert;
  for (int i=0; i < vcount; i++) {
    vert=vertices[i];
    x=vert[X];
    y=vert[Y];
    z=vert[Z];
    nx=vert[NX];
    ny=vert[NY];
    nz=vert[NZ];
    if (mm == null) {
      verticesTemp[nv++]=x;
      verticesTemp[nv++]=y;
      verticesTemp[nv++]=z;
      normalsTemp[nn++]=nx;
      normalsTemp[nn++]=ny;
      normalsTemp[nn++]=nz;
    }
 else {
      verticesTemp[nv++]=x * mm[0] + y * mm[4] + z * mm[8] + mm[12];
      verticesTemp[nv++]=x * mm[1] + y * mm[5] + z * mm[9] + mm[13];
      verticesTemp[nv++]=x * mm[2] + y * mm[6] + z * mm[10] + mm[14];
      normalsTemp[nn++]=nx + mm[12];
      normalsTemp[nn++]=ny + mm[13];
      normalsTemp[nn++]=nz + mm[14];
    }
    colorsTemp[nc++]=vert[R];
    colorsTemp[nc++]=vert[G];
    colorsTemp[nc++]=vert[B];
    colorsTemp[nc++]=vert[A];
    if (1 < texCount) {
      float[] vertU=vertexU[i];
      float[] vertV=vertexU[i];
      for (int t=0; t < texCount; t++) {
        texcoordsTemp[nt++][t]=vertU[t];
        texcoordsTemp[nt++][t]=vertV[t];
      }
    }
 else     if (0 < texCount) {
      texcoordsTemp[nt++][0]=vert[U];
      texcoordsTemp[nt++][0]=vert[V];
    }
  }
  indicesBuffer.put(indicesTemp,0,3 * gcount);
}

{
  int gcount=i1 - i0 + 1;
  int vcount=v1 - v0 + 1;
  while (indicesBuffer.capacity() < idxCount + 3 * gcount) {
    int newSize=indicesBuffer.capacity() << 1;
    ByteBuffer ibb=ByteBuffer.allocateDirect(newSize * SIZEOF_INT);
    ibb.order(ByteOrder.nativeOrder());
    indicesBuffer=ibb.asIntBuffer();
    indicesArray=new int[newSize];
  }
  while (verticesBuffer.capacity() / 3 < vertCount + vcount) {
    int newSize=verticesBuffer.capacity() / 3 << 1;
    ByteBuffer vbb=ByteBuffer.allocateDirect(newSize * 3 * SIZEOF_FLOAT);
    vbb.order(ByteOrder.nativeOrder());
    verticesBuffer=vbb.asFloatBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(newSize * 4 * SIZEOF_FLOAT);
    cbb.order(ByteOrder.nativeOrder());
    colorsBuffer=cbb.asFloatBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(newSize * 3 * SIZEOF_FLOAT);
    nbb.order(ByteOrder.nativeOrder());
    normalsBuffer=nbb.asFloatBuffer();
    for (int t=0; t < texCount; t++) {
      ByteBuffer tbb=ByteBuffer.allocateDirect(newSize * 2 * SIZEOF_FLOAT);
      tbb.order(ByteOrder.nativeOrder());
      texcoordsBuffer[t]=tbb.asFloatBuffer();
    }
    verticesArray=new float[newSize * 3];
    colorsArray=new float[newSize * 4];
    normalsArray=new float[newSize * 3];
    for (int t=0; t < texCount; t++) {
      texcoordsArray[t]=new float[newSize * 2];
    }
  }
  int ni=0;
  for (int i=i0; i <= i1; i++) {
    indicesArray[ni++]=vertCount + indices[i][VERTEX1] - v0;
    indicesArray[ni++]=vertCount + indices[i][VERTEX2] - v0;
    indicesArray[ni++]=vertCount + indices[i][VERTEX3] - v0;
  }
  minVertIndex=vertCount;
  maxVertIndex=vertCount + v1 - v0;
  int nv=0;
  int nn=0;
  int nc=0;
  int nt=0;
  float x, y, z;
  float nx, ny, nz;
  float[] vert;
  for (int i=v0; i <= v1; i++) {
    vert=vertices[i];
    x=vert[X];
    y=vert[Y];
    z=vert[Z];
    nx=vert[NX];
    ny=vert[NY];
    nz=vert[NZ];
    if (mm == null) {
      verticesArray[nv++]=x;
      verticesArray[nv++]=y;
      verticesArray[nv++]=z;
      normalsArray[nn++]=nx;
      normalsArray[nn++]=ny;
      normalsArray[nn++]=nz;
    }
 else {
      verticesArray[nv++]=x * mm[0] + y * mm[4] + z * mm[8] + mm[12];
      verticesArray[nv++]=x * mm[1] + y * mm[5] + z * mm[9] + mm[13];
      verticesArray[nv++]=x * mm[2] + y * mm[6] + z * mm[10] + mm[14];
      normalsArray[nn++]=nx + mm[12];
      normalsArray[nn++]=ny + mm[13];
      normalsArray[nn++]=nz + mm[14];
    }
    colorsArray[nc++]=vert[R];
    colorsArray[nc++]=vert[G];
    colorsArray[nc++]=vert[B];
    colorsArray[nc++]=vert[A];
    if (0 < texCount) {
      float[] vertU=vertexU[i];
      float[] vertV=vertexV[i];
      for (int t=0; t < texCount; t++) {
        float uscale=1.0f;
        float vscale=1.0f;
        float cx=0.0f;
        float sx=+1.0f;
        float cy=0.0f;
        float sy=+1.0f;
        PTexture tex=texturesArray[t];
        uscale*=tex.getMaxTexCoordU();
        vscale*=tex.getMaxTexCoordV();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
        texcoordsArray[t][nt++]=(cx + sx * vertU[t]) * uscale;
        texcoordsArray[t][nt++]=(cy + sy * vertV[t]) * vscale;
      }
    }
  }
  indicesBuffer.put(indicesArray,0,3 * gcount);
  verticesBuffer.put(verticesArray,0,3 * vcount);
  normalsBuffer.put(normalsArray,0,3 * vcount);
  colorsBuffer.put(colorsArray,0,4 * vcount);
  for (int t=0; t < texCount; t++) {
    texcoordsBuffer[t].put(texcoordsArray[t],0,2 * vcount);
  }
  idxCount+=3 * gcount;
  vertCount+=vcount;
}

{
  if (mode == LINES) {
  }
 else   if (mode == TRIANGLES) {
  }
  int gcount=i1 - i0 + 1;
  int vcount=v1 - v0 + 1;
  while (indicesBuffer.capacity() < idxCount + 3 * gcount) {
    int newSize=indicesBuffer.capacity() << 1;
    ByteBuffer ibb=ByteBuffer.allocateDirect(newSize * SIZEOF_INT);
    ibb.order(ByteOrder.nativeOrder());
    indicesBuffer=ibb.asIntBuffer();
    indicesArray=new int[newSize];
  }
  while (verticesBuffer.capacity() / 3 < vertCount + vcount) {
    int newSize=verticesBuffer.capacity() / 3 << 1;
    ByteBuffer vbb=ByteBuffer.allocateDirect(newSize * 3 * SIZEOF_FLOAT);
    vbb.order(ByteOrder.nativeOrder());
    verticesBuffer=vbb.asFloatBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(newSize * 4 * SIZEOF_FLOAT);
    cbb.order(ByteOrder.nativeOrder());
    colorsBuffer=cbb.asFloatBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(newSize * 3 * SIZEOF_FLOAT);
    nbb.order(ByteOrder.nativeOrder());
    normalsBuffer=nbb.asFloatBuffer();
    for (int t=0; t < texCount; t++) {
      ByteBuffer tbb=ByteBuffer.allocateDirect(newSize * 2 * SIZEOF_FLOAT);
      tbb.order(ByteOrder.nativeOrder());
      texcoordsBuffer[t]=tbb.asFloatBuffer();
    }
    verticesArray=new float[newSize * 3];
    colorsArray=new float[newSize * 4];
    normalsArray=new float[newSize * 3];
    for (int t=0; t < texCount; t++) {
      texcoordsArray[t]=new float[newSize * 2];
    }
  }
  int ni=0;
  for (int i=i0; i <= i1; i++) {
    indicesArray[ni++]=indices[i][VERTEX1];
    indicesArray[ni++]=indices[i][VERTEX2];
    indicesArray[ni++]=indices[i][VERTEX2];
  }
  int nv=0;
  int nn=0;
  int nc=0;
  int nt=0;
  float x, y, z;
  float nx, ny, nz;
  float[] vert;
  for (int i=v0; i <= v1; i++) {
    vert=vertices[i];
    x=vert[X];
    y=vert[Y];
    z=vert[Z];
    nx=vert[NX];
    ny=vert[NY];
    nz=vert[NZ];
    if (mm == null) {
      verticesArray[nv++]=x;
      verticesArray[nv++]=y;
      verticesArray[nv++]=z;
      normalsArray[nn++]=nx;
      normalsArray[nn++]=ny;
      normalsArray[nn++]=nz;
    }
 else {
      verticesArray[nv++]=x * mm[0] + y * mm[4] + z * mm[8] + mm[12];
      verticesArray[nv++]=x * mm[1] + y * mm[5] + z * mm[9] + mm[13];
      verticesArray[nv++]=x * mm[2] + y * mm[6] + z * mm[10] + mm[14];
      normalsArray[nn++]=nx + mm[12];
      normalsArray[nn++]=ny + mm[13];
      normalsArray[nn++]=nz + mm[14];
    }
    colorsArray[nc++]=vert[R];
    colorsArray[nc++]=vert[G];
    colorsArray[nc++]=vert[B];
    colorsArray[nc++]=vert[A];
    if (1 < texCount) {
      float[] vertU=vertexU[i];
      float[] vertV=vertexU[i];
      for (int t=0; t < texCount; t++) {
        texcoordsArray[nt++][t]=vertU[t];
        texcoordsArray[nt++][t]=vertV[t];
      }
    }
 else     if (0 < texCount) {
      texcoordsArray[nt++][0]=vert[U];
      texcoordsArray[nt++][0]=vert[V];
    }
  }
  indicesBuffer.put(indicesArray,0,3 * gcount);
  verticesBuffer.put(verticesArray,0,3 * vcount);
  normalsBuffer.put(normalsArray,0,3 * vcount);
  colorsBuffer.put(normalsArray,0,4 * vcount);
  for (int t=0; t < texCount; t++) {
    texcoordsBuffer[t].put(texcoordsArray[t],0,2 * vcount);
  }
  idxCount+=3 * gcount;
  vertCount+=vcount;
}

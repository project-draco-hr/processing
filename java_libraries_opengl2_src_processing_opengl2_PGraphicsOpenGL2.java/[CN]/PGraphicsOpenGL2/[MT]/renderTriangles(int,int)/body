{
  report("render_triangles in");
  int tcount=0;
  gl2f.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl2f.glEnableClientState(GL2.GL_COLOR_ARRAY);
  gl2f.glEnableClientState(GL2.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    PImage[] images=faceTextures[j];
    if (1 < numTextures) {
      for (int t=0; t < numTextures; t++) {
        if (images[t] != null) {
          PTexture tex=getTexture(images[t]);
          if (tex == null) {
            break;
          }
          gl.glEnable(tex.getGLTarget());
          gl.glActiveTexture(GL.GL_TEXTURE0 + t);
          gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
          renderTextures[tcount]=tex;
          tcount++;
        }
 else {
          break;
        }
      }
    }
 else     if (images[0] != null) {
      PTexture tex=getTexture(images[0]);
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL.GL_TEXTURE0);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[0]=tex;
        tcount=1;
      }
    }
    if (0 < tcount) {
      if (numTexBuffers < tcount) {
        addTexBuffers(tcount - numTexBuffers);
      }
      gl2f.glEnableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
      if (1 < tcount) {
        setupTextureBlend(renderTextures,tcount);
      }
    }
    if (gbuffer == null) {
      gbuffer=new GeometryBuffer();
    }
    gbuffer.init(TRIANGLES,renderTextures,tcount);
    gbuffer.add(triangles,i,i + faceLength[j] - 1,vertices,faceMinIndex[j],faceMaxIndex[j]);
    gbuffer.render();
    if (0 < tcount) {
      if (1 < tcount) {
        cleanupTextureBlend(tcount);
      }
      for (int t=0; t < tcount; t++) {
        PTexture tex=renderTextures[t];
        gl.glActiveTexture(GL.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),0);
      }
      for (int t=0; t < tcount; t++) {
        PTexture tex=renderTextures[t];
        gl.glDisable(tex.getGLTarget());
      }
      gl2f.glDisableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl2f.glDisableClientState(GL2.GL_NORMAL_ARRAY);
  gl2f.glDisableClientState(GL2.GL_COLOR_ARRAY);
  gl2f.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  report("render_triangles out");
}

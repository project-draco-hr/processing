{
  if (pg == null) {
    System.out.println(" setting pg and uniforms " + pg);
    setRenderer(PGraphicsOpenGL.pgCurrent);
    loadAttributes();
    loadUniforms();
  }
  setCommonUniforms();
  if (-1 < vertexLoc)   pgl.enableVertexAttribArray(vertexLoc);
  if (-1 < colorLoc)   pgl.enableVertexAttribArray(colorLoc);
  if (-1 < texCoordLoc)   pgl.enableVertexAttribArray(texCoordLoc);
  if (-1 < normalLoc)   pgl.enableVertexAttribArray(normalLoc);
  if (-1 < normalMatLoc) {
    pg.updateGLNormal();
    setUniformMatrix(normalMatLoc,pg.glNormal);
  }
  if (-1 < ambientLoc)   pgl.enableVertexAttribArray(ambientLoc);
  if (-1 < specularLoc)   pgl.enableVertexAttribArray(specularLoc);
  if (-1 < emissiveLoc)   pgl.enableVertexAttribArray(emissiveLoc);
  if (-1 < shininessLoc)   pgl.enableVertexAttribArray(shininessLoc);
  int count=pg.lightCount;
  setUniformValue(lightCountLoc,count);
  if (0 < count) {
    setUniformVector(lightPositionLoc,pg.lightPosition,4,count);
    setUniformVector(lightNormalLoc,pg.lightNormal,3,count);
    setUniformVector(lightAmbientLoc,pg.lightAmbient,3,count);
    setUniformVector(lightDiffuseLoc,pg.lightDiffuse,3,count);
    setUniformVector(lightSpecularLoc,pg.lightSpecular,3,count);
    setUniformVector(lightFalloffLoc,pg.lightFalloffCoefficients,3,count);
    setUniformVector(lightSpotLoc,pg.lightSpotParameters,2,count);
  }
  if (-1 < directionLoc)   pgl.enableVertexAttribArray(directionLoc);
  if (-1 < offsetLoc)   pgl.enableVertexAttribArray(offsetLoc);
  if (-1 < perspectiveLoc) {
    if (pg.getHint(ENABLE_STROKE_PERSPECTIVE) && pg.nonOrthoProjection()) {
      setUniformValue(perspectiveLoc,1);
    }
 else {
      setUniformValue(perspectiveLoc,0);
    }
  }
  if (-1 < scaleLoc) {
    if (pg.getHint(DISABLE_OPTIMIZED_STROKE)) {
      setUniformValue(scaleLoc,1.0f,1.0f,1.0f);
    }
 else {
      float f=PGL.STROKE_DISPLACEMENT;
      if (pg.orthoProjection()) {
        setUniformValue(scaleLoc,1,1,f);
      }
 else {
        setUniformValue(scaleLoc,f,f,f);
      }
    }
  }
}

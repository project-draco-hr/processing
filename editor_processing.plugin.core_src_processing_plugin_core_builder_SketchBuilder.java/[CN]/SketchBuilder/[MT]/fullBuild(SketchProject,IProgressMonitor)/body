{
  this.clean(sketchProject,monitor);
  IProject sketch=sketchProject.getProject();
  if (sketch == null || !sketch.isAccessible()) {
    System.out.println("Sketch is null!");
    return null;
  }
  codeFolder=sketch.getFolder("code");
  dataFolder=sketch.getFolder("data");
  buildFolder=sketch.getFolder("bin");
  appletFolder=sketch.getFolder("applet");
  monitor.beginTask("Sketch Build",400);
  if (!sketch.isOpen()) {
    return null;
  }
  if (checkCancel(monitor)) {
    return null;
  }
  if (!buildFolder.exists())   buildFolder.create(IResource.NONE,true,null);
  if (!appletFolder.exists())   appletFolder.create(IResource.NONE,true,null);
  monitor.worked(100);
  if (checkCancel(monitor)) {
    return null;
  }
  PdePreprocessor preproc=new PdePreprocessor(sketch.getName(),4);
  String[] codeFolderPackages=null;
  classPath=appletFolder.getLocation().toOSString();
  if (codeFolder.exists()) {
    libraryPath=codeFolder.getLocation().toOSString();
    String codeFolderClassPath=Utilities.contentsToClassPath(codeFolder.getLocation().toFile());
    classPath+=File.pathSeparator + codeFolderClassPath;
    codeFolderPackages=Utilities.packageListFromClassPath(codeFolderClassPath);
  }
 else {
    libraryPath="";
  }
  StringBuffer bigCode=new StringBuffer();
  int bigCount=0;
  for (  IResource file : sketch.members()) {
    if (file.getFileExtension() != null && file.getFileExtension().equalsIgnoreCase("pde")) {
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"),bigCount);
      String content=Utilities.readFile((IFile)file);
      bigCode.append(content);
      bigCode.append("\n");
      bigCount+=Utilities.getLineCount(content);
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"),bigCount);
    }
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  PreprocessResult result=null;
  try {
    IFile outputFile=buildFolder.getFile(sketch.getName() + ".java");
    StringWriter stream=new StringWriter();
    result=preproc.write(stream,bigCode.toString(),codeFolderPackages);
    ByteArrayInputStream inStream=new ByteArrayInputStream(stream.toString().getBytes());
    try {
      if (outputFile.exists()) {
        outputFile.setContents(inStream,true,false,monitor);
      }
 else {
        outputFile.create(inStream,true,monitor);
      }
      outputFile.setDerived(true,monitor);
    }
  finally {
      stream.close();
      inStream.close();
    }
  }
 catch (  antlr.RecognitionException re) {
    IResource errorFile=null;
    int errorLine=re.getLine() - 1;
    for (    IResource file : sketch.members()) {
      if (file.getFileExtension() != null && file.getFileExtension().equalsIgnoreCase("pde")) {
        int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
        int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
        if (low <= errorLine && high > errorLine) {
          errorFile=file;
          errorLine-=low;
          break;
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    String msg=re.getMessage();
    if (msg.equals("expecting RCURLY, found 'null'"))     msg="Found one too many { characters without a } to match it.";
    if (msg.indexOf("expecting RBRACK") != -1)     msg="Syntax error, maybe a missing right ] character?";
    if (msg.indexOf("expecting SEMI") != -1)     msg="Syntax error, maybe a missing semicolon?";
    if (msg.indexOf("expecting RPAREN") != -1)     msg="Syntax error, maybe a missing right parenthesis?";
    if (msg.indexOf("preproc.web_colors") != -1)     msg="A web color (such as #ffcc00) must be six digits.";
    reportProblem(msg,errorFile,errorLine,true);
    return null;
  }
catch (  antlr.TokenStreamRecognitionException tsre) {
    String mess="^line (\\d+):(\\d+):\\s";
    String[] matches=PApplet.match(tsre.toString(),mess);
    IResource errorFile=null;
    int errorLine=-1;
    if (matches != null) {
      errorLine=Integer.parseInt(matches[1]) - 1;
      for (      IResource file : sketch.members()) {
        if (file.getFileExtension() != null && file.getFileExtension().equalsIgnoreCase("pde")) {
          int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
          int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
          if (low <= errorLine && high > errorLine) {
            errorFile=file;
            errorLine-=low;
            break;
          }
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    reportProblem(tsre.getMessage(),errorFile,errorLine,true);
    return null;
  }
catch (  RunnerException re) {
    IResource errorFile=null;
    int errorLine=re.getCodeLine() + 1;
    for (    IResource file : sketch.members()) {
      if (file.getFileExtension() != null && file.getFileExtension().equalsIgnoreCase("pde")) {
        int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
        int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
        if (low <= errorLine && high > errorLine) {
          errorFile=file;
          errorLine-=low;
          break;
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    String msg=re.getMessage();
    if (msg.equals("expecting RCURLY, found 'null'"))     msg="Found one too many { characters without a } to match it.";
    if (msg.indexOf("expecting RBRACK") != -1)     msg="Syntax error, maybe a missing right ] character?";
    if (msg.indexOf("expecting SEMI") != -1)     msg="Syntax error, maybe a missing semicolon?";
    if (msg.indexOf("expecting RPAREN") != -1)     msg="Syntax error, maybe a missing right parenthesis?";
    if (msg.indexOf("preproc.web_colors") != -1)     msg="A web color (such as #ffcc00) must be six digits.";
    reportProblem(msg,errorFile,errorLine,true);
    return null;
  }
catch (  CoreException e) {
    ProcessingLog.logError(e);
    return null;
  }
catch (  Exception e) {
    ProcessingLog.logError(e);
    return null;
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  importedLibraries=new ArrayList<File>();
  coreLibs=getCoreLibsFolder().getAbsoluteFile();
  sketchBookLibs=getSketchBookLibsFolder(sketch).getAbsoluteFile();
  importToLibraryTable=new HashMap<String,File>();
  try {
    addLibraries(coreLibs);
    addLibraries(sketchBookLibs);
  }
 catch (  IOException e) {
    ProcessingLog.logError("Libraries could not be loaded.",e);
  }
  for (  String item : result.extraImports) {
    int dot=item.lastIndexOf('.');
    String entry=(dot == -1) ? item : item.substring(0,dot);
    File libFolder=importToLibraryTable.get(entry);
    if (libFolder != null) {
      importedLibraries.add(libFolder);
      classPath+=Utilities.contentsToClassPath(libFolder);
      libraryPath+=File.pathSeparator + libFolder.getAbsolutePath();
    }
  }
  String javaClassPath=System.getProperty("java.class.path");
  if (javaClassPath.startsWith("\"") && javaClassPath.endsWith("\""))   javaClassPath=javaClassPath.substring(1,javaClassPath.length() - 1);
  classPath+=File.pathSeparator + javaClassPath;
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  for (  IResource file : sketch.members()) {
    if (file.getFileExtension() != null && file.getFileExtension().equalsIgnoreCase("java")) {
      String filename=file.getName() + ".java";
      try {
        String program=Utilities.readFile((IFile)file);
        String[] pkg=PApplet.match(program,Utilities.PACKAGE_REGEX);
        if (pkg == null) {
          pkg=new String[]{packageName};
          program="package " + packageName + ";"+ program;
        }
        IFolder packageFolder=buildFolder.getFolder(pkg[0].replace('.','/'));
        if (!packageFolder.exists())         packageFolder.create(IResource.NONE,true,null);
        IFile modFile=packageFolder.getFile(file.getName() + ".java");
        ByteArrayInputStream inStream=new ByteArrayInputStream(program.getBytes());
        try {
          if (modFile.exists()) {
            modFile.setContents(inStream,true,false,monitor);
          }
 else {
            modFile.create(inStream,true,monitor);
          }
          modFile.setDerived(true,monitor);
        }
  finally {
          inStream.close();
        }
      }
 catch (      Exception e) {
        ProcessingLog.logError("Problem moving " + filename + " to the build folder.",e);
      }
    }
 else     if (file.getFileExtension() != null && file.getFileExtension().equalsIgnoreCase("pde")) {
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"),result.headerOffset);
    }
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  IPath containerPath=new Path(JavaRuntime.JRE_CONTAINER);
  IVMInstall vm=JavaRuntime.getDefaultVMInstall();
  IPath vmPath=containerPath.append(vm.getVMInstallType().getId()).append(vm.getName());
  System.out.println("classPath entries:");
  for (  String s : classPath.split(File.pathSeparator)) {
    if (!s.isEmpty())     System.out.println(s);
  }
  System.out.println("IClasspathEntry[] items:");
  IClasspathEntry[] newClasspath={JavaCore.newSourceEntry(buildFolder.getFullPath()),JavaCore.newContainerEntry(vmPath)};
  for (  IClasspathEntry s : newClasspath) {
    System.out.println(s.toString());
  }
  return null;
}

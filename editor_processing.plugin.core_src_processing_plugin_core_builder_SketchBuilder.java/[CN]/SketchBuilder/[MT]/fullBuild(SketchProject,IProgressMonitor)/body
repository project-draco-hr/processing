{
  clean(sketchProject,monitor);
  IProject sketch=sketchProject.getProject();
  if (sketch == null || !sketch.isAccessible()) {
    ProcessingLog.logError("Sketch is inaccessible. Aborting build process.",null);
    return null;
  }
  sketchProject.wasLastBuildSuccessful=false;
  IFolder buildFolder=sketchProject.getBuildFolder();
  if (buildFolder == null) {
    ProcessingLog.logError("Build folder could not be accessed.",null);
    return null;
  }
  monitor.beginTask("Sketch Build",40);
  if (checkCancel(monitor)) {
    return null;
  }
  IFolder codeFolder=sketchProject.getCodeFolder();
  String[] codeFolderPackages=null;
  if (codeFolder != null && codeFolder.exists()) {
    String codeFolderClassPath=Utilities.contentsToClassPath(codeFolder.getLocation().toFile());
    for (    String s : codeFolderClassPath.split(File.separator)) {
      if (!s.isEmpty()) {
        libraryJarPathList.add(new Path(s).makeAbsolute());
      }
    }
    codeFolderPackages=Utilities.packageListFromClassPath(codeFolderClassPath);
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  StringBuffer bigCode=new StringBuffer();
  int bigCount=0;
  for (  IResource file : sketch.members()) {
    if ("pde".equalsIgnoreCase(file.getFileExtension())) {
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"),bigCount);
      String content=Utilities.readFile((IFile)file);
      bigCode.append(content);
      bigCode.append("\n");
      bigCount+=Utilities.getLineCount(content);
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"),bigCount);
    }
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  PdePreprocessor preproc=new PdePreprocessor(sketch.getName(),4);
  PreprocessResult result=null;
  try {
    IFile output=buildFolder.getFile(sketch.getName() + ".java");
    StringWriter stream=new StringWriter();
    result=preproc.write(stream,bigCode.toString(),codeFolderPackages);
    sketchProject.sketch_width=-1;
    sketchProject.sketch_height=-1;
    String scrubbed=Utilities.scrubComments(stream.toString());
    String[] matches=Utilities.match(scrubbed,Utilities.SIZE_REGEX);
    if (matches != null) {
      try {
        int wide=Integer.parseInt(matches[1]);
        int high=Integer.parseInt(matches[2]);
        if (wide > 0)         sketchProject.sketch_width=wide;
        if (high > 0)         sketchProject.sketch_height=high;
      }
 catch (      NumberFormatException e) {
        ProcessingLog.logInfo("Found a reference to size, but it didn't seem to contain numbers. " + "Will use default sizes instead.");
      }
    }
    ByteArrayInputStream inStream=new ByteArrayInputStream(stream.toString().getBytes());
    try {
      if (!output.exists()) {
        output.create(inStream,true,monitor);
      }
 else {
        output.setContents(inStream,true,false,monitor);
      }
    }
  finally {
      stream.close();
      inStream.close();
    }
    srcFolderPathList.add(buildFolder.getFullPath());
  }
 catch (  antlr.RecognitionException re) {
    IResource errorFile=null;
    int errorLine=re.getLine() - 1;
    for (    IResource file : sketch.members()) {
      if ("pde".equalsIgnoreCase(file.getFileExtension())) {
        int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
        int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
        if (low <= errorLine && high > errorLine) {
          errorFile=file;
          errorLine-=low;
          break;
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    reportProblem(re.getMessage(),errorFile,errorLine,true);
    return null;
  }
catch (  antlr.TokenStreamRecognitionException tsre) {
    String mess="^line (\\d+):(\\d+):\\s";
    String[] matches=Utilities.match(tsre.toString(),mess);
    IResource errorFile=null;
    int errorLine=-1;
    if (matches != null) {
      errorLine=Integer.parseInt(matches[1]) - 1;
      for (      IResource file : sketch.members()) {
        if ("pde".equalsIgnoreCase(file.getFileExtension())) {
          int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
          int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
          if (low <= errorLine && high > errorLine) {
            errorFile=file;
            errorLine-=low;
            break;
          }
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    reportProblem(tsre.getMessage(),errorFile,errorLine,true);
    return null;
  }
catch (  RunnerException re) {
    IResource errorFile=null;
    int errorLine=re.getCodeLine() + 1;
    for (    IResource file : sketch.members()) {
      if ("pde".equalsIgnoreCase(file.getFileExtension())) {
        int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
        int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
        if (low <= errorLine && high > errorLine) {
          errorFile=file;
          errorLine-=low;
          break;
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    reportProblem(re.getMessage(),errorFile,errorLine,true);
    return null;
  }
catch (  Exception e) {
    ProcessingLog.logError(e);
    return null;
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  ArrayList<String> allFoundLibraries=new ArrayList<String>();
  allFoundLibraries.addAll(Utilities.getLibraryJars(ProcessingCore.getProcessingCore().getCoreLibsFolder()));
  allFoundLibraries.addAll(Utilities.getLibraryJars(Utilities.getSketchBookLibsFolder(sketch)));
  HashMap<String,IPath> libraryImportToPathTable=new HashMap<String,IPath>();
  for (  String libraryPath : allFoundLibraries) {
    String[] packages=Utilities.packageListFromClassPath(libraryPath);
    for (    String pkg : packages)     libraryImportToPathTable.put(pkg,new Path(libraryPath));
  }
  boolean importProblems=false;
  for (int i=0; i < result.extraImports.size(); i++) {
    String importPackage=result.extraImports.get(i);
    int dot=importPackage.lastIndexOf('.');
    String entry=(dot == -1) ? importPackage : importPackage.substring(0,dot);
    IPath libPath=libraryImportToPathTable.get(entry);
    if (libPath != null) {
      libraryJarPathList.add(libPath.makeAbsolute());
    }
 else {
      reportProblem("Library import " + entry + " could not be found. Check the library folder in your sketchbook.",sketch.getFile(sketch.getName() + ".pde"),i + 1,true);
      importProblems=true;
    }
  }
  if (importProblems)   return null;
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  IPath[] libPaths=new IPath[libraryJarPathList.size()];
  int i=0;
  for (  IPath path : libraryJarPathList)   libPaths[i++]=path;
  IPath[] srcPaths=new IPath[srcFolderPathList.size()];
  i=0;
  for (  IPath path : srcFolderPathList)   srcPaths[i++]=path;
  try {
    sketchProject.updateClasspathEntries(srcPaths,libPaths);
  }
 catch (  JavaModelException e) {
    ProcessingLog.logError("There was a problem setting the compiler class path.",e);
    return null;
  }
  sketchProject.wasLastBuildSuccessful=true;
  return null;
}

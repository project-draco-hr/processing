{
  clean(sketchProject,monitor);
  IProject sketch=sketchProject.getProject();
  if (sketch == null || !sketch.isAccessible()) {
    ProcessingLog.logError("Sketch is inaccessible!",null);
    return null;
  }
  IFolder codeFolder=sketchProject.getCodeFolder();
  IFolder buildFolder=sketchProject.getBuildFolder();
  if (buildFolder == null) {
    ProcessingLog.logError("Build folder could not be accessed.",null);
    return null;
  }
  monitor.beginTask("Sketch Build",400);
  if (!sketch.isOpen()) {
    return null;
  }
  if (checkCancel(monitor)) {
    return null;
  }
  PdePreprocessor preproc=new PdePreprocessor(sketch.getName(),4);
  String[] codeFolderPackages=null;
  if (codeFolder != null && codeFolder.exists()) {
    String codeFolderClassPath=Utilities.contentsToClassPath(codeFolder.getLocation().toFile());
    for (    String s : codeFolderClassPath.split(File.separator)) {
      if (!s.isEmpty()) {
        libraryJarPathList.add(new Path(s).makeAbsolute());
      }
    }
    codeFolderPackages=Utilities.packageListFromClassPath(codeFolderClassPath);
  }
  StringBuffer bigCode=new StringBuffer();
  int bigCount=0;
  for (  IResource file : sketch.members()) {
    if ("pde".equalsIgnoreCase(file.getFileExtension())) {
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"),bigCount);
      String content=Utilities.readFile((IFile)file);
      bigCode.append(content);
      bigCode.append("\n");
      bigCount+=Utilities.getLineCount(content);
      file.setSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"),bigCount);
    }
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  PreprocessResult result=null;
  try {
    IFile output=buildFolder.getFile(sketch.getName() + ".java");
    StringWriter stream=new StringWriter();
    result=preproc.write(stream,bigCode.toString(),codeFolderPackages);
    String scrubbed=Utilities.scrubComments(stream.toString());
    String[] matches=Utilities.match(scrubbed,Utilities.SIZE_REGEX);
    if (matches != null) {
      try {
        int wide=Integer.parseInt(matches[1]);
        int high=Integer.parseInt(matches[2]);
        if (high > 0) {
          SketchProject.sketch_height=high;
        }
 else {
          SketchProject.sketch_height=-1;
        }
        if (wide > 0) {
          SketchProject.sketch_width=wide;
        }
 else {
          SketchProject.sketch_width=-1;
        }
      }
 catch (      NumberFormatException e) {
        SketchProject.sketch_height=-1;
        SketchProject.sketch_width=-1;
        ProcessingLog.logInfo("Could not find applet size");
      }
    }
    ByteArrayInputStream inStream=new ByteArrayInputStream(stream.toString().getBytes());
    try {
      if (!output.exists()) {
        output.create(inStream,true,monitor);
      }
 else {
        output.setContents(inStream,true,false,monitor);
      }
    }
  finally {
      stream.close();
      inStream.close();
    }
    srcFolderPathList.add(buildFolder.getFullPath());
  }
 catch (  antlr.RecognitionException re) {
    IResource errorFile=null;
    int errorLine=re.getLine() - 1;
    for (    IResource file : sketch.members()) {
      if ("pde".equalsIgnoreCase(file.getFileExtension())) {
        int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
        int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
        if (low <= errorLine && high > errorLine) {
          errorFile=file;
          errorLine-=low;
          break;
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    String msg=re.getMessage();
    if (msg.equals("expecting RCURLY, found 'null'"))     msg="Found one too many { characters without a } to match it.";
    if (msg.indexOf("expecting RBRACK") != -1)     msg="Syntax error, maybe a missing right ] character?";
    if (msg.indexOf("expecting SEMI") != -1)     msg="Syntax error, maybe a missing semicolon?";
    if (msg.indexOf("expecting RPAREN") != -1)     msg="Syntax error, maybe a missing right parenthesis?";
    if (msg.indexOf("preproc.web_colors") != -1)     msg="A web color (such as #ffcc00) must be six digits.";
    reportProblem(msg,errorFile,errorLine,true);
    return null;
  }
catch (  antlr.TokenStreamRecognitionException tsre) {
    String mess="^line (\\d+):(\\d+):\\s";
    String[] matches=Utilities.match(tsre.toString(),mess);
    IResource errorFile=null;
    int errorLine=-1;
    if (matches != null) {
      errorLine=Integer.parseInt(matches[1]) - 1;
      for (      IResource file : sketch.members()) {
        if ("pde".equalsIgnoreCase(file.getFileExtension())) {
          int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
          int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
          if (low <= errorLine && high > errorLine) {
            errorFile=file;
            errorLine-=low;
            break;
          }
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    reportProblem(tsre.getMessage(),errorFile,errorLine,true);
    return null;
  }
catch (  RunnerException re) {
    IResource errorFile=null;
    int errorLine=re.getCodeLine() + 1;
    for (    IResource file : sketch.members()) {
      if ("pde".equalsIgnoreCase(file.getFileExtension())) {
        int low=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc start"));
        int high=(Integer)file.getSessionProperty(new QualifiedName(BUILDER_ID,"preproc end"));
        if (low <= errorLine && high > errorLine) {
          errorFile=file;
          errorLine-=low;
          break;
        }
      }
    }
    if (errorFile == null) {
      errorFile=sketch;
      errorLine=-1;
    }
    String msg=re.getMessage();
    if (msg.equals("expecting RCURLY, found 'null'"))     msg="Found one too many { characters without a } to match it.";
    if (msg.indexOf("expecting RBRACK") != -1)     msg="Syntax error, maybe a missing right ] character?";
    if (msg.indexOf("expecting SEMI") != -1)     msg="Syntax error, maybe a missing semicolon?";
    if (msg.indexOf("expecting RPAREN") != -1)     msg="Syntax error, maybe a missing right parenthesis?";
    if (msg.indexOf("preproc.web_colors") != -1)     msg="A web color (such as #ffcc00) must be six digits.";
    reportProblem(msg,errorFile,errorLine,true);
    return null;
  }
catch (  Exception e) {
    ProcessingLog.logError(e);
    return null;
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  ArrayList<String> libs=new ArrayList<String>();
  libs.addAll(Utilities.getLibraryJars(ProcessingCore.getProcessingCore().getCoreLibsFolder()));
  libs.addAll(Utilities.getLibraryJars(Utilities.getSketchBookLibsFolder(sketch)));
  HashMap<String,IPath> importToLibraryTable=new HashMap<String,IPath>();
  for (  String s : libs) {
    String[] packages=Utilities.packageListFromClassPath(s);
    for (    String pkg : packages) {
      importToLibraryTable.put(pkg,new Path(s));
    }
  }
  for (int i=0; i < result.extraImports.size(); i++) {
    String item=result.extraImports.get(i);
    int dot=item.lastIndexOf('.');
    String entry=(dot == -1) ? item : item.substring(0,dot);
    IPath libPath=importToLibraryTable.get(entry);
    if (libPath != null) {
      libraryJarPathList.add(libPath.makeAbsolute());
    }
 else {
      reportProblem("Library import " + entry + " could not be found. Check the library folder in your sketchbook.",sketch.getFile(sketch.getName() + ".pde"),i + 1,true);
    }
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  monitor.worked(10);
  if (checkCancel(monitor)) {
    return null;
  }
  IPath[] libPaths=new IPath[libraryJarPathList.size()];
  int i=0;
  for (  IPath path : libraryJarPathList)   libPaths[i++]=path;
  IPath[] srcPaths=new IPath[srcFolderPathList.size()];
  i=0;
  for (  IPath path : srcFolderPathList)   srcPaths[i++]=path;
  sketchProject.updateClasspathEntries(srcPaths,libPaths);
  return null;
}

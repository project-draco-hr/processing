{
  for (int i=start; i < stop; i++) {
    float a[]=vertices[triangles[i][VERTEX1]];
    float b[]=vertices[triangles[i][VERTEX2]];
    float c[]=vertices[triangles[i][VERTEX3]];
    int tex=triangles[i][TEXTURE_INDEX];
    triangle.reset();
    float ar=clamp(triangleColors[i][0][TRI_DIFFUSE_R] + triangleColors[i][0][TRI_SPECULAR_R]);
    float ag=clamp(triangleColors[i][0][TRI_DIFFUSE_G] + triangleColors[i][0][TRI_SPECULAR_G]);
    float ab=clamp(triangleColors[i][0][TRI_DIFFUSE_B] + triangleColors[i][0][TRI_SPECULAR_B]);
    float br=clamp(triangleColors[i][1][TRI_DIFFUSE_R] + triangleColors[i][1][TRI_SPECULAR_R]);
    float bg=clamp(triangleColors[i][1][TRI_DIFFUSE_G] + triangleColors[i][1][TRI_SPECULAR_G]);
    float bb=clamp(triangleColors[i][1][TRI_DIFFUSE_B] + triangleColors[i][1][TRI_SPECULAR_B]);
    float cr=clamp(triangleColors[i][2][TRI_DIFFUSE_R] + triangleColors[i][2][TRI_SPECULAR_R]);
    float cg=clamp(triangleColors[i][2][TRI_DIFFUSE_G] + triangleColors[i][2][TRI_SPECULAR_G]);
    float cb=clamp(triangleColors[i][2][TRI_DIFFUSE_B] + triangleColors[i][2][TRI_SPECULAR_B]);
    boolean failedToPrecalc=false;
    if (s_enableAccurateTextures && frustumMode) {
      boolean textured=true;
      smoothTriangle.reset(3);
      smoothTriangle.smooth=true;
      smoothTriangle.interpARGB=true;
      smoothTriangle.setIntensities(ar,ag,ab,a[A],br,bg,bb,b[A],cr,cg,cb,c[A]);
      if (tex > -1 && textures[tex] != null) {
        smoothTriangle.setCamVertices(a[VX],a[VY],a[VZ],b[VX],b[VY],b[VZ],c[VX],c[VY],c[VZ]);
        smoothTriangle.interpUV=true;
        smoothTriangle.texture(textures[tex]);
        float umult=textures[tex].width;
        float vmult=textures[tex].height;
        smoothTriangle.vertices[0][U]=a[U] * umult;
        smoothTriangle.vertices[0][V]=a[V] * vmult;
        smoothTriangle.vertices[1][U]=b[U] * umult;
        smoothTriangle.vertices[1][V]=b[V] * vmult;
        smoothTriangle.vertices[2][U]=c[U] * umult;
        smoothTriangle.vertices[2][V]=c[V] * vmult;
      }
 else {
        smoothTriangle.interpUV=false;
        textured=false;
      }
      smoothTriangle.setVertices(a[TX],a[TY],a[TZ],b[TX],b[TY],b[TZ],c[TX],c[TY],c[TZ]);
      if (!textured || smoothTriangle.precomputeAccurateTexturing()) {
        smoothTriangle.render();
      }
 else {
        failedToPrecalc=true;
      }
    }
    if (!s_enableAccurateTextures || failedToPrecalc || (frustumMode == false)) {
      if (tex > -1 && textures[tex] != null) {
        triangle.setTexture(textures[tex]);
        triangle.setUV(a[U],a[V],b[U],b[V],c[U],c[V]);
      }
      triangle.setIntensities(ar,ag,ab,a[A],br,bg,bb,b[A],cr,cg,cb,c[A]);
      triangle.setVertices(a[TX],a[TY],a[TZ],b[TX],b[TY],b[TZ],c[TX],c[TY],c[TZ]);
      triangle.render();
    }
  }
}

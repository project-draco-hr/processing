{
  while (offset < stopOffset) {
    char curChar=buffer[offset];
switch (state) {
case ISA_HASH:
      if (isDelimiter(curChar)) {
        state=INIT;
        if (curChar == '(')         return SchemeTokenContext.SCHEME_OPEN_PAREN;
        return categorizeHash();
      }
    offset++;
  break;
case ISA_TEXT:
if (isDelimiter(curChar)) {
  state=INIT;
  return categorizeText();
}
offset++;
break;
case ISI_LINE_COMMENT:
offset++;
if (curChar == '\n') {
state=INIT;
return SchemeTokenContext.SCHEME_COMMENT;
}
break;
case ISI_WHITESPACE:
if (!isWhitespace(curChar)) {
state=INIT;
return SchemeTokenContext.SCHEME_WHITESPACE;
}
offset++;
break;
case ISI_STRING:
if (curChar == '\\') {
state=ISI_STRING_AFTER_SLASH;
}
 else if (curChar == '"') {
state=INIT;
offset++;
return SchemeTokenContext.SCHEME_CONSTANT;
}
offset++;
break;
case ISI_STRING_AFTER_SLASH:
state=ISI_STRING;
offset++;
break;
case INIT:
switch (curChar) {
case '#':
state=ISA_HASH;
offset++;
break;
case ';':
state=ISI_LINE_COMMENT;
offset++;
break;
case '(':
offset++;
return SchemeTokenContext.SCHEME_OPEN_PAREN;
case ')':
offset++;
return SchemeTokenContext.SCHEME_CLOSE_PAREN;
case '"':
state=ISI_STRING;
offset++;
break;
default :
if (isWhitespace(curChar)) {
state=ISI_WHITESPACE;
offset++;
break;
}
 else {
state=ISA_TEXT;
offset++;
break;
}
}
}
}
if (lastBuffer) {
if (state == ISI_STRING || state == ISI_STRING_AFTER_SLASH || state == ISA_HASH) return SchemeTokenContext.SCHEME_CONSTANT;
if (state == ISA_TEXT) {
return categorizeText();
}
if (state == ISI_LINE_COMMENT) return SchemeTokenContext.SCHEME_COMMENT;
if (state == ISI_WHITESPACE) return SchemeTokenContext.SCHEME_WHITESPACE;
Logger.getLogger(getClass().getName()).log(Level.WARNING,"SchemeSyntax: Unknown token type for state: '" + state + "'");
}
return null;
}

{
  if (!fillVBOsCreated) {
    createFillBuffers();
    fillVBOsCreated=true;
  }
  int size, sizef, sizex;
  startFillShader();
  enableFillVertex();
  enableFillColor();
  if (lights) {
    enableFillNormal();
    enableFillMaterials();
  }
  size=tessGeo.fillVertexCount;
  sizef=size * PGL.SIZEOF_FLOAT;
  pgl.glBindBuffer(PGL.GL_ARRAY_BUFFER,glFillVertexBufferID);
  pgl.glBufferData(PGL.GL_ARRAY_BUFFER,3 * sizef,FloatBuffer.wrap(tessGeo.fillVertices,0,3 * size),vboMode);
  setFillVertexFormat(3,0);
  pgl.glBindBuffer(PGL.GL_ARRAY_BUFFER,glFillColorBufferID);
  pgl.glBufferData(PGL.GL_ARRAY_BUFFER,4 * sizef,FloatBuffer.wrap(tessGeo.fillColors,0,4 * size),vboMode);
  setFillColorFormat(4,0);
  if (lights) {
    pgl.glBindBuffer(PGL.GL_ARRAY_BUFFER,glFillNormalBufferID);
    pgl.glBufferData(PGL.GL_ARRAY_BUFFER,3 * sizef,FloatBuffer.wrap(tessGeo.fillNormals,0,3 * size),vboMode);
    setFillNormalFormat(3,0);
  }
  if (texCache.hasTexture) {
    pgl.glActiveTexture(PGL.GL_TEXTURE0);
    enableFillTexCoord();
    pgl.glBindBuffer(PGL.GL_ARRAY_BUFFER,glFillTexCoordBufferID);
    pgl.glBufferData(PGL.GL_ARRAY_BUFFER,2 * sizef,FloatBuffer.wrap(tessGeo.fillTexcoords,0,2 * size),vboMode);
    setFillTexCoordFormat(2,0);
  }
  pgl.glBindBuffer(PGL.GL_ELEMENT_ARRAY_BUFFER,glFillIndexBufferID);
  PTexture tex0=null;
  for (int i=0; i < texCache.count; i++) {
    PImage img=texCache.textures[i];
    PTexture tex=null;
    if (img != null) {
      tex=pg.getTexture(img);
      if (tex != null) {
        tex.bind();
        tex0=tex;
        enableFillTexturing();
      }
 else {
        disableFillTexturing();
      }
    }
 else {
      disableFillTexturing();
    }
    if (tex == null && tex0 != null) {
      tex0.unbind();
      pgl.glDisable(tex0.glTarget);
    }
    int offset=texCache.firstIndex[i];
    size=texCache.lastIndex[i] - texCache.firstIndex[i] + 1;
    sizex=size * PGL.SIZEOF_INDEX;
    pgl.glBufferData(PGL.GL_ELEMENT_ARRAY_BUFFER,sizex,ShortBuffer.wrap(tessGeo.fillIndices,offset,size),vboMode);
    pgl.glDrawElements(PGL.GL_TRIANGLES,size,PGL.GL_UNSIGNED_SHORT,0);
  }
  if (texCache.hasTexture) {
    for (int i=0; i < texCache.count; i++) {
      PImage img=texCache.textures[i];
      if (img != null) {
        PTexture tex=pg.getTexture(img);
        if (tex != null) {
          tex.unbind();
        }
      }
    }
    for (int i=0; i < texCache.count; i++) {
      PImage img=texCache.textures[i];
      if (img != null) {
        PTexture tex=pg.getTexture(img);
        if (tex != null) {
          pgl.glDisable(tex.glTarget);
        }
      }
    }
    disableFillTexCoord();
    disableFillTexturing();
  }
  pgl.glBindBuffer(PGL.GL_ELEMENT_ARRAY_BUFFER,0);
  pgl.glBindBuffer(PGL.GL_ARRAY_BUFFER,0);
  disableFillVertex();
  disableFillColor();
  if (lights) {
    disableFillNormal();
  }
  stopFillShader();
}

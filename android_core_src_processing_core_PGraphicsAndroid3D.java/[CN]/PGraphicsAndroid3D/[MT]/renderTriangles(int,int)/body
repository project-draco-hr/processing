{
  report("render_triangles in");
  PTexture tex=null;
  boolean texturing=false;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    FACECOUNT++;
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (recordingModel) {
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      VertexGroup group=PShape3D.newVertexGroup(n0,n1,TRIANGLES,0,faceTexture[j]);
      recordedGroups.add(group);
    }
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    texCoordBuffer.position(0);
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      TRIANGLECOUNT++;
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * a[U]) * uscale,(cy + sy * a[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * a[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * a[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * b[U]) * uscale,(cy + sy * b[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * b[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * b[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * c[U]) * uscale,(cy + sy * c[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * c[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * c[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      i++;
    }
    if (!recordingModel) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      if (texturing)       texCoordBuffer.put(texCoordArray);
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      texCoordBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      if (texturing)       gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer);
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (texturing) {
      gl.glBindTexture(tex.getGLTarget(),0);
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report("render_triangles out");
}

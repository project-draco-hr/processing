{
  int nInVert=in.lastVertex - in.firstVertex + 1;
  if (stroke && 1 <= nInVert) {
    tess.isStroked=true;
    int quadCount=nInVert;
    int nvertTot=5 * quadCount;
    int nindTot=12 * quadCount;
    tess.addPointVertices(nvertTot);
    tess.addPointIndices(nindTot);
    int vertIdx=tess.firstPointVertex;
    int attribIdx=tess.firstPointVertex;
    int indIdx=tess.firstPointIndex;
    int firstVert=tess.firstPointVertex;
    for (int i=in.firstVertex; i <= in.lastVertex; i++) {
      int nvert=5;
      for (int k=0; k < nvert; k++) {
        tess.putPointVertex(in,i,vertIdx);
        vertIdx++;
      }
      tess.pointAttributes[2 * attribIdx + 0]=0;
      tess.pointAttributes[2 * attribIdx + 1]=0;
      attribIdx++;
      for (int k=0; k < 4; k++) {
        tess.pointAttributes[2 * attribIdx + 0]=0.5f * QUAD_SIGNS[k][0] * strokeWeight;
        tess.pointAttributes[2 * attribIdx + 1]=0.5f * QUAD_SIGNS[k][1] * strokeWeight;
        attribIdx++;
      }
      for (int k=1; k < nvert - 1; k++) {
        tess.pointIndices[indIdx++]=(short)(firstVert + 0);
        tess.pointIndices[indIdx++]=(short)(firstVert + k);
        tess.pointIndices[indIdx++]=(short)(firstVert + k + 1);
      }
      tess.pointIndices[indIdx++]=(short)(firstVert + 0);
      tess.pointIndices[indIdx++]=(short)(firstVert + 1);
      tess.pointIndices[indIdx++]=(short)(firstVert + nvert - 1);
      firstVert=vertIdx;
    }
  }
}

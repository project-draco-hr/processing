{
  int nInVert=in.lastVertex - in.firstVertex + 1;
  callback.calcNormals=calcNormals;
  if (fill && 3 <= nInVert) {
    checkForFlush(nInVert);
    gluTess.beginPolygon();
    if (solid) {
      gluTess.setWindingRule(PGL.TESS_WINDING_NONZERO);
    }
 else {
      gluTess.setWindingRule(PGL.TESS_WINDING_ODD);
    }
    gluTess.beginContour();
    for (int i=in.firstVertex; i <= in.lastVertex; i++) {
      boolean breakPt=in.codes[i] == PShape.BREAK;
      if (breakPt) {
        gluTess.endContour();
        gluTess.beginContour();
      }
      double[] vertex=new double[]{in.vertices[3 * i + 0],in.vertices[3 * i + 1],in.vertices[3 * i + 2],in.colors[4 * i + 0],in.colors[4 * i + 1],in.colors[4 * i + 2],in.colors[4 * i + 3],in.normals[3 * i + 0],in.normals[3 * i + 1],in.normals[3 * i + 2],in.texcoords[2 * i + 0],in.texcoords[2 * i + 1],in.ambient[i],in.specular[i],in.emissive[i],in.shininess[i]};
      gluTess.addVertex(vertex);
    }
    gluTess.endContour();
    gluTess.endPolygon();
  }
  if (stroke) {
    tess.isStroked=true;
    tessellateEdges();
  }
}

{
  int gcount=i1 - i0 + 1;
  int vcount=v1 - v0 + 1;
  while (indicesBuffer.capacity() < idxCount + 3 * gcount) {
    int newSize=indicesBuffer.capacity() << 1;
    ByteBuffer ibb=ByteBuffer.allocateDirect(newSize * SIZEOF_SHORT);
    ibb.order(ByteOrder.nativeOrder());
    indicesBuffer=ibb.asShortBuffer();
    indicesArray=new short[newSize];
  }
  while (verticesBuffer.capacity() / 3 < vertCount + vcount) {
    int newSize=verticesBuffer.capacity() / 3 << 1;
    ByteBuffer vbb=ByteBuffer.allocateDirect(newSize * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    verticesBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(newSize * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorsBuffer=cbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(newSize * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalsBuffer=nbb.asIntBuffer();
    for (int t=0; t < texCount; t++) {
      ByteBuffer tbb=ByteBuffer.allocateDirect(newSize * 2 * SIZEOF_INT);
      tbb.order(ByteOrder.nativeOrder());
      texcoordsBuffer[t]=tbb.asIntBuffer();
    }
    verticesArray=new int[newSize * 3];
    colorsArray=new int[newSize * 4];
    normalsArray=new int[newSize * 3];
    for (int t=0; t < texCount; t++) {
      texcoordsArray[t]=new int[newSize * 2];
    }
  }
  int ni=0;
  for (int i=i0; i <= i1; i++) {
    indicesArray[ni++]=(short)(vertCount + indices[i][VERTEX1] - v0);
    indicesArray[ni++]=(short)(vertCount + indices[i][VERTEX2] - v0);
    indicesArray[ni++]=(short)(vertCount + indices[i][VERTEX3] - v0);
  }
  minVertIndex=vertCount;
  maxVertIndex=vertCount + v1 - v0;
  int nv=0;
  int nn=0;
  int nc=0;
  int nt=0;
  float x, y, z;
  float nx, ny, nz;
  float[] vert;
  for (int i=v0; i <= v1; i++) {
    vert=vertices[i];
    x=vert[X];
    y=vert[Y];
    z=vert[Z];
    nx=vert[NX];
    ny=vert[NY];
    nz=vert[NZ];
    if (mm == null) {
      verticesArray[nv++]=toFixed32(x);
      verticesArray[nv++]=toFixed32(y);
      verticesArray[nv++]=toFixed32(z);
      normalsArray[nn++]=toFixed32(nx);
      normalsArray[nn++]=toFixed32(ny);
      normalsArray[nn++]=toFixed32(nz);
    }
 else {
      verticesArray[nv++]=toFixed32(x * mm[0] + y * mm[4] + z * mm[8] + mm[12]);
      verticesArray[nv++]=toFixed32(x * mm[1] + y * mm[5] + z * mm[9] + mm[13]);
      verticesArray[nv++]=toFixed32(x * mm[2] + y * mm[6] + z * mm[10] + mm[14]);
      normalsArray[nn++]=toFixed32(nx + mm[12]);
      normalsArray[nn++]=toFixed32(ny + mm[13]);
      normalsArray[nn++]=toFixed32(nz + mm[14]);
    }
    colorsArray[nc++]=toFixed32(vert[R]);
    colorsArray[nc++]=toFixed32(vert[G]);
    colorsArray[nc++]=toFixed32(vert[B]);
    colorsArray[nc++]=toFixed32(vert[A]);
    if (0 < texCount) {
      float[] vertU=vertexU[i];
      float[] vertV=vertexV[i];
      for (int t=0; t < texCount; t++) {
        float uscale=1.0f;
        float vscale=1.0f;
        float cx=0.0f;
        float sx=+1.0f;
        float cy=0.0f;
        float sy=+1.0f;
        PTexture tex=texturesArray[t];
        uscale*=tex.getMaxTexCoordU();
        vscale*=tex.getMaxTexCoordV();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
        texcoordsArray[t][nt++]=toFixed32((cx + sx * vertU[t]) * uscale);
        texcoordsArray[t][nt++]=toFixed32((cy + sy * vertV[t]) * vscale);
      }
    }
  }
  indicesBuffer.put(indicesArray,0,3 * gcount);
  verticesBuffer.put(verticesArray,0,3 * vcount);
  normalsBuffer.put(normalsArray,0,3 * vcount);
  colorsBuffer.put(colorsArray,0,4 * vcount);
  for (int t=0; t < texCount; t++) {
    texcoordsBuffer[t].put(texcoordsArray[t],0,2 * vcount);
  }
  idxCount+=3 * gcount;
  vertCount+=vcount;
}

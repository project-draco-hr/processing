{
  GLUvertex v, vHead=tess.mesh.vHead;
  double w;
  double[] norm=new double[3];
  double[] sUnit, tUnit;
  int i;
  boolean computedNormal=false;
  norm[0]=tess.normal[0];
  norm[1]=tess.normal[1];
  norm[2]=tess.normal[2];
  if (norm[0] == 0 && norm[1] == 0 && norm[2] == 0) {
    ComputeNormal(tess,norm);
    computedNormal=true;
  }
  sUnit=tess.sUnit;
  tUnit=tess.tUnit;
  i=LongAxis(norm);
  if (TRUE_PROJECT) {
    Normalize(norm);
    sUnit[i]=0;
    sUnit[(i + 1) % 3]=S_UNIT_X;
    sUnit[(i + 2) % 3]=S_UNIT_Y;
    w=Dot(sUnit,norm);
    sUnit[0]-=w * norm[0];
    sUnit[1]-=w * norm[1];
    sUnit[2]-=w * norm[2];
    Normalize(sUnit);
    tUnit[0]=norm[1] * sUnit[2] - norm[2] * sUnit[1];
    tUnit[1]=norm[2] * sUnit[0] - norm[0] * sUnit[2];
    tUnit[2]=norm[0] * sUnit[1] - norm[1] * sUnit[0];
    Normalize(tUnit);
  }
 else {
    sUnit[i]=0;
    sUnit[(i + 1) % 3]=S_UNIT_X;
    sUnit[(i + 2) % 3]=S_UNIT_Y;
    tUnit[i]=0;
    tUnit[(i + 1) % 3]=(norm[i] > 0) ? -S_UNIT_Y : S_UNIT_Y;
    tUnit[(i + 2) % 3]=(norm[i] > 0) ? S_UNIT_X : -S_UNIT_X;
  }
  for (v=vHead.next; v != vHead; v=v.next) {
    v.s=Dot(v.coords,sUnit);
    v.t=Dot(v.coords,tUnit);
  }
  if (computedNormal) {
    CheckOrientation(tess);
  }
}

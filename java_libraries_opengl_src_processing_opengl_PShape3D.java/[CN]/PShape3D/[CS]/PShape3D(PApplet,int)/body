{
  pg=(PGraphicsOpenGL)parent.g;
  pgl=pg.pgl;
  glMode=PGL.STATIC_DRAW;
  glFillVertexBufferID=0;
  glFillColorBufferID=0;
  glFillNormalBufferID=0;
  glFillTexCoordBufferID=0;
  glFillIndexBufferID=0;
  glLineVertexBufferID=0;
  glLineColorBufferID=0;
  glLineNormalBufferID=0;
  glLineAttribBufferID=0;
  glLineIndexBufferID=0;
  glPointVertexBufferID=0;
  glPointColorBufferID=0;
  glPointNormalBufferID=0;
  glPointAttribBufferID=0;
  glPointIndexBufferID=0;
  this.tessellator=pg.tessellator;
  this.family=family;
  this.root=this;
  this.parent=null;
  this.tessellated=false;
  if (family == GEOMETRY || family == PRIMITIVE || family == PATH) {
    in=pg.newInGeometry(RETAINED);
  }
  tess=pg.newTessGeometry(RETAINED);
  fillIndexData=new ArrayList<IndexData>();
  lineIndexData=new ArrayList<IndexData>();
  pointIndexData=new ArrayList<IndexData>();
  textureMode=pg.textureMode;
  rectMode=pg.rectMode;
  ellipseMode=pg.ellipseMode;
  shapeMode=pg.shapeMode;
  imageMode=pg.imageMode;
  colorMode(pg.colorMode,pg.colorModeX,pg.colorModeY,pg.colorModeZ,pg.colorModeA);
  fill=pg.fill;
  fillR=((pg.fillColor >> 16) & 0xFF) / 255.0f;
  fillG=((pg.fillColor >> 8) & 0xFF) / 255.0f;
  fillB=((pg.fillColor >> 0) & 0xFF) / 255.0f;
  fillA=((pg.fillColor >> 24) & 0xFF) / 255.0f;
  stroke=pg.stroke;
  strokeR=((pg.strokeColor >> 16) & 0xFF) / 255.0f;
  strokeG=((pg.strokeColor >> 8) & 0xFF) / 255.0f;
  strokeB=((pg.strokeColor >> 0) & 0xFF) / 255.0f;
  strokeA=((pg.strokeColor >> 24) & 0xFF) / 255.0f;
  strokeWeight=pg.strokeWeight;
  tint=pg.tint;
  tintR=((pg.tintColor >> 16) & 0xFF) / 255.0f;
  tintG=((pg.tintColor >> 8) & 0xFF) / 255.0f;
  tintB=((pg.tintColor >> 0) & 0xFF) / 255.0f;
  tintA=((pg.tintColor >> 24) & 0xFF) / 255.0f;
  normalX=normalY=0;
  normalZ=1;
  normalMode=NORMAL_MODE_AUTO;
}

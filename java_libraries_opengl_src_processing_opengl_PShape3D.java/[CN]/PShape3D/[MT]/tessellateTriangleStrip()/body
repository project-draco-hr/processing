{
  copyInDataToTessData();
  int triCount=vertexCount - 2;
  useIndices=true;
  indexCount=3 * triCount;
  indices=new int[indexCount];
  int idx=0;
  for (int i=1; i < vertexCount - 1; i++) {
    indices[idx++]=i;
    if (i % 2 == 0) {
      indices[idx++]=i - 1;
      indices[idx++]=i + 1;
    }
 else {
      indices[idx++]=i + 1;
      indices[idx++]=i - 1;
    }
  }
  firstIndex=0;
  lastIndex=indexCount - 1;
  int strokedCount=0;
  for (int i=1; i < vertexCount - 1; i++) {
    int i0=i;
    int i1, i2;
    if (i % 2 == 0) {
      i1=i - 1;
      i2=i + 1;
    }
 else {
      i1=i + 1;
      i2=i - 1;
    }
    if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4]) {
      strokedCount++;
    }
  }
  if (0 < strokedCount) {
    useStroke=true;
    int nvert=strokedCount * 3 * 4;
    strokeVertexCount=nvert;
    strokeVertices=new float[3 * nvert];
    strokeColors=new float[4 * nvert];
    strokeNormals=new float[3 * nvert];
    strokeAttributes=new float[4 * nvert];
    int nind=strokedCount * 3 * 2* 3;
    strokeIndexCount=nind;
    strokeIndices=new int[nind];
    int vcount=0;
    int icount=0;
    for (int i=1; i < vertexCount - 1; i++) {
      int i0=i;
      int i1, i2;
      if (i % 2 == 0) {
        i1=i - 1;
        i2=i + 1;
      }
 else {
        i1=i + 1;
        i2=i - 1;
      }
      if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4]) {
        addStrokeLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i1,i2,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i2,i0,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
  }
 else {
    useStroke=false;
  }
}

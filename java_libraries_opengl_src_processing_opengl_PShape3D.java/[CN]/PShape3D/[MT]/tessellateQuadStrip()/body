{
  copyInDataToTessData();
  int quadCount=vertexCount / 2 - 1;
  useIndices=true;
  indexCount=6 * quadCount;
  indices=new int[indexCount];
  int idx=0;
  for (int qd=1; qd < vertexCount / 2; qd++) {
    int i0=2 * (qd - 1);
    int i1=2 * (qd - 1) + 1;
    int i2=2 * qd + 1;
    int i3=2 * qd;
    indices[idx++]=i0;
    indices[idx++]=i1;
    indices[idx++]=i3;
    indices[idx++]=i1;
    indices[idx++]=i2;
    indices[idx++]=i3;
  }
  firstIndex=0;
  lastIndex=indexCount - 1;
  int strokedCount=0;
  for (int qd=1; qd < vertexCount / 2; qd++) {
    int i0=2 * (qd - 1);
    int i1=2 * (qd - 1) + 1;
    int i2=2 * qd + 1;
    int i3=2 * qd;
    if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4] || 0 < inStroke[5 * i3 + 4]) {
      strokedCount++;
    }
  }
  if (0 < strokedCount) {
    useStroke=true;
    int nvert=strokedCount * 4 * 4;
    strokeVertexCount=nvert;
    strokeVertices=new float[3 * nvert];
    strokeColors=new float[4 * nvert];
    strokeNormals=new float[3 * nvert];
    strokeAttributes=new float[4 * nvert];
    int nind=strokedCount * 4 * 2* 3;
    strokeIndexCount=nind;
    strokeIndices=new int[nind];
    int vcount=0;
    int icount=0;
    for (int qd=1; qd < vertexCount / 2; qd++) {
      int i0=2 * (qd - 1);
      int i1=2 * (qd - 1) + 1;
      int i2=2 * qd + 1;
      int i3=2 * qd;
      if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4] || 0 < inStroke[5 * i3 + 4]) {
        addStrokeLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i1,i2,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i2,i3,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i3,i0,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
  }
 else {
    useStroke=false;
  }
}

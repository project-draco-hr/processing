{
  vertexCount=0;
  firstVertex=0;
  lastVertex=0;
  isStroked=false;
  hasPoints=true;
  int nvertTot=0;
  int nindTot=0;
  for (int i=0; i < inVertexCount; i++) {
    float w=inStroke[5 * i + 4];
    int perim=PApplet.max(6,(int)(TWO_PI * w / 20));
    nvertTot+=perim + 1;
    nindTot+=3 * (perim - 1);
  }
  pointVertexCount=nvertTot;
  pointVertices=new float[3 * nvertTot];
  pointColors=new float[4 * nvertTot];
  pointNormals=new float[3 * nvertTot];
  pointAttributes=new float[2 * nvertTot];
  pointIndexCount=nindTot;
  pointIndices=new int[nindTot];
  int vertIdx=0;
  int indIdx=0;
  int attribIdx=0;
  for (int i=0; i < inVertexCount; i++) {
    float w=inStroke[5 * i + 4];
    int perim=PApplet.max(6,(int)(TWO_PI * w / 20));
    int nvert=perim + 1;
    for (int k=0; k < nvert; k++) {
      PApplet.arrayCopy(inVertices,3 * i,pointVertices,3 * vertIdx,3);
      PApplet.arrayCopy(inStroke,5 * i,pointNormals,4 * vertIdx,4);
      PApplet.arrayCopy(inNormals,3 * i,pointColors,3 * vertIdx,3);
      vertIdx++;
    }
    pointAttributes[2 * attribIdx + 0]=0;
    pointAttributes[2 * attribIdx + 1]=0;
    attribIdx++;
    float val=0;
    float inc=(float)SINCOS_LENGTH / perim;
    for (int k=0; k < perim; k++) {
      pointAttributes[2 * attribIdx + 0]=cosLUT[(int)val] * w / 2;
      pointAttributes[2 * attribIdx + 1]=sinLUT[(int)val] * w / 2;
      val=(val + inc) % SINCOS_LENGTH;
      attribIdx++;
    }
    for (int k=1; k < nvert - 1; k++) {
      pointIndices[indIdx++]=0;
      pointIndices[indIdx++]=i;
      pointIndices[indIdx++]=i + 1;
    }
  }
  firstPointIndex=0;
  lastPointIndex=pointIndexCount - 1;
}

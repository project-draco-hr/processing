{
  copyInDataToTessData();
  int triCount=vertexCount / 3;
  useIndices=true;
  indexCount=vertexCount;
  indices=new int[indexCount];
  for (int i=0; i < indexCount; i++) {
    indices[i]=i;
  }
  firstIndex=0;
  lastIndex=indexCount - 1;
  int strokedCount=0;
  for (int tr=0; tr < triCount; tr++) {
    int i0=3 * tr + 0;
    int i1=3 * tr + 1;
    int i2=3 * tr + 2;
    if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4]) {
      strokedCount++;
    }
  }
  if (0 < strokedCount) {
    isStroked=true;
    int nvert=strokedCount * 3 * 4;
    strokeVertexCount=nvert;
    strokeVertices=new float[3 * nvert];
    strokeColors=new float[4 * nvert];
    strokeNormals=new float[3 * nvert];
    strokeAttributes=new float[4 * nvert];
    int nind=strokedCount * 3 * 2* 3;
    strokeIndexCount=nind;
    strokeIndices=new int[nind];
    int vcount=0;
    int icount=0;
    for (int tr=0; tr < triCount; tr++) {
      int i0=3 * tr + 0;
      int i1=3 * tr + 1;
      int i2=3 * tr + 2;
      if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4]) {
        addStrokeLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i1,i2,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i2,i0,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
  }
 else {
    isStroked=false;
  }
}

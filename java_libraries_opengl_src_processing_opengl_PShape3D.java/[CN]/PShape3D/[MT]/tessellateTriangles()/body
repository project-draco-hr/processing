{
  vertexCount=dataSize;
  firstVertex=0;
  lastVertex=vertexCount - 1;
  vertices=new float[3 * dataSize];
  PApplet.arrayCopy(vertexData,vertices,3 * dataSize);
  texcoords=new float[2 * dataSize];
  PApplet.arrayCopy(tcoordData,texcoords,2 * dataSize);
  colors=new float[4 * dataSize];
  PApplet.arrayCopy(colorData,colors,4 * dataSize);
  normals=new float[3 * dataSize];
  PApplet.arrayCopy(normalData,normals,3 * dataSize);
  useIndices=true;
  indexCount=vertexCount;
  indices=new int[indexCount];
  for (int i=0; i < indexCount; i++) {
    indices[i]=i;
  }
  firstIndex=0;
  lastIndex=indexCount - 1;
  int count=0;
  for (int tr=0; tr < dataSize / 3; tr++) {
    int i0=3 * tr + 0;
    int i1=3 * tr + 1;
    int i2=3 * tr + 2;
    if (0 < strokeData[5 * i0 + 4] || 0 < strokeData[5 * i1 + 4] || 0 < strokeData[5 * i2 + 4]) {
      count++;
    }
  }
  if (0 < count) {
    useStroke=true;
    int nvert=count * 3 * 4;
    strokeVertexCount=nvert;
    strokeVertices=new float[3 * nvert];
    strokeColors=new float[4 * nvert];
    strokeNormals=new float[3 * nvert];
    strokeAttributes=new float[4 * nvert];
    int nind=count * 3 * 2* 3;
    strokeIndexCount=nind;
    strokeIndices=new int[nind];
    int vcount=0;
    int icount=0;
    for (int tr=0; tr < dataSize / 3; tr++) {
      int i0=3 * tr + 0;
      int i1=3 * tr + 1;
      int i2=3 * tr + 2;
      if (0 < strokeData[5 * i0 + 4] || 0 < strokeData[5 * i1 + 4] || 0 < strokeData[5 * i2 + 4]) {
        addStrokeLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i1,i2,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i2,i0,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
  }
 else {
    useStroke=false;
  }
}

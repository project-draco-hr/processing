{
  vertexCount=inVertexCount;
  firstVertex=0;
  lastVertex=vertexCount - 1;
  vertices=new float[3 * inVertexCount];
  PApplet.arrayCopy(inVertices,vertices,3 * inVertexCount);
  texcoords=new float[2 * inVertexCount];
  PApplet.arrayCopy(inTexCoords,texcoords,2 * inVertexCount);
  colors=new float[4 * inVertexCount];
  PApplet.arrayCopy(inColors,colors,4 * inVertexCount);
  normals=new float[3 * inVertexCount];
  PApplet.arrayCopy(inNormals,normals,3 * inVertexCount);
  useIndices=true;
  indexCount=vertexCount;
  indices=new int[indexCount];
  for (int i=0; i < indexCount; i++) {
    indices[i]=i;
  }
  firstIndex=0;
  lastIndex=indexCount - 1;
  int count=0;
  for (int tr=0; tr < inVertexCount / 3; tr++) {
    int i0=3 * tr + 0;
    int i1=3 * tr + 1;
    int i2=3 * tr + 2;
    if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4]) {
      count++;
    }
  }
  if (0 < count) {
    useStroke=true;
    int nvert=count * 3 * 4;
    strokeVertexCount=nvert;
    strokeVertices=new float[3 * nvert];
    strokeColors=new float[4 * nvert];
    strokeNormals=new float[3 * nvert];
    strokeAttributes=new float[4 * nvert];
    int nind=count * 3 * 2* 3;
    strokeIndexCount=nind;
    strokeIndices=new int[nind];
    int vcount=0;
    int icount=0;
    for (int tr=0; tr < inVertexCount / 3; tr++) {
      int i0=3 * tr + 0;
      int i1=3 * tr + 1;
      int i2=3 * tr + 2;
      if (0 < inStroke[5 * i0 + 4] || 0 < inStroke[5 * i1 + 4] || 0 < inStroke[5 * i2 + 4]) {
        addStrokeLine(i0,i1,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i1,i2,vcount,icount);
        vcount+=4;
        icount+=6;
        addStrokeLine(i2,i0,vcount,icount);
        vcount+=4;
        icount+=6;
      }
    }
  }
 else {
    useStroke=false;
  }
}

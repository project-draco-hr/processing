{
  if (family == GROUP) {
    boolean firstGeom=true;
    boolean firstStroke=true;
    boolean firstPoint=true;
    for (int i=0; i < childCount; i++) {
      PShape3D child=(PShape3D)children[i];
      child.aggregateImpl();
      tess.addCounts(child.tess);
      if (0 < child.tess.fillVertexCount) {
        if (firstGeom) {
          tess.setFirstFill(child.tess);
          firstGeom=false;
        }
        tess.setLastFill(child.tess);
      }
      if (0 < child.tess.lineVertexCount) {
        if (firstStroke) {
          tess.setFirstLine(child.tess);
          firstStroke=false;
        }
        tess.setLastLine(child.tess);
      }
      if (0 < child.tess.pointVertexCount) {
        if (firstPoint) {
          tess.setFirstPoint(child.tess);
          firstPoint=false;
        }
        tess.setLastPoint(child.tess);
      }
    }
    buildFillIndexCache();
    buildLineIndexCache();
    buildPointIndexCache();
  }
 else {
    if (0 < tess.fillVertexCount && 0 < tess.fillIndexCount) {
      IndexCache cache=tess.fillIndexCache;
      for (int n=0; n < cache.count; n++) {
        int ioffset=cache.indexOffset[n];
        int icount=cache.indexCount[n];
        int vcount=cache.vertexCount[n];
        if (PGL.MAX_VERTEX_INDEX1 <= root.fillVertexRel + vcount) {
          root.fillVertexRel=0;
        }
        if (0 < root.fillVertexRel) {
          for (int i=0; i < icount; i++) {
            tess.fillIndices[ioffset + i]+=root.fillVertexRel;
          }
        }
        cache.indexOffset[n]=root.fillIndexOffset;
        cache.vertexOffset[n]=root.fillVertexOffset;
        root.fillIndexOffset+=icount;
        root.fillVertexOffset+=vcount;
        root.fillVertexRel+=vcount;
      }
      tess.firstFillVertex=cache.vertexOffset[0];
      tess.lastFillVertex=tess.firstFillVertex + tess.fillVertexCount;
      tess.firstFillIndex=cache.indexOffset[0];
      tess.lastFillIndex=tess.firstFillIndex + tess.fillIndexCount;
    }
    if (0 < tess.lineVertexCount && 0 < tess.lineIndexCount) {
      if (PGL.MAX_VERTEX_INDEX1 < root.firstLineVertexRel + tess.lineVertexCount) {
        root.firstLineVertexRel=0;
        root.firstLineVertexAbs=root.lastLineVertexOffset + 1;
      }
      root.lastLineVertexOffset=tess.setLineVertex(root.lastLineVertexOffset);
      root.lastLineIndexOffset=tess.setLineIndex(root.firstLineVertexRel,root.lastLineIndexOffset);
      root.firstLineVertexRel+=tess.lineVertexCount;
    }
    if (0 < tess.pointVertexCount && 0 < tess.pointIndexCount) {
      if (PGL.MAX_VERTEX_INDEX1 < root.firstPointVertexRel + tess.pointVertexCount) {
        root.firstPointVertexRel=0;
        root.firstPointVertexAbs=root.lastPointVertexOffset + 1;
      }
      root.lastPointVertexOffset=tess.setPointVertex(root.lastPointVertexOffset);
      root.lastPointIndexOffset=tess.setPointIndex(root.firstPointVertexRel,root.lastPointIndexOffset);
      root.firstPointVertexRel+=tess.pointVertexCount;
    }
  }
  hasFill=0 < tess.fillVertexCount && 0 < tess.fillIndexCount;
  hasLines=0 < tess.lineVertexCount && 0 < tess.lineIndexCount;
  hasPoints=0 < tess.pointVertexCount && 0 < tess.pointIndexCount;
}

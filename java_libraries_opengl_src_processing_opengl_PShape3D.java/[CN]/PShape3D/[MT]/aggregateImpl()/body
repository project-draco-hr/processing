{
  if (family == GROUP) {
    boolean firstGeom=true;
    boolean firstStroke=true;
    boolean firstPoint=true;
    for (int i=0; i < childCount; i++) {
      PShape3D child=(PShape3D)children[i];
      child.aggregateImpl();
      tess.addCounts(child.tess);
      if (0 < child.tess.fillVertexCount) {
        if (firstGeom) {
          tess.setFirstFill(child.tess);
          firstGeom=false;
        }
        tess.setLastFill(child.tess);
      }
      if (0 < child.tess.lineVertexCount) {
        if (firstStroke) {
          tess.setFirstLine(child.tess);
          firstStroke=false;
        }
        tess.setLastLine(child.tess);
      }
      if (0 < child.tess.pointVertexCount) {
        if (firstPoint) {
          tess.setFirstPoint(child.tess);
          firstPoint=false;
        }
        tess.setLastPoint(child.tess);
      }
    }
    buildFillIndexCache();
    buildLineIndexCache();
    buildPointIndexCache();
  }
 else {
    if (0 < tess.fillVertexCount && 0 < tess.fillIndexCount) {
      IndexCache cache=tess.fillIndexCache;
      for (int n=0; n < cache.count; n++) {
        int ioffset=cache.indexOffset[n];
        int icount=cache.indexCount[n];
        int vcount=cache.vertexCount[n];
        if (PGL.MAX_VERTEX_INDEX1 <= root.fillVertexRel + vcount) {
          root.fillVertexRel=0;
          root.fillVertexOffset=root.fillVertexAbs;
          cache.indexOffset[n]=root.fillIndexOffset;
        }
 else         tess.incFillIndices(ioffset,ioffset + icount - 1,root.fillVertexRel);
        cache.vertexOffset[n]=root.fillVertexOffset;
        root.fillIndexOffset+=icount;
        root.fillVertexAbs+=vcount;
        root.fillVertexRel+=vcount;
      }
      tess.updateFillFromCache();
    }
    if (0 < tess.lineVertexCount && 0 < tess.lineIndexCount) {
      IndexCache cache=tess.lineIndexCache;
      for (int n=0; n < cache.count; n++) {
        int ioffset=cache.indexOffset[n];
        int icount=cache.indexCount[n];
        int vcount=cache.vertexCount[n];
        if (PGL.MAX_VERTEX_INDEX1 <= root.lineVertexRel + vcount) {
          root.lineVertexRel=0;
          root.lineVertexOffset=root.lineVertexAbs;
          cache.indexOffset[n]=root.lineIndexOffset;
        }
 else         tess.incLineIndices(ioffset,ioffset + icount - 1,root.lineVertexRel);
        cache.vertexOffset[n]=root.lineVertexOffset;
        root.lineIndexOffset+=icount;
        root.lineVertexAbs+=vcount;
        root.lineVertexRel+=vcount;
      }
      tess.updateLineFromCache();
    }
    if (0 < tess.pointVertexCount && 0 < tess.pointIndexCount) {
      IndexCache cache=tess.pointIndexCache;
      for (int n=0; n < cache.count; n++) {
        int ioffset=cache.indexOffset[n];
        int icount=cache.indexCount[n];
        int vcount=cache.vertexCount[n];
        if (PGL.MAX_VERTEX_INDEX1 <= root.pointVertexRel + vcount) {
          root.pointVertexRel=0;
          root.pointVertexOffset=root.pointVertexAbs;
          cache.indexOffset[n]=root.pointIndexOffset;
        }
 else         tess.incPointIndices(ioffset,ioffset + icount - 1,root.pointVertexRel);
        cache.vertexOffset[n]=root.pointVertexOffset;
        root.pointIndexOffset+=icount;
        root.pointVertexAbs+=vcount;
        root.pointVertexRel+=vcount;
      }
      tess.updatePointFromCache();
    }
  }
  hasFill=0 < tess.fillVertexCount && 0 < tess.fillIndexCount;
  hasLines=0 < tess.lineVertexCount && 0 < tess.lineIndexCount;
  hasPoints=0 < tess.pointVertexCount && 0 < tess.pointIndexCount;
}

{
  if (family == GROUP) {
    PGraphics.showWarning("GROUP shapes don't have any vertices");
    return;
  }
  updateTessellation();
  if (hasPoints) {
    int[] indices=inGeo.pointIndices[index];
    for (int i=0; i < indices.length; i++) {
      int tessIdx=indices[i];
      tessGeo.pointVertices[3 * tessIdx + 0]=x;
      tessGeo.pointVertices[3 * tessIdx + 1]=y;
      tessGeo.pointVertices[3 * tessIdx + 2]=z;
    }
    modifiedPointVertices=true;
  }
  if (hasLines) {
    int[] indices=inGeo.lineIndices[index];
    for (int i=0; i < indices.length; i++) {
      int tessIdx=indices[i];
      tessGeo.lineVertices[3 * tessIdx + 0]=x;
      tessGeo.lineVertices[3 * tessIdx + 1]=y;
      tessGeo.lineVertices[3 * tessIdx + 2]=z;
    }
    modifiedLineVertices=true;
  }
  if (hasFill) {
    if (-1 < inGeo.firstFillIndex) {
      int tessIdx=inGeo.firstFillIndex + index;
      tessGeo.fillVertices[3 * tessIdx + 0]=x;
      tessGeo.fillVertices[3 * tessIdx + 1]=y;
      tessGeo.fillVertices[3 * tessIdx + 2]=z;
    }
 else {
      float x0=inGeo.vertices[3 * index + 0];
      float y0=inGeo.vertices[3 * index + 1];
      float z0=inGeo.vertices[3 * index + 2];
      int[] indices=inGeo.fillIndices[index];
      float[] weigths=inGeo.fillWeights[index];
      for (int i=0; i < indices.length; i++) {
        int tessIdx=indices[i];
        float weight=weigths[i];
        float tx0=tessGeo.fillVertices[3 * tessIdx + 0];
        float ty0=tessGeo.fillVertices[3 * tessIdx + 1];
        float tz0=tessGeo.fillVertices[3 * tessIdx + 2];
        tessGeo.fillVertices[3 * tessIdx + 0]=tx0 + weight * (x - x0);
        tessGeo.fillVertices[3 * tessIdx + 1]=ty0 + weight * (y - y0);
        tessGeo.fillVertices[3 * tessIdx + 2]=tz0 + weight * (z - z0);
      }
    }
    modifiedFillVertices=true;
  }
  inGeo.vertices[3 * index + 0]=x;
  inGeo.vertices[3 * index + 1]=y;
  inGeo.vertices[3 * index + 2]=z;
  modified();
}

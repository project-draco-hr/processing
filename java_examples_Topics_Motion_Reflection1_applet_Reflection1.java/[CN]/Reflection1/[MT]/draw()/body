{
  fill(0,12);
  noStroke();
  rect(0,0,width,height);
  baseLength=dist(baseX1,baseY1,baseX2,baseY2);
  xCoords=new float[ceil(baseLength)];
  yCoords=new float[ceil(baseLength)];
  for (int i=0; i < xCoords.length; i++) {
    xCoords[i]=baseX1 + ((baseX2 - baseX1) / baseLength) * i;
    yCoords[i]=baseY1 + ((baseY2 - baseY1) / baseLength) * i;
  }
  fill(200);
  quad(baseX1,baseY1,baseX2,baseY2,baseX2,height,0,height);
  float baseDeltaX=(baseX2 - baseX1) / baseLength;
  float baseDeltaY=(baseY2 - baseY1) / baseLength;
  float normalX=-baseDeltaY;
  float normalY=baseDeltaX;
  noStroke();
  fill(255);
  ellipse(ellipseX,ellipseY,ellipseRadius * 2,ellipseRadius * 2);
  velocityX=directionX * ellipseSpeed;
  velocityY=directionY * ellipseSpeed;
  ellipseX+=velocityX;
  ellipseY+=velocityY;
  float incidenceVectorX=-directionX;
  float incidenceVectorY=-directionY;
  for (int i=0; i < xCoords.length; i++) {
    if (dist(ellipseX,ellipseY,xCoords[i],yCoords[i]) < ellipseRadius) {
      float dot=incidenceVectorX * normalX + incidenceVectorY * normalY;
      float reflectionVectorX=2 * normalX * dot - incidenceVectorX;
      float reflectionVectorY=2 * normalY * dot - incidenceVectorY;
      directionX=reflectionVectorX;
      directionY=reflectionVectorY;
      stroke(255,128,0);
      line(ellipseX,ellipseY,ellipseX - normalX * 100,ellipseY - normalY * 100);
    }
  }
  if (ellipseX > width - ellipseRadius) {
    ellipseX=width - ellipseRadius;
    directionX*=-1;
  }
  if (ellipseX < ellipseRadius) {
    ellipseX=ellipseRadius;
    directionX*=-1;
  }
  if (ellipseY < ellipseRadius) {
    ellipseY=ellipseRadius;
    directionY*=-1;
    baseY1=random(height - 100,height);
    baseY2=random(height - 100,height);
  }
}

{
  final String normalizedText=editor.getText().replaceAll("\r","");
  final String cleanText=normalizedText + (normalizedText.endsWith("\n") ? "" : "\n");
  result.setLength(0);
  indentValue=Preferences.getInteger("editor.tabs.size");
  lineNumber=0;
  q_flg=e_flg=a_flg=if_flg=false;
  s_flag=true;
  c_level=if_lev=level=paren=0;
  tabs=0;
  jdoc_flag=false;
  s_level=new int[10];
  sp_flg=new int[20][10];
  s_ind=new int[20][10];
  s_if_lev=new int[10];
  s_if_flg=new boolean[10];
  ind=new int[10];
  p_flg=new int[10];
  s_tabs=new int[20][10];
  pos=-1;
  chars=cleanText.toCharArray();
  lineNumber=1;
  EOF=false;
  try {
    while (!EOF) {
      c=next();
switch (c) {
default :
        currentLine.append(c);
      l_char=c;
    break;
case ',':
  trimRight(currentLine);
currentLine.append(c);
break;
case ' ':
case '\t':
if (lookup("else")) {
gotelse();
if ((!s_flag) || currentLine.length() > 0) {
currentLine.append(c);
}
writeIndentedLine();
s_flag=false;
break;
}
if ((!s_flag) || currentLine.length() > 0) {
currentLine.append(c);
}
break;
case '\n':
lineNumber++;
if (EOF) {
break;
}
e_flg=lookup("else");
if (e_flg) {
gotelse();
}
if (lookup_com("//")) {
final char lastChar=currentLine.charAt(currentLine.length() - 1);
if (lastChar == '\n') {
currentLine.setLength(currentLine.length() - 1);
}
}
writeIndentedLine();
result.append("\n");
s_flag=true;
if (e_flg) {
p_flg[level]++;
tabs++;
}
 else if (prev() == l_char) {
a_flg=true;
}
break;
case '{':
if (lookup("else")) {
gotelse();
}
if (s_if_lev.length == c_level) {
s_if_lev=PApplet.expand(s_if_lev);
s_if_flg=PApplet.expand(s_if_flg);
}
s_if_lev[c_level]=if_lev;
s_if_flg[c_level]=if_flg;
if_lev=0;
if_flg=false;
c_level++;
if (s_flag && p_flg[level] != 0) {
p_flg[level]--;
tabs--;
}
trimRight(currentLine);
if (currentLine.length() > 0 || (result.length() > 0 && !Character.isWhitespace(result.charAt(result.length() - 1)))) currentLine.append(" ");
currentLine.append(c);
writeIndentedLine();
getnl();
writeIndentedLine();
result.append("\n");
tabs++;
s_flag=true;
if (p_flg[level] > 0) {
ind[level]=1;
level++;
s_level[level]=c_level;
}
break;
case '}':
c_level--;
if (c_level < 0) {
c_level=0;
currentLine.append(c);
writeIndentedLine();
break;
}
if_lev=s_if_lev[c_level] - 1;
if (if_lev < 0) {
if_lev=0;
}
if_flg=s_if_flg[c_level];
trimRight(currentLine);
writeIndentedLine();
tabs--;
trimRight(result);
result.append("\n");
printIndentation();
result.append(c);
if (peek() == ';') {
result.append(next());
}
getnl();
writeIndentedLine();
result.append("\n");
s_flag=true;
if (c_level < s_level[level]) {
if (level > 0) {
level--;
}
}
if (ind[level] != 0) {
tabs-=p_flg[level];
p_flg[level]=0;
ind[level]=0;
}
break;
case '"':
case '\'':
currentLine.append(c);
cc=next();
while (!EOF && cc != c) {
currentLine.append(cc);
if (cc == '\\') {
currentLine.append(cc=next());
}
if (cc == '\n') {
lineNumber++;
writeIndentedLine();
s_flag=true;
}
cc=next();
}
currentLine.append(cc);
if (getnl()) {
l_char=cc;
chars[pos--]='\n';
}
break;
case ';':
currentLine.append(c);
writeIndentedLine();
if (p_flg[level] > 0 && ind[level] == 0) {
tabs-=p_flg[level];
p_flg[level]=0;
}
getnl();
writeIndentedLine();
result.append("\n");
s_flag=true;
if (if_lev > 0) {
if (if_flg) {
if_lev--;
if_flg=false;
}
 else {
if_lev=0;
}
}
break;
case '\\':
currentLine.append(c);
currentLine.append(next());
break;
case '?':
q_flg=true;
currentLine.append(c);
break;
case ':':
currentLine.append(c);
if (peek() == ':') {
writeIndentedLine();
result.append(next());
break;
}
if (q_flg) {
q_flg=false;
break;
}
if (!lookup("default") && !lookup("case")) {
s_flag=false;
writeIndentedLine();
}
 else {
tabs--;
writeIndentedLine();
tabs++;
}
if (peek() == ';') {
result.append(next());
}
getnl();
writeIndentedLine();
result.append("\n");
s_flag=true;
break;
case '/':
final char la=peek();
if (la == '/') {
currentLine.append(c).append(next());
handleSingleLineComment();
result.append("\n");
}
 else if (la == '*') {
if (currentLine.length() > 0) {
writeIndentedLine();
}
currentLine.append(c).append(next());
comment();
}
 else {
currentLine.append(c);
}
break;
case ')':
paren--;
if (paren < 0) {
paren=0;
}
currentLine.append(c);
writeIndentedLine();
if (getnl()) {
chars[pos--]='\n';
if (paren != 0) {
a_flg=true;
}
 else if (tabs > 0) {
p_flg[level]++;
tabs++;
ind[level]=0;
}
}
break;
case '(':
currentLine.append(c);
paren++;
if ((lookup("for"))) {
c=get_string();
while (c != ';') {
c=get_string();
}
ct=0;
int for_done=0;
while (for_done == 0) {
c=get_string();
while (c != ')') {
if (c == '(') {
ct++;
}
c=get_string();
}
if (ct != 0) {
ct--;
}
 else {
for_done=1;
}
}
paren--;
if (paren < 0) {
paren=0;
}
writeIndentedLine();
if (getnl()) {
chars[pos--]='\n';
p_flg[level]++;
tabs++;
ind[level]=0;
}
break;
}
if (lookup("if")) {
writeIndentedLine();
s_tabs[c_level][if_lev]=tabs;
sp_flg[c_level][if_lev]=p_flg[level];
s_ind[c_level][if_lev]=ind[level];
if_lev++;
if_flg=true;
}
}
}
int selectionEnd=editor.getSelectionStop();
if (result.length() < selectionEnd - 1) {
selectionEnd=result.length() - 1;
}
final String formattedText=result.toString();
if (formattedText.equals(cleanText)) {
editor.statusNotice("No changes necessary for Auto Format.");
}
 else if (paren != 0) {
editor.statusError("Auto Format Canceled: Too many " + ((paren < 0) ? "right" : "left") + " parentheses.");
}
 else if (c_level != 0) {
editor.statusError("Auto Format Canceled: Too many " + ((c_level < 0) ? "right" : "left") + " curly braces.");
}
 else {
editor.setText(formattedText);
editor.setSelection(selectionEnd,selectionEnd);
editor.getSketch().setModified(true);
editor.statusNotice("Auto Format finished.");
}
}
 catch (final Exception e) {
editor.statusError(e);
}
}

{
  if (x > colorMaxX)   x=colorMaxX;
  if (y > colorMaxY)   y=colorMaxY;
  if (z > colorMaxZ)   z=colorMaxZ;
  if (a > colorMaxA)   a=colorMaxA;
  if (x < 0)   x=0;
  if (y < 0)   y=0;
  if (z < 0)   z=0;
  if (a < 0)   a=0;
switch (color_mode) {
case RGB:
    if (color_scale) {
      calcR=x / colorMaxX;
      calcG=y / colorMaxY;
      calcB=z / colorMaxZ;
      calcA=a / colorMaxA;
    }
 else {
      calcR=x;
      calcG=y;
      calcB=z;
      calcA=a;
    }
  break;
case HSB:
x/=colorMaxX;
y/=colorMaxY;
z/=colorMaxZ;
calcA=color_scale ? (a / colorMaxA) : a;
if (y == 0) {
calcR=calcG=calcB=z;
}
 else {
float which=(x - (int)x) * 6.0f;
float f=which - (int)which;
float p=z * (1.0f - y);
float q=z * (1.0f - y * f);
float t=z * (1.0f - (y * (1.0f - f)));
switch ((int)which) {
case 0:
calcR=z;
calcG=t;
calcB=p;
break;
case 1:
calcR=q;
calcG=z;
calcB=p;
break;
case 2:
calcR=p;
calcG=z;
calcB=t;
break;
case 3:
calcR=p;
calcG=q;
calcB=z;
break;
case 4:
calcR=t;
calcG=p;
calcB=z;
break;
case 5:
calcR=z;
calcG=p;
calcB=q;
break;
}
}
break;
}
calcRi=(int)(255 * calcR);
calcGi=(int)(255 * calcG);
calcBi=(int)(255 * calcB);
calcAi=(int)(255 * calcA);
calci=(calcAi << 24) | (calcRi << 16) | (calcGi << 8)| calcBi;
calc_alpha=(calcAi != 255);
}

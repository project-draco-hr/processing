{
  shape=false;
  vertex_end=vertex_count;
  int increment=1;
  int stop=0;
  int counter=0;
  boolean check=_stroke || smooth;
  if (textureImage != null && textureImage.format == ALPHA) {
    check=false;
  }
  if (check) {
switch (shapeKind) {
case POINTS:
{
        stop=vertex_end;
        for (int i=vertex_start; i < stop; i++) {
          addLine(i,i);
        }
      }
    break;
case LINES:
case LINE_STRIP:
case LINE_LOOP:
{
    int first=lines_count;
    stop=vertex_end - 1;
    increment=(shapeKind == LINES) ? 2 : 1;
    for (int i=vertex_start; i < stop; i+=increment) {
      addLine(i,i + 1);
    }
    if (shapeKind == LINE_LOOP) {
      addLine(stop,lines[first][PA]);
    }
  }
break;
case TRIANGLES:
case TRIANGLE_STRIP:
{
stop=vertex_end - 1;
for (int i=vertex_start; i < stop; i++) {
  counter=i - vertex_start;
  addLine(i,i + 1);
  if ((shapeKind == TRIANGLES) && (counter % 3 == 1)) {
    i++;
  }
}
stop=vertex_end - 2;
increment=(shapeKind == TRIANGLE_STRIP) ? 1 : 3;
for (int i=vertex_start; i < stop; i+=increment) {
  addLine(i,i + 2);
}
}
break;
case QUADS:
case QUAD_STRIP:
{
stop=vertex_end - 1;
for (int i=vertex_start; i < stop; i++) {
counter=i - vertex_start;
addLine(i,i + 1);
if ((shapeKind == QUADS) && (counter % 4 == 2)) {
i++;
}
}
stop=vertex_end - 2;
increment=(shapeKind == QUAD_STRIP) ? 2 : 4;
for (int i=vertex_start; i < stop; i+=increment) {
addLine(i,i + 3);
}
}
break;
case POLYGON:
case CONCAVE_POLYGON:
case CONVEX_POLYGON:
{
int first=lines_count;
stop=vertex_end - 1;
for (int i=vertex_start; i < stop; i++) {
addLine(i,i + 1);
}
addLine(stop,lines[first][PA]);
}
break;
}
}
if (_fill) {
switch (shapeKind) {
case TRIANGLES:
case TRIANGLE_STRIP:
{
stop=vertex_end - 2;
increment=(shapeKind == TRIANGLES) ? 3 : 1;
for (int i=vertex_start; i < stop; i+=increment) {
addTriangle(i,i + 1,i + 2);
}
}
break;
case QUADS:
case QUAD_STRIP:
{
stop=vertex_count - 3;
increment=(shapeKind == QUADS) ? 4 : 2;
for (int i=vertex_start; i < stop; i+=increment) {
addTriangle(i,i + 1,i + 2);
addTriangle(i,i + 2,i + 3);
}
}
break;
case POLYGON:
case CONCAVE_POLYGON:
case CONVEX_POLYGON:
{
triangulate_polygon();
}
break;
}
}
if ((camera_mode != CUSTOM) && (dimensions == 0)) {
for (int i=vertex_start; i < vertex_end; i++) {
vertices[i][X]=vertices[i][MX];
vertices[i][Y]=vertices[i][MY];
}
}
 else if ((camera_mode != CUSTOM) && (dimensions == 2)) {
for (int i=vertex_start; i < vertex_end; i++) {
vertices[i][X]=m00 * vertices[i][MX] + m01 * vertices[i][MY] + m03;
vertices[i][Y]=m10 * vertices[i][MX] + m11 * vertices[i][MY] + m13;
}
}
 else {
for (int i=vertex_start; i < vertex_end; i++) {
float vertex[]=vertices[i];
vertex[VX]=m00 * vertex[MX] + m01 * vertex[MY] + m02 * vertex[MZ] + m03;
vertex[VY]=m10 * vertex[MX] + m11 * vertex[MY] + m12 * vertex[MZ] + m13;
vertex[VZ]=m20 * vertex[MX] + m21 * vertex[MY] + m22 * vertex[MZ] + m23;
vertex[VW]=m30 * vertex[MX] + m31 * vertex[MY] + m32 * vertex[MZ] + m33;
}
}
if (!normalChanged) {
vertices[vertex_start][NX]=normalX;
vertices[vertex_start][NY]=normalY;
vertices[vertex_start][NZ]=normalZ;
}
for (int i=vertex_start; i < (normalChanged ? vertex_end : 1); i++) {
float v[]=vertices[i];
float nx=m00 * v[NX] + m01 * v[NY] + m02 * v[NZ] + m03;
float ny=m10 * v[NX] + m11 * v[NY] + m12 * v[NZ] + m13;
float nz=m20 * v[NX] + m21 * v[NY] + m22 * v[NZ] + m23;
float nw=m30 * v[NX] + m31 * v[NY] + m32 * v[NZ] + m33;
if (nw != 0) {
v[NX]=nx / nw;
v[NY]=ny / nw;
v[NZ]=nz / nw;
}
 else {
v[NX]=nx;
v[NY]=ny;
v[NZ]=nz;
}
float nlen=mag(v[NX],v[NY],v[NZ]);
if (nlen != 0) {
v[NX]/=nlen;
v[NY]/=nlen;
v[NZ]/=nlen;
}
}
if (!lighting) {
}
 else {
float f[]=vertices[vertex_start];
for (int i=vertex_start; i < vertex_end; i++) {
float v[]=vertices[i];
if (normalChanged) {
if (_fill) {
calc_lighting(v[R],v[G],v[B],v[MX],v[MY],v[MZ],v[NX],v[NY],v[NZ],v,R);
}
if (_stroke) {
calc_lighting(v[SR],v[SG],v[SB],v[MX],v[MY],v[MZ],v[NX],v[NY],v[NZ],v,SR);
}
}
 else {
if (_fill) {
calc_lighting(v[R],v[G],v[B],v[MX],v[MY],v[MZ],f[NX],f[NY],f[NZ],v,R);
}
if (_stroke) {
calc_lighting(v[SR],v[SG],v[SB],v[MX],v[MY],v[MZ],f[NX],f[NY],f[NZ],v,SR);
}
}
}
}
if ((camera_mode == PERSPECTIVE) && (dimensions == 3)) {
for (int i=vertex_start; i < vertex_end; i++) {
float vx[]=vertices[i];
float ox=p00 * vx[VX] + p01 * vx[VY] + p02 * vx[VZ] + p03 * vx[VW];
float oy=p10 * vx[VX] + p11 * vx[VY] + p12 * vx[VZ] + p13 * vx[VW];
float oz=p20 * vx[VX] + p21 * vx[VY] + p22 * vx[VZ] + p23 * vx[VW];
float ow=p30 * vx[VX] + p31 * vx[VY] + p32 * vx[VZ] + p33 * vx[VW];
if (ow != 0) {
ox/=ow;
oy/=ow;
oz/=ow;
}
vx[X]=width * (ONE + ox) / 2.0f;
vx[Y]=height * (ONE + oy) / 2.0f;
vx[Z]=(oz + ONE) / 2.0f;
}
}
if (z_order == true) {
return;
}
if (_fill) {
for (int i=0; i < triangles_count; i++) {
float a[]=vertices[triangles[i][VA]];
float b[]=vertices[triangles[i][VB]];
float c[]=vertices[triangles[i][VC]];
int index=triangles[i][TI];
if (textureImage != null) {
triangle.setUV(a[U],a[V],b[U],b[V],c[U],c[V]);
}
triangle.setIntensities(a[R],a[G],a[B],a[A],b[R],b[G],b[B],b[A],c[R],c[G],c[B],c[A]);
triangle.setVertices(a[X],a[Y],a[Z],b[X],b[Y],b[Z],c[X],c[Y],c[Z]);
triangle.setIndex(index);
triangle.render();
}
}
if (_stroke || smooth) {
for (int i=0; i < lines_count; i++) {
float a[]=vertices[lines[i][PA]];
float b[]=vertices[lines[i][PB]];
int index=lines[i][LI];
line.setIntensities(a[SR],a[SG],a[SB],a[SA],b[SR],b[SG],b[SB],b[SA]);
line.setVertices(a[X],a[Y],a[Z],b[X],b[Y],b[Z]);
line.setIndex(index);
line.draw();
}
}
shapeKind=0;
}

{
switch (ellipse_mode) {
case CENTER_RADIUS:
    break;
case CENTER:
  hradius/=2f;
vradius/=2f;
break;
case CORNER:
hradius/=2f;
vradius/=2f;
x+=hradius;
y+=vradius;
break;
case CORNERS:
hradius-=x;
vradius-=y;
break;
}
int cAccuracy=(int)(4 + Math.sqrt(hradius + vradius) * 3);
boolean plain=!lighting && !smooth && (strokeWeight == 1)&& !fill_alpha&& !stroke_alpha;
boolean flat=(dimensions == 0) || ((dimensions == 2) && (m00 == m11) && (m00 == 1));
if (plain && flat) {
if (hradius == vradius) {
flat_circle((int)x,(int)y,(int)hradius);
}
 else {
flat_ellipse((int)x,(int)y,(int)hradius,(int)vradius);
}
}
 else {
float inc=(float)SINCOS_LENGTH / cAccuracy;
float val=0;
beginShape(POLYGON);
for (int i=0; i < cAccuracy; i++) {
vertex(x + cosLUT[(int)val] * hradius,y + sinLUT[(int)val] * vradius);
val+=inc;
}
if (!hints[NEW_GRAPHICS]) {
vertex(x + cosLUT[0] * hradius,y + sinLUT[0] * vradius);
}
endShape();
}
}

{
  int cAccuracy=(int)(4 + Math.sqrt(hradius + vradius) * 3);
  boolean plain=!lights && !smooth && (strokeWeight == 1)&& !fillAlpha&& !strokeAlpha;
  boolean flat=(dimensions == 0) || ((dimensions == 2) && (m00 == m11) && (m00 == 1));
  if (plain && flat) {
    if (hradius == vradius) {
      flat_circle((int)x,(int)y,(int)hradius);
    }
 else {
      flat_ellipse((int)x,(int)y,(int)hradius,(int)vradius);
    }
  }
 else {
    float inc=(float)SINCOS_LENGTH / cAccuracy;
    float val=0;
    beginShape(POLYGON);
    for (int i=0; i < cAccuracy; i++) {
      vertex(x + cosLUT[(int)val] * hradius,y + sinLUT[(int)val] * vradius);
      val+=inc;
    }
    endShape();
  }
}

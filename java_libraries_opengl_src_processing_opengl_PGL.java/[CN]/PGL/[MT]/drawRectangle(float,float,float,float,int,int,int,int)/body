{
  if (!loadedRectShader) {
    rectVertShader=createShader(GL_VERTEX_SHADER,rectVertShaderSource);
    rectFragShader=createShader(GL_FRAGMENT_SHADER,rectFragShaderSource);
    if (0 < rectVertShader && 0 < rectFragShader) {
      rectShaderProgram=createProgram(rectVertShader,rectFragShader);
    }
    if (0 < rectShaderProgram) {
      rectVertLoc=glGetAttribLocation(rectShaderProgram,"inVertex");
      rectColorLoc=glGetUniformLocation(rectShaderProgram,"rectColor");
    }
    rectData=ByteBuffer.allocateDirect(rectCoords.length * SIZEOF_FLOAT).order(ByteOrder.nativeOrder()).asFloatBuffer();
    loadedRectShader=true;
  }
  if (0 < rectShaderProgram) {
    boolean[] val=new boolean[1];
    glGetBooleanv(GL_DEPTH_WRITEMASK,val,0);
    boolean writeMask=val[0];
    glDepthMask(false);
    glUseProgram(rectShaderProgram);
    glEnableVertexAttribArray(rectVertLoc);
    glUniform4f(rectColorLoc,r,g,b,a);
    rectCoords[0]=2 * (float)scrX0 / pg.width - 1;
    rectCoords[1]=2 * (float)scrY0 / pg.height - 1;
    rectCoords[2]=2 * (float)scrX1 / pg.width - 1;
    rectCoords[3]=2 * (float)scrY0 / pg.height - 1;
    rectCoords[4]=2 * (float)scrX0 / pg.width - 1;
    rectCoords[5]=2 * (float)scrY1 / pg.height - 1;
    rectCoords[6]=2 * (float)scrX1 / pg.width - 1;
    rectCoords[7]=2 * (float)scrY1 / pg.height - 1;
    rectData.rewind();
    rectData.put(rectCoords);
    rectData.position(0);
    glVertexAttribPointer(rectVertLoc,2,GL_FLOAT,false,2 * SIZEOF_FLOAT,rectData);
    glDrawArrays(GL_TRIANGLE_STRIP,0,4);
    glDisableVertexAttribArray(rectVertLoc);
    glUseProgram(0);
    glDepthMask(writeMask);
  }
}
